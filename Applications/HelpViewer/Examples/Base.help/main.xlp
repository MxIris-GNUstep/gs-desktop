<document>The GNUstep base library is a free software package implementing
        the API of the OpenStep Foundation Kit (tm), including later
	additions.  This documentation package describes the core of the
	base library, for documentation on additional classes, see the
	BaseAdditions documentation package.
    <chapter name="GSXMLParser">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXMLParser">GSXMLParser</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="loadEntity:at:">
<label id="method**GSXMLParser**+loadEntity:at:" />+ <code>(NSString*) </code>
          <b>loadEntity: </b>
          <code>(NSString*) </code><i>publicId </i>
          <b>at: </b>
          <code>(NSString*) </code><i>location </i>
          <br><em>Description forthcoming.</em>


        



<section name="parser">
<label id="method**GSXMLParser**+parser" />+ <code>(GSXMLParser*) </code>
          <b>parser </b>
          <br><em>Description forthcoming.</em>


        



<section name="parserWithContentsOfFile:">
<label id="method**GSXMLParser**+parserWithContentsOfFile:" />+ <code>(GSXMLParser*) </code>
          <b>parserWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="parserWithContentsOfURL:">
<label id="method**GSXMLParser**+parserWithContentsOfURL:" />+ <code>(GSXMLParser*) </code>
          <b>parserWithContentsOfURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br><em>Description forthcoming.</em>


        



<section name="parserWithData:">
<label id="method**GSXMLParser**+parserWithData:" />+ <code>(GSXMLParser*) </code>
          <b>parserWithData: </b>
          <code>(NSData*) </code><i>data </i>
          <br><em>Description forthcoming.</em>


        



<section name="parserWithSAXHandler:">
<label id="method**GSXMLParser**+parserWithSAXHandler:" />+ <code>(GSXMLParser*) </code>
          <b>parserWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <br><em>Description forthcoming.</em>


        



<section name="parserWithSAXHandler:withContentsOfFile:">
<label id="method**GSXMLParser**+parserWithSAXHandler:withContentsOfFile:" />+ <code>(GSXMLParser*) </code>
          <b>parserWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <b>withContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="parserWithSAXHandler:withContentsOfURL:">
<label id="method**GSXMLParser**+parserWithSAXHandler:withContentsOfURL:" />+ <code>(GSXMLParser*) </code>
          <b>parserWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <b>withContentsOfURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br><em>Description forthcoming.</em>


        



<section name="parserWithSAXHandler:withData:">
<label id="method**GSXMLParser**+parserWithSAXHandler:withData:" />+ <code>(GSXMLParser*) </code>
          <b>parserWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <b>withData: </b>
          <code>(NSData*) </code><i>data </i>
          <br><em>Description forthcoming.</em>


        



<section name="xmlEncodingStringForStringEncoding:">
<label id="method**GSXMLParser**+xmlEncodingStringForStringEncoding:" />+ <code>(NSString*) </code>
          <b>xmlEncodingStringForStringEncoding: </b>
          <code>(NSStringEncoding) </code><i>encoding </i>
          <br><em>Description forthcoming.</em>


        



<section name="doValidityChecking:">
<label id="method**GSXMLParser**-doValidityChecking:" />- <code>(BOOL) </code>
          <b>doValidityChecking: </b>
          <code>(BOOL) </code><i>yesno </i>
          <br><em>Description forthcoming.</em>


        



<section name="document">
<label id="method**GSXMLParser**-document" />- <code>(GSXMLDocument*) </code>
          <b>document </b>
          <br><em>Description forthcoming.</em>


        



<section name="errNo">
<label id="method**GSXMLParser**-errNo" />- <code>(int) </code>
          <b>errNo </b>
          <br><em>Description forthcoming.</em>


        



<section name="getWarnings:">
<label id="method**GSXMLParser**-getWarnings:" />- <code>(BOOL) </code>
          <b>getWarnings: </b>
          <code>(BOOL) </code><i>yesno </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithSAXHandler:">
<label id="method**GSXMLParser**-initWithSAXHandler:" />- <code>(id) </code>
          <b>initWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithSAXHandler:withContentsOfFile:">
<label id="method**GSXMLParser**-initWithSAXHandler:withContentsOfFile:" />- <code>(id) </code>
          <b>initWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <b>withContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithSAXHandler:withContentsOfURL:">
<label id="method**GSXMLParser**-initWithSAXHandler:withContentsOfURL:" />- <code>(id) </code>
          <b>initWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <b>withContentsOfURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithSAXHandler:withData:">
<label id="method**GSXMLParser**-initWithSAXHandler:withData:" />- <code>(id) </code>
          <b>initWithSAXHandler: </b>
          <code>(GSSAXHandler*) </code><i>handler </i>
          <b>withData: </b>
          <code>(NSData*) </code><i>data </i>
          <br><em>Description forthcoming.</em>


        



<section name="keepBlanks:">
<label id="method**GSXMLParser**-keepBlanks:" />- <code>(BOOL) </code>
          <b>keepBlanks: </b>
          <code>(BOOL) </code><i>yesno </i>
          <br><em>Description forthcoming.</em>


        



<section name="parse">
<label id="method**GSXMLParser**-parse" />- <code>(BOOL) </code>
          <b>parse </b>
          <br><em>Description forthcoming.</em>


        



<section name="parse:">
<label id="method**GSXMLParser**-parse:" />- <code>(BOOL) </code>
          <b>parse: </b>
          <code>(NSData*) </code><i>data </i>
          <br><em>Description forthcoming.</em>


        



<section name="substituteEntities:">
<label id="method**GSXMLParser**-substituteEntities:" />- <code>(BOOL) </code>
          <b>substituteEntities: </b>
          <code>(BOOL) </code><i>yesno </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSPortMessage">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSPortMessage">NSPortMessage</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSPortMessage.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="components">
<label id="method**NSPortMessage**-components" />- <code>(NSArray*) </code>
          <b>components </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithMachMessage:">
<label id="method**NSPortMessage**-initWithMachMessage:" />- <code>(id) </code>
          <b>initWithMachMessage: </b>
          <code>(void*) </code><i>buffer </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithSendPort:receivePort:components:">
<label id="method**NSPortMessage**-initWithSendPort:receivePort:components:" />- <code>(id) </code>
          <b>initWithSendPort: </b>
          <code>(NSPort*) </code><i>aPort </i>
          <b>receivePort: </b>
          <code>(NSPort*) </code><i>anotherPort </i>
          <b>components: </b>
          <code>(NSArray*) </code><i>items </i>
          <br><em>Description forthcoming.</em>


        



<section name="msgid">
<label id="method**NSPortMessage**-msgid" />- <code>(unsigned) </code>
          <b>msgid </b>
          <br><em>Description forthcoming.</em>


        



<section name="receivePort">
<label id="method**NSPortMessage**-receivePort" />- <code>(NSPort*) </code>
          <b>receivePort </b>
          <br><em>Description forthcoming.</em>


        



<section name="sendBeforeDate:">
<label id="method**NSPortMessage**-sendBeforeDate:" />- <code>(BOOL) </code>
          <b>sendBeforeDate: </b>
          <code>(NSDate*) </code><i>when </i>
          <br><em>Description forthcoming.</em>


        



<section name="sendPort">
<label id="method**NSPortMessage**-sendPort" />- <code>(NSPort*) </code>
          <b>sendPort </b>
          <br><em>Description forthcoming.</em>


        



<section name="setMsgid:">
<label id="method**NSPortMessage**-setMsgid:" />- <code>(void) </code>
          <b>setMsgid: </b>
          <code>(unsigned) </code><i>anId </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSObject">


<section name="Overview">
<b>Inherits From:  </b>None, is a root class
<br><b>Conforms to: </b>NSObject
<br><b>Declared in: </b>NSObject.h
</section>

<section name="Description">
<br><code>NSObject</code> is the root class (a root
            class is a class with no superclass) of the gnustep
            base library class hierarchy, so all classes normally
            inherit from <code>NSObject</code>. There is an
            exception though: <code>NSProxy</code> (which is
            used for remote messaging) does not inherit from
            <code>NSObject</code>.
          Unless you are really sure of what you are doing,
            all your own classes should inherit (directly or
            indirectly) from <code>NSObject</code> (or in
            special cases from <code>NSProxy</code>).
            <code>NSObject</code> provides the basic common
            functionality shared by all gnustep classes
            and objects.
          The essential methods which must be implemented by all
            classes for their instances to be usable within
            gnustep are declared in a separate protocol, which
            is the <code>NSObject</code> protocol. Both
            <code>NSObject</code> and <code>NSProxy</code>
            conform to this protocol, which means all objects
            in a gnustep application will conform to this protocol
            (btw, if you don't find a method of
            <code>NSObject</code> you are looking for in this
            documentation, make sure you also look into
            the documentation for the <code>NSObject</code>
            protocol).
          Theoretically, in special cases you might
            need to implement a new root class. If you do, you
            need to make sure that your root class conforms (at
            least) to the <code>NSObject</code> protocol,
            otherwise it will not interact correctly with the
            gnustep framework. Said that, I must note that I
            have never seen a case in which a new root class is
            needed.
          <code>NSObject</code> is a root class, which implies
            that instance methods of <code>NSObject</code> are
            treated in a special way by the Objective-C
            runtime. This is an exception to the normal way
            messaging works with class and instance methods:
            if the Objective-C runtime can't find a class method for
            a class object, as a last resort it looks for an instance
            method of the root class with the same name, and
            executes it if it finds it. This means that
            instance methods of the root class (such as
            <code>NSObject</code>) can be performed by class
            objects which inherit from that root class ! This
            can only happen if the class doesn't have a class
            method with the same name, otherwise that method -
            of course - takes the precedence. Because of this
            exception, <code>NSObject</code> 's instance
            methods are written in such a way that they work
            both on <code>NSObject</code> 's instances and on
            class objects.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="alloc">
<label id="method**NSObject**+alloc" />+ <code>(id) </code>
          <b>alloc </b>
          <br>Allocates a new instance of the receiver from the
            default zone, by invoking
            <ref id="method**NSObject**+allocWithZone:">
              +allocWithZone:
            </ref>
            with
            <code><ref id="function**NSObject**NSDefaultMallocZone">
                NSDefaultMallocZone()
              </ref></code>
            as the zone argument. 
<br>
 Returns the created
            instance.


        



<section name="allocWithZone:">
<label id="method**NSObject**+allocWithZone:" />+ <code>(id) </code>
          <b>allocWithZone: </b>
          <code>(NSZone*) </code><i>z </i>
          <br>This is the basic method to create a new instance. It
            allocates a new instance of the receiver from the
            specified memory zone.
            Memory for an instance of the receiver is
              allocated; a pointer to this newly created
              instance is returned. All instance variables are
              set to 0 except the <code>isa</code> pointer which is
              set to point to the object class. No initialization
              of the instance is performed: it is your
              responsibility to initialize the instance
              by calling an appropriate <code>init</code> method. If
              you are not using the garbage collector, it is also
              your responsibility to make sure the returned
              instance is destroyed when you finish using it,
              by calling the <code>release</code> method to destroy
              the instance directly, or by using
              <code>autorelease</code> and autorelease pools.
            You do not normally need to override this method in
              subclasses, unless you are implementing a
              class which for some reasons silently allocates
              instances of another class (this is typically
              needed to implement class clusters and similar
              design schemes).
            If you have turned on debugging of object allocation
              (by calling the <code>GSDebugAllocationActive</code>
              function), this method will also update the
              various debugging counts and monitors of
              allocated objects, which you can access using
              the <code>GSDebugAllocation...</code> functions.


        



<section name="class">
<label id="method**NSObject**+class" />+ <code>(Class) </code>
          <b>class </b>
          <br>Returns the receiver.


        



<section name="description">
<label id="method**NSObject**+description" />+ <code>(NSString*) </code>
          <b>description </b>
          <br>Returns a string describing the receiving class.
            The default implementation gives the name of the class
            by calling
            <ref id="function**NSObject**NSStringFromClass">
              NSStringFromClass()
            </ref>
            .


        



<section name="initialize">
<label id="method**NSObject**+initialize" />+ <code>(void) </code>
          <b>initialize </b>
          <br><em>Description forthcoming.</em>


        



<section name="instanceMethodForSelector:">
<label id="method**NSObject**+instanceMethodForSelector:" />+ <code>(IMP) </code>
          <b>instanceMethodForSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Returns a pointer to the C function implementing
            the method used to respond to messages with
            <i>aSelector</i> by instances of the receiving
            class. 
<br>
 Raises NSInvalidArgumentException if
            given a null selector.


        



<section name="instanceMethodSignatureForSelector:">
<label id="method**NSObject**+instanceMethodSignatureForSelector:" />+ <code>(NSMethodSignature*) </code>
          <b>instanceMethodSignatureForSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Returns a pointer to the C function implementing
            the method used to respond to messages with
            <i>aSelector</i> whihc are sent to instances of
            the receiving class. 
<br>
 Raises
            NSInvalidArgumentException if
            given a null selector.


        



<section name="instancesRespondToSelector:">
<label id="method**NSObject**+instancesRespondToSelector:" />+ <code>(BOOL) </code>
          <b>instancesRespondToSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Returns a flag to say if instances of the receiver
            class will respond to the specified selector. This
            ignores situations where a subclass implements
            <ref id="method**NSObject**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            to respond to selectors not normally handled... in these
            cases the subclass may override this method to handle
            it. 
<br>
 Raises NSInvalidArgumentException if given a
            null selector.


        



<section name="isSubclassOfClass:">
<label id="method**NSObject**+isSubclassOfClass:" />+ <code>(BOOL) </code>
          <b>isSubclassOfClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Returns <code>YES</code> if the receiver is
            <i>aClass</i> or a subclass of <i>aClass</i>.


        



<section name="new">
<label id="method**NSObject**+new" />+ <code>(id) </code>
          <b>new </b>
          <br>This method is a short-hand for alloc followed by
              init, that is,
            <code>NSObject *object = [NSObject new];</code>
            is exactly the same as
            <code>NSObject *object = [[NSObject alloc] init];</code>
            This is a general convention: all
              <code>new...</code> methods are supposed to return
              a newly allocated and initialized instance, as would be
              generated by an <code>alloc</code> method
              followed by a corresponding <code>init...</code>
              method. Please note that if you are not using a
              garbage collector, this means that instances
              generated by the <code>new...</code> methods
              are not autoreleased, that is, you are responsible
              for releasing (autoreleasing) the instances yourself.
              So when you use <code>new</code> you typically do
              something like:
            <code>NSMutableArray *array = AUTORELEASE
                ([NSMutableArray new]);</code>
            You do not normally need to override <code>new</code>
              in subclasses, because if you override
              <code>init</code> (and optionally
              <code>allocWithZone:</code> if you really need),
              <code>new</code> will automatically use your
              subclass methods.
            You might need instead to define new
              <code>new...</code> methods specific to your
              subclass to match any <code>init...</code>
              specific to your subclass. For example, if your
              subclass defines an instance method
            <code>initWithName:</code>
            it might be handy for you to have a class method
            <code>newWithName:</code>
            which combines <code>alloc</code> and
              <code>initWithName:</code>. You would implement it
              as follows:
            <code>+ (id) newWithName: (NSString *)aName {return [[self
                alloc] initWithName: aName];}</code>


        



<section name="poseAsClass:">
<label id="method**NSObject**+poseAsClass:" />+ <code>(void) </code>
          <b>poseAsClass: </b>
          <code>(Class) </code><i>aClassObject </i>
          <br>Sets up the ObjC runtime so that the receiver is used
            wherever code calls for <i>aClassObject</i> to
            be used.


        



<section name="requiresTypedMemory">
<label id="method**NSObject**+requiresTypedMemory" />+ <code>(BOOL) </code>
          <b>requiresTypedMemory </b>
          <br><em>Description forthcoming.</em>


        



<section name="setVersion:">
<label id="method**NSObject**+setVersion:" />+ <code>(id) </code>
          <b>setVersion: </b>
          <code>(int) </code><i>aVersion </i>
          <br>Sets the version number of the receiving class.


        



<section name="superclass">
<label id="method**NSObject**+superclass" />+ <code>(Class) </code>
          <b>superclass </b>
          <br>Returns the super class from which the recevier was
            derived.


        



<section name="version">
<label id="method**NSObject**+version" />+ <code>(int) </code>
          <b>version </b>
          <br>Returns the version number of the receiving class.


        



<section name="autorelease">
<label id="method**NSObject**-autorelease" />- <code>(id) </code>
          <b>autorelease </b>
          <br>Adds the receiver to the current autorelease pool, so
            that it will be sent a
            <ref id="method**NSObject**-release">
              -release
            </ref>
            message when the pool is destroyed. 
<br>
 Returns
            the receiver. 
<br>
 In GNUstep, the
            <ref id="method**NSObject**+enableDoubleReleaseCheck:">[NSObject% unknown entity: nbsp
+enableDoubleReleaseCheck:]</ref> method may be used to turn on checking for ratain/release errors in this method.


        



<section name="awakeAfterUsingCoder:">
<label id="method**NSObject**-awakeAfterUsingCoder:" />- <code>(id) </code>
          <b>awakeAfterUsingCoder: </b>
          <code>(NSCoder*) </code><i>aDecoder </i>
          <br>Called after the receiver has been created by
            decoding some sort of archive. Returns self.
            Subclasses may override this to perform some
            special initialisation upon being decoded.


        



<section name="class">
<label id="method**NSObject**-class" />- <code>(Class) </code>
          <b>class </b>
          <br>Returns the class of which the receiver is an
            instance. 
<br>
 The default implementation
            returns the private <code>isa</code> instance
            variable of NSObject, which is used to store a
            pointer to the objects class. 
<br>
 NB. When
            NSZombie is enabled (see NSDebug.h) this pointer
            is changed upon object deallocation.


        



<section name="classForArchiver">
<label id="method**NSObject**-classForArchiver" />- <code>(Class) </code>
          <b>classForArchiver </b>
          <br><em>Description forthcoming.</em>


        



<section name="classForCoder">
<label id="method**NSObject**-classForCoder" />- <code>(Class) </code>
          <b>classForCoder </b>
          <br><em>Description forthcoming.</em>


        



<section name="classForPortCoder">
<label id="method**NSObject**-classForPortCoder" />- <code>(Class) </code>
          <b>classForPortCoder </b>
          <br><em>Description forthcoming.</em>


        



<section name="className">
<label id="method**NSObject**-className" />- <code>(NSString*) </code>
          <b>className </b>
          <br>Returns the name of the class of the receiving
            object by using the
            <ref id="function**NSObject**NSStringFromClass">
              NSStringFromClass()
            </ref>
            function. 
<br>
 This is a MacOS-X addition for
            apple scripting, which is also generally useful.


        



<section name="conformsToProtocol:">
<label id="method**NSObject**-conformsToProtocol:" />- <code>(BOOL) </code>
          <b>conformsToProtocol: </b>
          <code>(Protocol*) </code><i>aProtocol </i>
          <br>Returns a flag to say whether the class of the
            receiver conforms to <i>aProtocol</i>.


        



<section name="copy">
<label id="method**NSObject**-copy" />- <code>(id) </code>
          <b>copy </b>
          <br>Creates and returns a copy of the reciever by
            calling
            <ref id="method**NSObject**-copyWithZone:">
              -copyWithZone:
            </ref>
            passing
            <ref id="function**NSObject**NSDefaultMallocZone">
              NSDefaultMallocZone()
            </ref>


        



<section name="dealloc">
<label id="method**NSObject**-dealloc" />- <code>(void) </code>
          <b>dealloc </b>
          <br>Deallocates the receiver by calling
            <ref id="function**NSObject**NSDeallocateObject">
              NSDeallocateObject()
            </ref>
            with self as the argument. 
<br>

            You should normally call the superclass
              implementation of this method when you
              override it in a subclass, or the memory
              occupied by your object will not be released.
            <code>NSObject</code> 's implementation of this
              method destroys the receiver, by returning the
              memory allocated to the receiver to the system.
              After this method has been called on an instance,
              you must not refer the instance in any way, because
              it does not exist any longer. If you do, it is a bug
              and your program might even crash with a segmentation
              fault.
            If you have turned on the debugging facilities for
              instance allocation, <code>NSObject</code> 's
              implementation of this method will also
              update the various counts and monitors of
              allocated instances (see the
              <code>GSDebugAllocation...</code> functions for
              more info).
            Normally you are supposed to manage the memory
              taken by objects by using the high level interface
              provided by the <code>retain</code>,
              <code>release</code> and <code>autorelease</code>
              methods (or better by the corresponding macros
              <code>RETAIN</code>, <code>RELEASE</code> and
              <code>AUTORELEASE</code>), and by autorelease
              pools and such; whenever the release/autorelease
              mechanism determines that an object is no
              longer needed (which happens when its retain count
              reaches 0), it will call the <code>dealloc</code>
              method to actually deallocate the object. This
              means that normally, you should not need to call
              <code>dealloc</code> directly as the gnustep base
              library automatically calls it for you when the
              retain count of an object reaches 0.
            Because the <code>dealloc</code> method will be
              called when an instance is being destroyed, if
              instances of your subclass use objects or
              resources (as it happens for most useful
              classes), you must override
              <code>dealloc</code> in subclasses to release all
              objects and resources which are used by the
              instance, otherwise these objects and resources
              would be leaked. In the subclass implementation,
              you should first release all your subclass specific
              objects and resources, and then invoke super's
              implementation (which will do the same,
              and so on up in the class hierarchy to
              <code>NSObject</code> 's implementation, which
              finally destroys the object). Here is an example
              of the implementation of <code>dealloc</code> for a
              subclass whose instances have a single instance
              variable <code>name</code> which needs to be
              released when an instance is deallocated:
            <code>- (void) dealloc {RELEASE (name); [super dealloc];}</code>
            <code>dealloc</code> might contain code to release
              not only objects, but also other resources, such as
              open files, network connections, raw memory
              allocated in other ways, etc.
            If you have allocated the memory using a non-standard
              mechanism, you will not call the superclass
              (NSObject) implementation of the method as you
              will need to handle the deallocation specially.
              
<br>
 In some circumstances, an object may wish
              to prevent itsself from being deallocated, it can do
              this simply be refraining from calling the
              superclass implementation.


        



<section name="description">
<label id="method**NSObject**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br>Returns a string describing the receiver. The
            default implementation gives the class and memory
            location of the receiver.


        



<section name="doesNotRecognizeSelector:">
<label id="method**NSObject**-doesNotRecognizeSelector:" />- <code>(void) </code>
          <b>doesNotRecognizeSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Raises an invalid argument exception providing
            infomration about the receivers inability to
            handle <i>aSelector</i>.


        



<section name="forwardInvocation:">
<label id="method**NSObject**-forwardInvocation:" />- <code>(void) </code>
          <b>forwardInvocation: </b>
          <code>(NSInvocation*) </code><i>anInvocation </i>
          <br>This method is called automatically to handle a
            message sent to the receiver for which the
            receivers class has no method. 
<br>
 The default
            implemnentation calls
            <ref id="method**NSObject**-doesNotRecognizeSelector:">
              -doesNotRecognizeSelector:
            </ref>


        



<section name="hash">
<label id="method**NSObject**-hash" />- <code>(unsigned) </code>
          <b>hash </b>
          <br>Returns the hash of the receiver. Subclasses should
            ensure that their implementations of this method
            obey the rule that if the
            <ref id="method**NSObject**-isEqual:">
              -isEqual:
            </ref>
            method returns <code>YES</code> for two instances of
            the class, the
            <ref id="method**NSObject**-hash">
              -hash
            </ref>
            method returns the same value fro both instances.
            
<br>
 The default implementation returns the
            address of the instance.


        



<section name="init">
<label id="method**NSObject**-init" />- <code>(id) </code>
          <b>init </b>
          <br>Initialises the receiver... the NSObject
            implementation simply returns self.


        



<section name="isEqual:">
<label id="method**NSObject**-isEqual:" />- <code>(BOOL) </code>
          <b>isEqual: </b>
          <code>(id) </code><i>anObject </i>
          <br>Tests <i>anObject</i> and the receiver for
            equality. The default implementation considers
            two objects to be equal only if they are the same
            object (ie occupy the same memory location). 
<br>

            If a subclass overrides this method, it should also
            override the
            <ref id="method**NSObject**-hash">
              -hash
            </ref>
            method so that if two objects are equal they both
            have the same hash.


        



<section name="isKindOfClass:">
<label id="method**NSObject**-isKindOfClass:" />- <code>(BOOL) </code>
          <b>isKindOfClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Returns <code>YES</code> if the class of the
            receiver is either the same as <i>aClass</i>
            or is derived from (a subclass of) <i>aClass</i>.


        



<section name="isMemberOfClass:">
<label id="method**NSObject**-isMemberOfClass:" />- <code>(BOOL) </code>
          <b>isMemberOfClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Returns <code>YES</code> if the class of the
            receiver is <i>aClass</i>


        



<section name="isProxy">
<label id="method**NSObject**-isProxy" />- <code>(BOOL) </code>
          <b>isProxy </b>
          <br>Returns a flag to differentiate between 'true'
            objects, and objects which are proxies for other
            objects (ie they forward messages to the other
            objects). 
<br>
 The default implementation
            returns <code>NO</code>.


        



<section name="methodForSelector:">
<label id="method**NSObject**-methodForSelector:" />- <code>(IMP) </code>
          <b>methodForSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Returns a pointer to the C function implementing
            the method used to respond to messages with
            <i>aSelector</i>. 
<br>
 Raises
            NSInvalidArgumentException if
            given a null selector.


        



<section name="methodSignatureForSelector:">
<label id="method**NSObject**-methodSignatureForSelector:" />- <code>(NSMethodSignature*) </code>
          <b>methodSignatureForSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Returns the method signature describing how the
            receiver would handle a message with
            <i>aSelector</i>. 
<br>
 Raises
            NSInvalidArgumentException if
            given a null selector.


        



<section name="mutableCopy">
<label id="method**NSObject**-mutableCopy" />- <code>(id) </code>
          <b>mutableCopy </b>
          <br>Creates and rturns a mutable copy of the receiver
            by calling
            <ref id="method**NSObject**-mutableCopyWithZone:">
              -mutableCopyWithZone:
            </ref>
            passing
            <ref id="function**NSObject**NSDefaultMallocZone">
              NSDefaultMallocZone()
            </ref>
            .


        



<section name="performSelector:">
<label id="method**NSObject**-performSelector:" />- <code>(id) </code>
          <b>performSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Causes the receiver to execute the method
            implementation corresponding to
            <i>aSelector</i> and returns the result. 
<br>

            The method must be one which takes no arguments and
            returns an object. 
<br>
 Raises
            NSInvalidArgumentException if
            given a null selector.


        



<section name="performSelector:withObject:">
<label id="method**NSObject**-performSelector:withObject:" />- <code>(id) </code>
          <b>performSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>withObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Causes the receiver to execute the method
            implementation corresponding to
            <i>aSelector</i> and returns the result. 
<br>

            The method must be one which takes one argument and
            returns an object. 
<br>
 Raises
            NSInvalidArgumentException if
            given a null selector.


        



<section name="performSelector:withObject:withObject:">
<label id="method**NSObject**-performSelector:withObject:withObject:" />- <code>(id) </code>
          <b>performSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>withObject: </b>
          <code>(id) </code><i>object1 </i>
          <b>withObject: </b>
          <code>(id) </code><i>object2 </i>
          <br>Causes the receiver to execute the method
            implementation corresponding to
            <i>aSelector</i> and returns the result. 
<br>

            The method must be one which takes two arguments and
            returns an object. 
<br>
 Raises
            NSInvalidArgumentException if
            given a null selector.


        



<section name="release">
<label id="method**NSObject**-release" />- <code>(void) </code>
          <b>release </b>
          <br>Decrements the retain count for the receiver if
            greater than zeron, otherwise calls the dealloc
            method instead. 
<br>
 The default implementation
            calls the
            <ref id="function**NSObject**NSDecrementExtraRefCountWasZero">
              NSDecrementExtraRefCountWasZero()
            </ref>
            function to test the extra reference count for the
            receiver (and decrement it if non-zero) - if the
            extra reference count is zero then the retain count
            is one, and the dealloc method is called. 
<br>
 In
            GNUstep, the
            <ref id="method**NSObject**+enableDoubleReleaseCheck:">[NSObject% unknown entity: nbsp
+enableDoubleReleaseCheck:]</ref> method may be used to turn on checking for ratain/release errors in this method.


        



<section name="replacementObjectForArchiver:">
<label id="method**NSObject**-replacementObjectForArchiver:" />- <code>(id) </code>
          <b>replacementObjectForArchiver: </b>
          <code>(NSArchiver*) </code><i>anArchiver </i>
          <br><em>Description forthcoming.</em>


        



<section name="replacementObjectForCoder:">
<label id="method**NSObject**-replacementObjectForCoder:" />- <code>(id) </code>
          <b>replacementObjectForCoder: </b>
          <code>(NSCoder*) </code><i>anEncoder </i>
          <br><em>Description forthcoming.</em>


        



<section name="replacementObjectForPortCoder:">
<label id="method**NSObject**-replacementObjectForPortCoder:" />- <code>(id) </code>
          <b>replacementObjectForPortCoder: </b>
          <code>(NSPortCoder*) </code><i>aCoder </i>
          <br>Returns the actual object to be encoded for sending
            over the network on a Distributed Objects connection.
            
<br>
 The default implementation returns self if
            the receiver is being sent <em>bycopy</em> and returns
            a proxy otherwise. 
<br>
 Subclasses may override this
            method to change this behavior, eg. to ensure that
            they are always copied.


        



<section name="respondsToSelector:">
<label id="method**NSObject**-respondsToSelector:" />- <code>(BOOL) </code>
          <b>respondsToSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Returns a flag to say if the receiver will respond
            to the specified selector. This ignores situations where
            a subclass implements
            <ref id="method**NSObject**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            to respond to selectors not normally handled... in these
            cases the subclass may override this method to handle
            it. 
<br>
 Raises NSInvalidArgumentException if given a
            null selector.


        



<section name="retain">
<label id="method**NSObject**-retain" />- <code>(id) </code>
          <b>retain </b>
          <br>Increments the reference count and returns the
            receiver. 
<br>
 The default implementation does
            this by calling
            <ref id="function**NSObject**NSIncrementExtraRefCount">
              NSIncrementExtraRefCount()
            </ref>


        



<section name="retainCount">
<label id="method**NSObject**-retainCount" />- <code>(unsigned) </code>
          <b>retainCount </b>
          <br>Returns the reference count for the receiver. Each
            instance has an implicit reference count of 1, and
            has an 'extra refrence count' returned by the
            <ref id="function**NSObject**NSExtraRefCount">
              NSExtraRefCount()
            </ref>
            function, so the value returned by this method is
            always greater than zero. 
<br>
 By convention,
            objects which should (or can) never be deallocated
            return the maximum unsigned integer value.


        



<section name="self">
<label id="method**NSObject**-self" />- <code>(id) </code>
          <b>self </b>
          <br>Returns the reciever.


        



<section name="superclass">
<label id="method**NSObject**-superclass" />- <code>(Class) </code>
          <b>superclass </b>
          <br>Returns the super class from which the receviers
            class was derived.


        



<section name="zone">
<label id="method**NSObject**-zone" />- <code>(NSZone*) </code>
          <b>zone </b>
          <br>Returns the memory allocation zone in which the
            receiver is located.


        


</section>


</chapter>


<chapter name="GSHTMLSAXHandler">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSHTMLSAXHandler">GSHTMLSAXHandler</ref>: <ref id="GSSAXHandler">GSSAXHandler</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSFormatter">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSFormatter">NSFormatter</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopyingNSCoding
<br><b>Declared in: </b>NSFormatter.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
      

<section name="attributedStringForObjectValue:withDefaultAttributes:">
<label id="method**NSFormatter**-attributedStringForObjectValue:withDefaultAttributes:" />- <code>(NSAttributedString*) </code>
          <b>attributedStringForObjectValue: </b>
          <code>(id) </code><i>anObject </i>
          <b>withDefaultAttributes: </b>
          <code>(NSDictionary*) </code><i>attr </i>
          <br><em>Description forthcoming.</em>


        



<section name="editingStringForObjectValue:">
<label id="method**NSFormatter**-editingStringForObjectValue:" />- <code>(NSString*) </code>
          <b>editingStringForObjectValue: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="getObjectValue:forString:errorDescription:">
<label id="method**NSFormatter**-getObjectValue:forString:errorDescription:" />- <code>(BOOL) </code>
          <b>getObjectValue: </b>
          <code>(id*) </code><i>anObject </i>
          <b>forString: </b>
          <code>(NSString*) </code><i>string </i>
          <b>errorDescription: </b>
          <code>(NSString**) </code><i>error </i>
          <br><em>Description forthcoming.</em>


        



<section name="isPartialStringValid:newEditingString:errorDescription:">
<label id="method**NSFormatter**-isPartialStringValid:newEditingString:errorDescription:" />- <code>(BOOL) </code>
          <b>isPartialStringValid: </b>
          <code>(NSString*) </code><i>partialString </i>
          <b>newEditingString: </b>
          <code>(NSString**) </code><i>newString </i>
          <b>errorDescription: </b>
          <code>(NSString**) </code><i>error </i>
          <br><em>Description forthcoming.</em>


        



<section name="isPartialStringValid:proposedSelectedRange:originalString:originalSelectedRange:errorDescription:">
<label id="method**NSFormatter**-isPartialStringValid:proposedSelectedRange:originalString:originalSelectedRange:errorDescription:" />- <code>(BOOL) </code>
          <b>isPartialStringValid: </b>
          <code>(NSString**) </code><i>partialStringPtr </i>
          <b>proposedSelectedRange: </b>
          <code>(NSRange*) </code><i>proposedSelRangePtr </i>
          <b>originalString: </b>
          <code>(NSString*) </code><i>origString </i>
          <b>originalSelectedRange: </b>
          <code>(NSRange) </code><i>originalSelRangePtr </i>
          <b>errorDescription: </b>
          <code>(NSString**) </code><i>error </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringForObjectValue:">
<label id="method**NSFormatter**-stringForObjectValue:" />- <code>(NSString*) </code>
          <b>stringForObjectValue: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSDirectoryEnumerator">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDirectoryEnumerator">NSDirectoryEnumerator</ref>: <ref id="NSEnumerator">NSEnumerator</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSFileManager.h
</section>

<section name="Description">
<br>NSDirectoryEnumerator implementation
          
<br>
 The Objective-C interface hides a traditional C
          implementation. This was the only way I could
          get near the speed of standard unix tools for big
          directories.


</section>

<section name="Methods">


<section name="directoryAttributes">
<label id="method**NSDirectoryEnumerator**-directoryAttributes" />- <code>(NSDictionary*) </code>
          <b>directoryAttributes </b>
          <br>Returns a dictionary containing the attributes of
            the directory at which enumeration started. 
<br>
 The
            contents of this dictionary are as produced by
            <ref id="method**NSFileManager**-fileAttributesAtPath:traverseLink:">[NSFileManager% unknown entity: nbsp
-fileAttributesAtPath:traverseLink:]</ref>


        



<section name="fileAttributes">
<label id="method**NSDirectoryEnumerator**-fileAttributes" />- <code>(NSDictionary*) </code>
          <b>fileAttributes </b>
          <br>Returns a dictionary containing the attributes of
            the file currently being enumerated. 
<br>
 The
            contents of this dictionary are as produced by
            <ref id="method**NSFileManager**-fileAttributesAtPath:traverseLink:">[NSFileManager% unknown entity: nbsp
-fileAttributesAtPath:traverseLink:]</ref>


        



<section name="initWithDirectoryPath:recurseIntoSubdirectories:followSymlinks:justContents:">
<label id="method**NSDirectoryEnumerator**-initWithDirectoryPath:recurseIntoSubdirectories:followSymlinks:justContents:" />- <code>(id) </code>
          <b>initWithDirectoryPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>recurseIntoSubdirectories: </b>
          <code>(BOOL) </code><i>recurse </i>
          <b>followSymlinks: </b>
          <code>(BOOL) </code><i>follow </i>
          <b>justContents: </b>
          <code>(BOOL) </code><i>justContents </i>
          <br><em>Description forthcoming.</em>


        



<section name="skipDescendents">
<label id="method**NSDirectoryEnumerator**-skipDescendents" />- <code>(void) </code>
          <b>skipDescendents </b>
          <br>Informs the receiver that any descendents of the
            current directory should be skipped rather than
            enumerated. Use this to avaoid enumerating the
            contents of directories you are not interested in.


        


        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSPipe">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSPipe">NSPipe</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSFileHandle.h
</section>

<section name="Description">
<br>The NSPipe provides an encapsulation of the UNIX concept
          of pipe. With NSPipe, it is possible to redirect the
          standard input or standard output.


</section>

<section name="Methods">


<section name="pipe">
<label id="method**NSPipe**+pipe" />+ <code>(id) </code>
          <b>pipe </b>
          <br>Returns a newly allocated and initialized NSPipe
            object that has been sent an autorelease message.


        



<section name="fileHandleForReading">
<label id="method**NSPipe**-fileHandleForReading" />- <code>(NSFileHandle*) </code>
          <b>fileHandleForReading </b>
          <br><em>Description forthcoming.</em>


        



<section name="fileHandleForWriting">
<label id="method**NSPipe**-fileHandleForWriting" />- <code>(NSFileHandle*) </code>
          <b>fileHandleForWriting </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSRecursiveLock">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSRecursiveLock">NSRecursiveLock</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSLockingGCFinalization
<br><b>Declared in: </b>NSLock.h
</section>

<section name="Description">
<br>See NSLock for more information about what a lock is. A
          recursive lock extends NSLock in that you can lock
          a recursive lock multiple times. Each lock must be balanced
          by a cooresponding unlock, and the lock is not released
          for another thread to aquire until the last unlock call
          is made (corresponding to the first lock message).


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
      

<section name="lock">
<label id="method**NSRecursiveLock**-lock" />- <code>(void) </code>
          <b>lock </b>
          <br><em>Description forthcoming.</em>


        



<section name="lockBeforeDate:">
<label id="method**NSRecursiveLock**-lockBeforeDate:" />- <code>(BOOL) </code>
          <b>lockBeforeDate: </b>
          <code>(NSDate*) </code><i>limit </i>
          <br>Attempts to aquire a lock before the date
            <i>limit</i> passes. It returns <code>YES</code>
            if it can. It returns <code>NO</code> if it cannot (but
            it waits until the time <i>limit</i> is up before
            returning <code>NO</code>).


        



<section name="tryLock">
<label id="method**NSRecursiveLock**-tryLock" />- <code>(BOOL) </code>
          <b>tryLock </b>
          <br>Attempts to aquire a lock, but returns
            <code>NO</code> immediately if the lock cannot be
            aquired. It returns <code>YES</code> if the lock
            is aquired. Can be called multiple times to make nested
            locks.


        



<section name="unlock">
<label id="method**NSRecursiveLock**-unlock" />- <code>(void) </code>
          <b>unlock </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSIntNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSIntNumber">NSIntNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSDoubleNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDoubleNumber">NSDoubleNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSMutableBitmapCharSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableBitmapCharSet">NSMutableBitmapCharSet</ref>: <ref id="NSMutableCharacterSet">NSMutableCharacterSet</ref>: <ref id="NSCharacterSet">NSCharacterSet</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSBitmapCharSet.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="initWithBitmap:">
<label id="method**NSMutableBitmapCharSet**-initWithBitmap:" />- <code>(id) </code>
          <b>initWithBitmap: </b>
          <code>(NSData*) </code><i>bitmap </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
      
</section>


</chapter>


<chapter name="NSURL">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSURL">NSURL</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSURLHandleClient
<br><b>Declared in: </b>NSURL.h
</section>

<section name="Description">
<br>This class permits manipulation of URLs and the
          resources to which they refer. They can be used to
          represent absolute URLs or relative URLs which are
          based upon an absolute URL. The relevant RFCs
          describing how a URL is formatted, and what is
          legal in a URL are - 1808, 1738, and 2396. 
<br>

          Handling of the underlying resources is carried out
          by NSURLHandle objects, but NSURL provides a simoplified
          API wrapping these objects.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="URLWithString:">
<label id="method**NSURL**+URLWithString:" />+ <code>(id) </code>
          <b>URLWithString: </b>
          <code>(NSString*) </code><i>aUrlString </i>
          <br>Create and return a URL with the supplied string,
            which should be a string (containing percent escape
            codes where necessary) conforming to the description
            (in RFC2396) of an absolute URL. 
<br>
 Calls
            <ref id="method**NSURL**-initWithString:">
              -initWithString:
            </ref>


        



<section name="URLWithString:relativeToURL:">
<label id="method**NSURL**+URLWithString:relativeToURL:" />+ <code>(id) </code>
          <b>URLWithString: </b>
          <code>(NSString*) </code><i>aUrlString </i>
          <b>relativeToURL: </b>
          <code>(NSURL*) </code><i>aBaseUrl </i>
          <br>Create and return a URL with the supplied string,
            which should be a string (containing percent escape
            codes where necessary) conforming to the description
            (in RFC2396) of a relative URL. 
<br>
 Calls
            <ref id="method**NSURL**-initWithString:relativeToURL:">
              -initWithString:relativeToURL:
            </ref>


        



<section name="fileURLWithPath:">
<label id="method**NSURL**+fileURLWithPath:" />+ <code>(id) </code>
          <b>fileURLWithPath: </b>
          <code>(NSString*) </code><i>aPath </i>
          <br>Create and return a file URL with the supplied path.
            
<br>
 The value of <i>aPath</i> must be a valid
            filesystem path. 
<br>
 Calls
            <ref id="method**NSURL**-initFileURLWithPath:">
              -initFileURLWithPath:
            </ref>


        



<section name="URLHandleUsingCache:">
<label id="method**NSURL**-URLHandleUsingCache:" />- <code>(NSURLHandle*) </code>
          <b>URLHandleUsingCache: </b>
          <code>(BOOL) </code><i>shouldUseCache </i>
          <br>Returns an NSURLHandle instance which may be used
            to write data to the resource represented by the
            receiver URL, or read data from it. 
<br>
 The
            <i>shouldUseCache</i> flag indicates whether a
            cached handle may be returned or a new one should be
            created.


        



<section name="absoluteString">
<label id="method**NSURL**-absoluteString" />- <code>(NSString*) </code>
          <b>absoluteString </b>
          <br>Returns the full string describing the receiver
            resiolved against its base.


        



<section name="absoluteURL">
<label id="method**NSURL**-absoluteURL" />- <code>(NSURL*) </code>
          <b>absoluteURL </b>
          <br>If the receiver is an absolute URL, returns self.
            Otherwise returns an absolute URL referring to
            the same resource as the receiver.


        



<section name="baseURL">
<label id="method**NSURL**-baseURL" />- <code>(NSURL*) </code>
          <b>baseURL </b>
          <br>If the receiver is a relative URL, returns its base URL.
            
<br>
 Otherwise, returns <code>nil</code>.


        



<section name="fragment">
<label id="method**NSURL**-fragment" />- <code>(NSString*) </code>
          <b>fragment </b>
          <br>Returns the fragment portion of the receiver or
            <code>nil</code> if there is no fragment supplied in
            the URL. 
<br>
 The fragment is everything in the
            original URL string after a '#' 
<br>
 File URLs
            do not have fragments.


        



<section name="host">
<label id="method**NSURL**-host" />- <code>(NSString*) </code>
          <b>host </b>
          <br>Returns the host portion of the receiver or
            <code>nil</code> if there is no host supplied in the
            URL. 
<br>
 Percent escape sequences in the user
            string are translated and the string treated as
            UTF8. 
<br>


        



<section name="initFileURLWithPath:">
<label id="method**NSURL**-initFileURLWithPath:" />- <code>(id) </code>
          <b>initFileURLWithPath: </b>
          <code>(NSString*) </code><i>aPath </i>
          <br>Initialise as a file URL with the specified path
            (which must be a valid path on the local
            filesystem). 
<br>
 Converts relative paths to
            absolute ones. 
<br>
 Appends a trailing slash to
            the path when necessary if it specifies a directory.
            
<br>
 Calls
            <ref id="method**NSURL**-initWithScheme:host:path:">
              -initWithScheme:host:path:
            </ref>


        



<section name="initWithScheme:host:path:">
<label id="method**NSURL**-initWithScheme:host:path:" />- <code>(id) </code>
          <b>initWithScheme: </b>
          <code>(NSString*) </code><i>aScheme </i>
          <b>host: </b>
          <code>(NSString*) </code><i>aHost </i>
          <b>path: </b>
          <code>(NSString*) </code><i>aPath </i>
          <br>Initialise by building a URL string from the
            supplied parameters and calling
            <ref id="method**NSURL**-initWithString:relativeToURL:">
              -initWithString:relativeToURL:
            </ref>


        



<section name="initWithString:">
<label id="method**NSURL**-initWithString:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>aUrlString </i>
          <br>Initialise as an absolute URL. 
<br>
 Calls
            <ref id="method**NSURL**-initWithString:relativeToURL:">
              -initWithString:relativeToURL:
            </ref>


        



<section name="initWithString:relativeToURL:">
<label id="method**NSURL**-initWithString:relativeToURL:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>aUrlString </i>
          <b>relativeToURL: </b>
          <code>(NSURL*) </code><i>aBaseUrl </i>
          <br>Initialised using <i>aUrlString</i> and
            <i>aBaseUrl</i>. The value of <i>aBaseUrl</i>
            may be <code>nil</code>, but <i>aUrlString</i> must
            be non-nil. 
<br>
 If the string cannot be parsed the
            method returns <code>nil</code>.


        



<section name="isFileURL">
<label id="method**NSURL**-isFileURL" />- <code>(BOOL) </code>
          <b>isFileURL </b>
          <br>Returns <code>YES</code> if the recevier is a file
            URL, <code>NO</code> otherwise.


        



<section name="loadResourceDataNotifyingClient:usingCache:">
<label id="method**NSURL**-loadResourceDataNotifyingClient:usingCache:" />- <code>(void) </code>
          <b>loadResourceDataNotifyingClient: </b>
          <code>(id) </code><i>client </i>
          <b>usingCache: </b>
          <code>(BOOL) </code><i>shouldUseCache </i>
          <br>Loads resource data for the specified
            <i>client</i>.
            If <i>shouldUseCache</i> is <code>YES</code> then
              an attempt will be made to locate a cached NSURLHandle
              to provide the resource data, otherwise a new handle
              will be created and cached.
            If the handle does not have the data available, it
              will be asked to load the data in the background by
              calling its loadInBackground method.
            The specified <i>client</i> (if non-nil) will be
              set up to receive notifications of the progress of
              the background load process.


        



<section name="parameterString">
<label id="method**NSURL**-parameterString" />- <code>(NSString*) </code>
          <b>parameterString </b>
          <br>Returns the parameter portion of the receiver or
            <code>nil</code> if there is no parameter supplied
            in the URL. 
<br>
 The parameters are everything in the
            original URL string after a ';' but before the
            query. 
<br>
 File URLs do not have parameters.


        



<section name="password">
<label id="method**NSURL**-password" />- <code>(NSString*) </code>
          <b>password </b>
          <br>Returns the password portion of the receiver or
            <code>nil</code> if there is no password supplied in
            the URL. 
<br>
 Percent escape sequences in the user
            string are translated and the string treated as UTF8
            in GNUstep but this appears to be broken in MacOS-X.
            
<br>
 NB. because of its security implications it
            is recommended that you do not use URLs with users and
            passwords unless necessary.


        



<section name="path">
<label id="method**NSURL**-path" />- <code>(NSString*) </code>
          <b>path </b>
          <br>Returns the path portion of the receiver. 
<br>

            Replaces percent escapes with unescaped values,
            interpreting non-ascii character sequences as
            UTF8. 
<br>
 NB. This does not conform strictly to
            the RFCs, in that it includes a leading slash ('/')
            character (wheras the path part of a URL strictly
            should not) and the interpretation of non-ascii
            character is (strictly speaking) undefined.
            
<br>
 Also, this breaks strict conformance in that
            a URL of file scheme is treated as having a path
            (contrary to RFCs)


        



<section name="port">
<label id="method**NSURL**-port" />- <code>(NSNumber*) </code>
          <b>port </b>
          <br>Returns the port portion of the receiver or
            <code>nil</code> if there is no port supplied in the
            URL. 
<br>
 Percent escape sequences in the user
            string are translated in GNUstep but this appears to
            be broken in MacOS-X.


        



<section name="propertyForKey:">
<label id="method**NSURL**-propertyForKey:" />- <code>(id) </code>
          <b>propertyForKey: </b>
          <code>(NSString*) </code><i>propertyKey </i>
          <br>Asks a URL handle to return the property for the
            specified key and returns the result.


        



<section name="query">
<label id="method**NSURL**-query" />- <code>(NSString*) </code>
          <b>query </b>
          <br>Returns the query portion of the receiver or
            <code>nil</code> if there is no query supplied in
            the URL. 
<br>
 The query is everything in the original
            URL string after a '?' but before the fragment. 
<br>

            File URLs do not have queries.


        



<section name="relativePath">
<label id="method**NSURL**-relativePath" />- <code>(NSString*) </code>
          <b>relativePath </b>
          <br>Returns the path of the receiver, without taking
            any base URL into account. If the receiver is an
            absolute URL,
            <ref id="method**NSURL**-relativePath">
              -relativePath
            </ref>
            is the same as <ref id="method**NSURL**-path">-path</ref>
            . 
<br>
 Returns <code>nil</code> if there is no path
            specified for the URL.


        



<section name="relativeString">
<label id="method**NSURL**-relativeString" />- <code>(NSString*) </code>
          <b>relativeString </b>
          <br>Returns the relative portion of the URL string. If
            the receiver is not a relative URL, this returns the
            same as absoluteString.


        



<section name="resourceDataUsingCache:">
<label id="method**NSURL**-resourceDataUsingCache:" />- <code>(NSData*) </code>
          <b>resourceDataUsingCache: </b>
          <code>(BOOL) </code><i>shouldUseCache </i>
          <br>Loads the resource data for the represented URL and
            returns the result. The shoulduseCache flag
            determines whether an existing cached
            NSURLHandle can be used to provide the data.


        



<section name="resourceSpecifier">
<label id="method**NSURL**-resourceSpecifier" />- <code>(NSString*) </code>
          <b>resourceSpecifier </b>
          <br>Returns the resource specifier of the URL... the
            part which lies after the scheme.


        



<section name="scheme">
<label id="method**NSURL**-scheme" />- <code>(NSString*) </code>
          <b>scheme </b>
          <br>Returns the scheme of the receiver.


        



<section name="setProperty:forKey:">
<label id="method**NSURL**-setProperty:forKey:" />- <code>(BOOL) </code>
          <b>setProperty: </b>
          <code>(id) </code><i>property </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>propertyKey </i>
          <br>Calls
            <ref id="method**NSURLHandle**-writeProperty:forKey:">[NSURLHandle% unknown entity: nbsp
-writeProperty:forKey:]</ref> to set the named <i>property</i>.


        



<section name="setResourceData:">
<label id="method**NSURL**-setResourceData:" />- <code>(BOOL) </code>
          <b>setResourceData: </b>
          <code>(NSData*) </code><i>data </i>
          <br>Calls
            <ref id="method**NSURLHandle**-writeData:">
              [NSURLHandle% unknown entity: nbsp
-writeData:]
            </ref>
            to write the specified <i>data</i> object to the
            resource identified by the receiver URL. 
<br>

            Returns the result.


        



<section name="standardizedURL">
<label id="method**NSURL**-standardizedURL" />- <code>(NSURL*) </code>
          <b>standardizedURL </b>
          <br>Returns a URL with '/./' and '/../' sequences
            resolved etc.


        



<section name="user">
<label id="method**NSURL**-user" />- <code>(NSString*) </code>
          <b>user </b>
          <br>Returns the user portion of the receiver or
            <code>nil</code> if there is no user supplied in the
            URL. 
<br>
 Percent escape sequences in the user
            string are translated and the whole is treated as
            UTF8 data. 
<br>
 NB. because of its security
            implications it is recommended that you do not
            use URLs with users and passwords unless necessary.


        


</section>


</chapter>


<chapter name="NSProxy">


<section name="Overview">
<b>Inherits From:  </b>None, is a root class
<br><b>Conforms to: </b>NSObject
<br><b>Declared in: </b>NSProxy.h
</section>

<section name="Description">
<br>The NSProxy class provides a basic implementation of a
          class whose instances are used to <em>stand in</em> for
          other objects. 
<br>
 The class provides the most basic
          methods of NSObject, and expects messages for other
          methods to be forwarded to the <em>real</em> object
          represented by the proxy. You must subclass
          NSProxy to implement
          <ref id="method**NSProxy**-forwardInvocation:">
            -forwardInvocation:
          </ref>
          to these <em>real</em> objects.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="alloc">
<label id="method**NSProxy**+alloc" />+ <code>(id) </code>
          <b>alloc </b>
          <br>Allocates and returns an NSProxy instance in the
            default zone.


        



<section name="allocWithZone:">
<label id="method**NSProxy**+allocWithZone:" />+ <code>(id) </code>
          <b>allocWithZone: </b>
          <code>(NSZone*) </code><i>z </i>
          <br>Allocates and returns an NSProxy instance in the
            specified zone <i>z</i>.


        



<section name="autorelease">
<label id="method**NSProxy**+autorelease" />+ <code>(id) </code>
          <b>autorelease </b>
          <br>Returns the receiver


        



<section name="class">
<label id="method**NSProxy**+class" />+ <code>(Class) </code>
          <b>class </b>
          <br>Returns the receiver


        



<section name="description">
<label id="method**NSProxy**+description" />+ <code>(NSString*) </code>
          <b>description </b>
          <br>Returns a string describing the receiver.


        



<section name="isKindOfClass:">
<label id="method**NSProxy**+isKindOfClass:" />+ <code>(BOOL) </code>
          <b>isKindOfClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Returns <code>NO</code>... the NSProxy class cannot
            be an instance of any class.


        



<section name="isMemberOfClass:">
<label id="method**NSProxy**+isMemberOfClass:" />+ <code>(BOOL) </code>
          <b>isMemberOfClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Returns <code>YES</code> if <i>aClass</i> is
            identical to the receiver, <code>NO</code>
            otherwise.


        



<section name="load">
<label id="method**NSProxy**+load" />+ <code>(void) </code>
          <b>load </b>
          <br>A dummy method...


        



<section name="release">
<label id="method**NSProxy**+release" />+ <code>(void) </code>
          <b>release </b>
          <br>A dummy method to ensure that the class can safely be
            held in containers.


        



<section name="respondsToSelector:">
<label id="method**NSProxy**+respondsToSelector:" />+ <code>(BOOL) </code>
          <b>respondsToSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Returns <code>YES</code> if the receiver responds
            to <i>aSelector</i>, <code>NO</code> otherwise.


        



<section name="retain">
<label id="method**NSProxy**+retain" />+ <code>(id) </code>
          <b>retain </b>
          <br>Returns the receiver.


        



<section name="retainCount">
<label id="method**NSProxy**+retainCount" />+ <code>(unsigned int) </code>
          <b>retainCount </b>
          <br>Returns the maximum unsigned integer value.


        



<section name="autorelease">
<label id="method**NSProxy**-autorelease" />- <code>(id) </code>
          <b>autorelease </b>
          <br>Adds the receiver to the current autorelease pool and
            returns self.


        



<section name="class">
<label id="method**NSProxy**-class" />- <code>(Class) </code>
          <b>class </b>
          <br>Returns the class of the receiver.


        



<section name="conformsToProtocol:">
<label id="method**NSProxy**-conformsToProtocol:" />- <code>(BOOL) </code>
          <b>conformsToProtocol: </b>
          <code>(Protocol*) </code><i>aProtocol </i>
          <br>Calls the
            <ref id="method**NSProxy**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            method to determine if the 'real' object referred to
            by the proxy conforms to <i>aProtocol</i>. Returns
            the result. 
<br>
 NB. The default operation of
            <ref id="method**NSProxy**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            is to raise an exception.


        



<section name="dealloc">
<label id="method**NSProxy**-dealloc" />- <code>(void) </code>
          <b>dealloc </b>
          <br>Frees the memory used by the receiver.


        



<section name="description">
<label id="method**NSProxy**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br>Returns a text descrioption of the receiver.


        



<section name="forwardInvocation:">
<label id="method**NSProxy**-forwardInvocation:" />- <code>(void) </code>
          <b>forwardInvocation: </b>
          <code>(NSInvocation*) </code><i>anInvocation </i>
          <br>Raises an NSInvalidArgumentException


        



<section name="hash">
<label id="method**NSProxy**-hash" />- <code>(unsigned int) </code>
          <b>hash </b>
          <br>Returns the address of the receiver... so it can be
            stored in a dictionary.


        



<section name="init">
<label id="method**NSProxy**-init" />- <code>(id) </code>
          <b>init </b>
          <br>Initialises the receiver and returns the
            resulting instance.


        



<section name="isEqual:">
<label id="method**NSProxy**-isEqual:" />- <code>(BOOL) </code>
          <b>isEqual: </b>
          <code>(id) </code><i>anObject </i>
          <br>Tests for pointer equality with <i>anObject</i>


        



<section name="isKindOfClass:">
<label id="method**NSProxy**-isKindOfClass:" />- <code>(BOOL) </code>
          <b>isKindOfClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Calls the
            <ref id="method**NSProxy**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            method to determine if the 'real' object referred to
            by the proxy is an instance of the specified class.
            Returns the result. 
<br>
 NB. The default
            operation of
            <ref id="method**NSProxy**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            is to raise an exception.


        



<section name="isMemberOfClass:">
<label id="method**NSProxy**-isMemberOfClass:" />- <code>(BOOL) </code>
          <b>isMemberOfClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Calls the
            <ref id="method**NSProxy**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            method to determine if the 'real' object referred to
            by the proxy is an instance of the specified class.
            Returns the result. 
<br>
 NB. The default
            operation of
            <ref id="method**NSProxy**-forwardInvocation:">
              -forwardInvocation:
            </ref>
            is to raise an exception.


        



<section name="isProxy">
<label id="method**NSProxy**-isProxy" />- <code>(BOOL) </code>
          <b>isProxy </b>
          <br>Returns <code>YES</code>


        



<section name="methodSignatureForSelector:">
<label id="method**NSProxy**-methodSignatureForSelector:" />- <code>(NSMethodSignature*) </code>
          <b>methodSignatureForSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>If we respond to the method directly, create and return
            a method signature. Otherwise raise an exception.


        



<section name="release">
<label id="method**NSProxy**-release" />- <code>(void) </code>
          <b>release </b>
          <br>Decrement the retain count for the receiver...
            deallocate if it would become negative.


        



<section name="respondsToSelector:">
<label id="method**NSProxy**-respondsToSelector:" />- <code>(BOOL) </code>
          <b>respondsToSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>If we respond to the method directly, return
            <code>YES</code>, otherwise forward this request to
            the object we are acting as a proxy for.


        



<section name="retain">
<label id="method**NSProxy**-retain" />- <code>(id) </code>
          <b>retain </b>
          <br>Increment the retain count for the receiver.


        



<section name="retainCount">
<label id="method**NSProxy**-retainCount" />- <code>(unsigned int) </code>
          <b>retainCount </b>
          <br>Return the retain count for the receiver.


        



<section name="self">
<label id="method**NSProxy**-self" />- <code>(id) </code>
          <b>self </b>
          <br>Returns the receiver.


        



<section name="superclass">
<label id="method**NSProxy**-superclass" />- <code>(Class) </code>
          <b>superclass </b>
          <br>Returns the superclass of the receivers class.


        



<section name="zone">
<label id="method**NSProxy**-zone" />- <code>(NSZone*) </code>
          <b>zone </b>
          <br>Returns the zone in which the receiver was
            allocated.


        


</section>


</chapter>


<chapter name="NSFileManager">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSFileManager">NSFileManager</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSFileManager.h
</section>

<section name="Description">
<br>This is the main class for management of the local
          filesystem.


</section>

<section name="Methods">


<section name="defaultManager">
<label id="method**NSFileManager**+defaultManager" />+ <code>(NSFileManager*) </code>
          <b>defaultManager </b>
          <br>Returns a shared default file manager which may be
            used throughout an application.


        



<section name="changeCurrentDirectoryPath:">
<label id="method**NSFileManager**-changeCurrentDirectoryPath:" />- <code>(BOOL) </code>
          <b>changeCurrentDirectoryPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Changes the current directory used for all
            subsequent operations. 
<br>
 All non-absolute
            paths are interpreted relative to this directory.
            
<br>
 The current directory is set on a per-task
            basis, so the current directory for other file
            manager instances will also be changed by this
            method.


        



<section name="changeFileAttributes:atPath:">
<label id="method**NSFileManager**-changeFileAttributes:atPath:" />- <code>(BOOL) </code>
          <b>changeFileAttributes: </b>
          <code>(NSDictionary*) </code><i>attributes </i>
          <b>atPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Change the <i>attributes</i> of the file at
            <i>path</i> to those specified. 
<br>
 Returns
            <code>YES</code> if all requested changes were made
            (or if the dictionary was <code>nil</code> or empty, so
            no changes were requested), <code>NO</code> otherwise.
            
<br>
 On failure, some fo the requested changes may
            have taken place. 
<br>


        



<section name="componentsToDisplayForPath:">
<label id="method**NSFileManager**-componentsToDisplayForPath:" />- <code>(NSArray*) </code>
          <b>componentsToDisplayForPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns an array of <i>path</i> components
            suitably modified for display to the end user.
            This modification may render the returned strings
            unusable for <i>path</i> manipulation, so you
            should work with two arrays... one returned by this
            method (for display tio the user), and a parallel
            one returned by
            <ref id="method**NSString**-pathComponents">
              [NSString% unknown entity: nbsp
-pathComponents]
            </ref>
            (for <i>path</i> manipulation).


        



<section name="contentsAtPath:">
<label id="method**NSFileManager**-contentsAtPath:" />- <code>(NSData*) </code>
          <b>contentsAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Reads the file at <i>path</i> an returns its
            contents as an NSData object. 
<br>
 If an error
            occurs or if <i>path</i> specifies a directory
            etc then <code>nil</code> is returned.


        



<section name="contentsEqualAtPath:andPath:">
<label id="method**NSFileManager**-contentsEqualAtPath:andPath:" />- <code>(BOOL) </code>
          <b>contentsEqualAtPath: </b>
          <code>(NSString*) </code><i>path1 </i>
          <b>andPath: </b>
          <code>(NSString*) </code><i>path2 </i>
          <br>Returns <code>YES</code> if the contents of the
            file or directory at <i>path1</i> are the same as
            those at <i>path2</i>. 
<br>
 If <i>path1</i>
            and <i>path2</i> are files, this is a simple
            comparison. If they are directories, the
            contents of the files in those subdirectories are
            compared recursively. 
<br>
 Symbolic links are
            not followed. 
<br>
 A comparison checks first file
            identity, then size, then content.


        



<section name="copyPath:toPath:handler:">
<label id="method**NSFileManager**-copyPath:toPath:handler:" />- <code>(BOOL) </code>
          <b>copyPath: </b>
          <code>(NSString*) </code><i>source </i>
          <b>toPath: </b>
          <code>(NSString*) </code><i>destination </i>
          <b>handler: </b>
          <code>(id) </code><i>handler </i>
          <br>Copies the file or directory at <i>source</i> to
            <i>destination</i>, using a <i>handler</i>
            object which should respond to
            <ref id="method**NSObject**-fileManager:willProcessPath:">[NSObject% unknown entity: nbsp
-fileManager:willProcessPath:]</ref> and <ref id="method**NSObject**-fileManager:shouldProceedAfterError:">[NSObject% unknown entity: nbsp
-fileManager:shouldProceedAfterError:]</ref> messages.


        



<section name="createDirectoryAtPath:attributes:">
<label id="method**NSFileManager**-createDirectoryAtPath:attributes:" />- <code>(BOOL) </code>
          <b>createDirectoryAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>attributes: </b>
          <code>(NSDictionary*) </code><i>attributes </i>
          <br>Creates a new directory, and sets its
            <i>attributes</i> as specified. 
<br>
 Creates
            other directories in the <i>path</i> as
            necessary. 
<br>
 Returns <code>YES</code> on
            success, <code>NO</code> on failure.


        



<section name="createFileAtPath:contents:attributes:">
<label id="method**NSFileManager**-createFileAtPath:contents:attributes:" />- <code>(BOOL) </code>
          <b>createFileAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>contents: </b>
          <code>(NSData*) </code><i>contents </i>
          <b>attributes: </b>
          <code>(NSDictionary*) </code><i>attributes </i>
          <br>Creates a new file, and sets its
            <i>attributes</i> as specified. 
<br>

            Initialises the file content with the specified
            data. 
<br>
 Returns <code>YES</code> on success,
            <code>NO</code> on failure.


        



<section name="createSymbolicLinkAtPath:pathContent:">
<label id="method**NSFileManager**-createSymbolicLinkAtPath:pathContent:" />- <code>(BOOL) </code>
          <b>createSymbolicLinkAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>pathContent: </b>
          <code>(NSString*) </code><i>otherPath </i>
          <br>Creates a symbolic link at <i>path</i> which
            links to the location specified by
            <i>otherPath</i>.


        



<section name="currentDirectoryPath">
<label id="method**NSFileManager**-currentDirectoryPath" />- <code>(NSString*) </code>
          <b>currentDirectoryPath </b>
          <br>Returns the current working directory used by all
            instance of the file manager in the current task.


        



<section name="directoryContentsAtPath:">
<label id="method**NSFileManager**-directoryContentsAtPath:" />- <code>(NSArray*) </code>
          <b>directoryContentsAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns an array of the contents of the specified
            directory. 
<br>
 The listing does
            <b>not</b> recursively list
            subdirectories. 
<br>
 The special files
            '.' and '..' are not listed. 
<br>
 Indicates an error
            by returning <code>nil</code> (eg. if <i>path</i> is
            not a directory or it can't be read for some reason).


        



<section name="displayNameAtPath:">
<label id="method**NSFileManager**-displayNameAtPath:" />- <code>(NSString*) </code>
          <b>displayNameAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns the name of the file or directory at
            <i>path</i>. Converts it into a format for
            display to an end user. This may render it unusable
            as part of a file/path name. 
<br>
 For instance, if a
            user has elected not to see file extensions, this
            method may return filenames with the extension
            removed. 
<br>
 The default operation is to return
            the result of calling
            <ref id="method**NSString**-lastPathComponent">[NSString% unknown entity: nbsp
-lastPathComponent]</ref> on the <i>path</i>.


        



<section name="enumeratorAtPath:">
<label id="method**NSFileManager**-enumeratorAtPath:" />- <code>(NSDirectoryEnumerator*) </code>
          <b>enumeratorAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns an enumerator which can be used to return
            each item with the directory at <i>path</i> in
            turn. 
<br>
 The enumeration is recursive...
            following all nested subdirectories.


        



<section name="fileAttributesAtPath:traverseLink:">
<label id="method**NSFileManager**-fileAttributesAtPath:traverseLink:" />- <code>(NSDictionary*) </code>
          <b>fileAttributesAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>traverseLink: </b>
          <code>(BOOL) </code><i>flag </i>
          <br>If a file (or directory etc) exists at the specified
            <i>path</i>, and can be queriesd for its
            attributes, this method returns a dictionary
            containing the various attributes of that file.
            Otherwise <code>nil</code> is returned. 
<br>
 If
            the <i>flag</i> is <code>NO</code> and the file is
            a symbolic link, the attributes of the link itsself
            (rather than the file it points to) are returned.
            
<br>

            The dictionary keys for attributes are -
            
            The NSDictionary class also has a set of accessor
              methods which enable you to get at file attribute
              information more efficiently than using the
              keys above to extract it. You should generally use
              the accessor methods where they are available.


        



<section name="fileExistsAtPath:">
<label id="method**NSFileManager**-fileExistsAtPath:" />- <code>(BOOL) </code>
          <b>fileExistsAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns <code>YES</code> if a file (or directory
            etc) exists at the specified <i>path</i>.


        



<section name="fileExistsAtPath:isDirectory:">
<label id="method**NSFileManager**-fileExistsAtPath:isDirectory:" />- <code>(BOOL) </code>
          <b>fileExistsAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>isDirectory: </b>
          <code>(BOOL*) </code><i>isDirectory </i>
          <br>Returns <code>YES</code> if a file (or directory
            etc) exists at the specified <i>path</i>. 
<br>

            If the <i>isDirectory</i> argument is not a nul
            pointer, stores a flag in the location it points
            to, to indicate whether the file is a directory or not.


        



<section name="fileSystemAttributesAtPath:">
<label id="method**NSFileManager**-fileSystemAttributesAtPath:" />- <code>(NSDictionary*) </code>
          <b>fileSystemAttributesAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns a dictionary containing the filesystem
            attributes for the specified <i>path</i> (or
            <code>nil</code> if the <i>path</i> is not
            valid). 
<br>


        



<section name="fileSystemRepresentationWithPath:">
<label id="method**NSFileManager**-fileSystemRepresentationWithPath:" />- <code>(const char*) </code>
          <b>fileSystemRepresentationWithPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Convert from OpenStep internal <i>path</i>
            format (unix-style) to a string in the local
            filesystem format, suitable for passing to
            system functions. 
<br>
 Under unix, this simply
            standardizes the <i>path</i> and converts
            to a C string. 
<br>
 Under windoze, this attempts to
            use local conventions to convert to a windows
            <i>path</i>. In GNUstep, the conventional unix
            syntax '~user/...' can be used to indicate a windoze
            drive specification by using the drive letter in
            place of the username.


        



<section name="isDeletableFileAtPath:">
<label id="method**NSFileManager**-isDeletableFileAtPath:" />- <code>(BOOL) </code>
          <b>isDeletableFileAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns <code>YES</code> if a file (or directory
            etc) exists at the specified <i>path</i> and is
            deletable.


        



<section name="isExecutableFileAtPath:">
<label id="method**NSFileManager**-isExecutableFileAtPath:" />- <code>(BOOL) </code>
          <b>isExecutableFileAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns <code>YES</code> if a file (or directory
            etc) exists at the specified <i>path</i> and is
            executable (if a directory is executable, you
            can access its contents).


        



<section name="isReadableFileAtPath:">
<label id="method**NSFileManager**-isReadableFileAtPath:" />- <code>(BOOL) </code>
          <b>isReadableFileAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns <code>YES</code> if a file (or directory
            etc) exists at the specified <i>path</i> and is
            readable.


        



<section name="isWritableFileAtPath:">
<label id="method**NSFileManager**-isWritableFileAtPath:" />- <code>(BOOL) </code>
          <b>isWritableFileAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns <code>YES</code> if a file (or directory
            etc) exists at the specified <i>path</i> and is
            writable.


        



<section name="linkPath:toPath:handler:">
<label id="method**NSFileManager**-linkPath:toPath:handler:" />- <code>(BOOL) </code>
          <b>linkPath: </b>
          <code>(NSString*) </code><i>source </i>
          <b>toPath: </b>
          <code>(NSString*) </code><i>destination </i>
          <b>handler: </b>
          <code>(id) </code><i>handler </i>
          <br>Links the file or directory at <i>source</i> to
            <i>destination</i>, using a <i>handler</i>
            object which should respond to
            <ref id="method**NSObject**-fileManager:willProcessPath:">[NSObject% unknown entity: nbsp
-fileManager:willProcessPath:]</ref> and <ref id="method**NSObject**-fileManager:shouldProceedAfterError:">[NSObject% unknown entity: nbsp
-fileManager:shouldProceedAfterError:]</ref> messages.


        



<section name="movePath:toPath:handler:">
<label id="method**NSFileManager**-movePath:toPath:handler:" />- <code>(BOOL) </code>
          <b>movePath: </b>
          <code>(NSString*) </code><i>source </i>
          <b>toPath: </b>
          <code>(NSString*) </code><i>destination </i>
          <b>handler: </b>
          <code>(id) </code><i>handler </i>
          <br>Moves the file or directory at <i>source</i> to
            <i>destination</i>, using a <i>handler</i>
            object which should respond to
            <ref id="method**NSObject**-fileManager:willProcessPath:">[NSObject% unknown entity: nbsp
-fileManager:willProcessPath:]</ref> and <ref id="method**NSObject**-fileManager:shouldProceedAfterError:">[NSObject% unknown entity: nbsp
-fileManager:shouldProceedAfterError:]</ref> messages.


        



<section name="pathContentOfSymbolicLinkAtPath:">
<label id="method**NSFileManager**-pathContentOfSymbolicLinkAtPath:" />- <code>(NSString*) </code>
          <b>pathContentOfSymbolicLinkAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns the name of the file or directory that the
            symbolic link at <i>path</i> points to.


        



<section name="removeFileAtPath:handler:">
<label id="method**NSFileManager**-removeFileAtPath:handler:" />- <code>(BOOL) </code>
          <b>removeFileAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>handler: </b>
          <code>(id) </code><i>handler </i>
          <br>Removes the file or directory at <i>path</i>,
            using a <i>handler</i> object which should
            respond to
            <ref id="method**NSObject**-fileManager:willProcessPath:">[NSObject% unknown entity: nbsp
-fileManager:willProcessPath:]</ref> and <ref id="method**NSObject**-fileManager:shouldProceedAfterError:">[NSObject% unknown entity: nbsp
-fileManager:shouldProceedAfterError:]</ref> messages.


        



<section name="stringWithFileSystemRepresentation:length:">
<label id="method**NSFileManager**-stringWithFileSystemRepresentation:length:" />- <code>(NSString*) </code>
          <b>stringWithFileSystemRepresentation: </b>
          <code>(const char*) </code><i>string </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>len </i>
          <br>This method converts from a local system specific
            filename representation to the internal OpenStep
            representation (unix-style). This should be
            used whenever a filename is read in from the local
            system. 
<br>
 In GNUstep, windoze drive specifiers
            are encoded in the internal path using the
            conventuional unix syntax of '~user/...'
            where the drive letter is used instead of a username.


        



<section name="subpathsAtPath:">
<label id="method**NSFileManager**-subpathsAtPath:" />- <code>(NSArray*) </code>
          <b>subpathsAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns an array containing the (relative) paths of
            all the items in the directory at <i>path</i>.
            
<br>
 The listing follows all subdirectories, so it
            can produce a very large array... use with care.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSSet">NSSet</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSMutableCopying
<br><b>Declared in: </b>NSSet.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="set">
<label id="method**NSSet**+set" />+ <code>(id) </code>
          <b>set </b>
          <br><em>Description forthcoming.</em>


        



<section name="setWithArray:">
<label id="method**NSSet**+setWithArray:" />+ <code>(id) </code>
          <b>setWithArray: </b>
          <code>(NSArray*) </code><i>objects </i>
          <br><em>Description forthcoming.</em>


        



<section name="setWithObject:">
<label id="method**NSSet**+setWithObject:" />+ <code>(id) </code>
          <b>setWithObject: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="setWithObjects:">
<label id="method**NSSet**+setWithObjects:" />+ <code>(id) </code>
          <b>setWithObjects: </b>
          <code>(id) </code><i>firstObject </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="setWithSet:">
<label id="method**NSSet**+setWithSet:" />+ <code>(id) </code>
          <b>setWithSet: </b>
          <code>(NSSet*) </code><i>aSet </i>
          <br><em>Description forthcoming.</em>


        



<section name="allObjects">
<label id="method**NSSet**-allObjects" />- <code>(NSArray*) </code>
          <b>allObjects </b>
          <br><em>Description forthcoming.</em>


        



<section name="anyObject">
<label id="method**NSSet**-anyObject" />- <code>(id) </code>
          <b>anyObject </b>
          <br><em>Description forthcoming.</em>


        



<section name="containsObject:">
<label id="method**NSSet**-containsObject:" />- <code>(BOOL) </code>
          <b>containsObject: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="count">
<label id="method**NSSet**-count" />- <code>(unsigned) </code>
          <b>count </b>
          <br>Returns the number of objects stored in the set.


        



<section name="descriptionWithLocale:">
<label id="method**NSSet**-descriptionWithLocale:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithArray:">
<label id="method**NSSet**-initWithArray:" />- <code>(id) </code>
          <b>initWithArray: </b>
          <code>(NSArray*) </code><i>other </i>
          <br>Initialises a newly allocated set by adding all
            the objects in the supplied array to the set.


        



<section name="initWithObjects:">
<label id="method**NSSet**-initWithObjects:" />- <code>(id) </code>
          <b>initWithObjects: </b>
          <code>(id) </code><i>firstObject </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="initWithObjects:count:">
<label id="method**NSSet**-initWithObjects:count:" />- <code>(id) </code>
          <b>initWithObjects: </b>
          <code>(id*) </code><i>objects </i>
          <b>count: </b>
          <code>(unsigned) </code><i>count </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithObjects:rest:">
<label id="method**NSSet**-initWithObjects:rest:" />- <code>(id) </code>
          <b>initWithObjects: </b>
          <code>(id) </code><i>firstObject </i>
          <b>rest: </b>
          <code>(va_list) </code><i>ap </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithSet:">
<label id="method**NSSet**-initWithSet:" />- <code>(id) </code>
          <b>initWithSet: </b>
          <code>(NSSet*) </code><i>other </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithSet:copyItems:">
<label id="method**NSSet**-initWithSet:copyItems:" />- <code>(id) </code>
          <b>initWithSet: </b>
          <code>(NSSet*) </code><i>other </i>
          <b>copyItems: </b>
          <code>(BOOL) </code><i>flag </i>
          <br>Initialises a newly allocated set by adding all
            the objects in the supplied set.


        



<section name="intersectsSet:">
<label id="method**NSSet**-intersectsSet:" />- <code>(BOOL) </code>
          <b>intersectsSet: </b>
          <code>(NSSet*) </code><i>otherSet </i>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToSet:">
<label id="method**NSSet**-isEqualToSet:" />- <code>(BOOL) </code>
          <b>isEqualToSet: </b>
          <code>(NSSet*) </code><i>other </i>
          <br><em>Description forthcoming.</em>


        



<section name="isSubsetOfSet:">
<label id="method**NSSet**-isSubsetOfSet:" />- <code>(BOOL) </code>
          <b>isSubsetOfSet: </b>
          <code>(NSSet*) </code><i>otherSet </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeObjectsPerform:">
<label id="method**NSSet**-makeObjectsPerform:" />- <code>(void) </code>
          <b>makeObjectsPerform: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeObjectsPerform:withObject:">
<label id="method**NSSet**-makeObjectsPerform:withObject:" />- <code>(void) </code>
          <b>makeObjectsPerform: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>withObject: </b>
          <code>(id) </code><i>argument </i>
          <br><em>Description forthcoming.</em>


        



<section name="member:">
<label id="method**NSSet**-member:" />- <code>(id) </code>
          <b>member: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="objectEnumerator">
<label id="method**NSSet**-objectEnumerator" />- <code>(NSEnumerator*) </code>
          <b>objectEnumerator </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="GSXMLDocument">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXMLDocument">GSXMLDocument</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopying
<br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="documentWithVersion:">
<label id="method**GSXMLDocument**+documentWithVersion:" />+ <code>(GSXMLDocument*) </code>
          <b>documentWithVersion: </b>
          <code>(NSString*) </code><i>version </i>
          <br><em>Description forthcoming.</em>


        



<section name="description">
<label id="method**GSXMLDocument**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br><em>Description forthcoming.</em>


        



<section name="encoding">
<label id="method**GSXMLDocument**-encoding" />- <code>(NSString*) </code>
          <b>encoding </b>
          <br><em>Description forthcoming.</em>


        



<section name="lib">
<label id="method**GSXMLDocument**-lib" />- <code>(void*) </code>
          <b>lib </b>
          <br><em>Description forthcoming.</em>


        



<section name="makeNodeWithNamespace:name:content:">
<label id="method**GSXMLDocument**-makeNodeWithNamespace:name:content:" />- <code>(GSXMLNode*) </code>
          <b>makeNodeWithNamespace: </b>
          <code>(GSXMLNamespace*) </code><i>ns </i>
          <b>name: </b>
          <code>(NSString*) </code><i>name </i>
          <b>content: </b>
          <code>(NSString*) </code><i>content </i>
          <br><em>Description forthcoming.</em>


        



<section name="root">
<label id="method**GSXMLDocument**-root" />- <code>(GSXMLNode*) </code>
          <b>root </b>
          <br><em>Description forthcoming.</em>


        



<section name="setRoot:">
<label id="method**GSXMLDocument**-setRoot:" />- <code>(GSXMLNode*) </code>
          <b>setRoot: </b>
          <code>(GSXMLNode*) </code><i>node </i>
          <br><em>Description forthcoming.</em>


        



<section name="version">
<label id="method**GSXMLDocument**-version" />- <code>(NSString*) </code>
          <b>version </b>
          <br><em>Description forthcoming.</em>


        



<section name="writeToFile:atomically:">
<label id="method**GSXMLDocument**-writeToFile:atomically:" />- <code>(BOOL) </code>
          <b>writeToFile: </b>
          <code>(NSString*) </code><i>filename </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxilliaryFile </i>
          <br><em>Description forthcoming.</em>


        



<section name="writeToURL:atomically:">
<label id="method**GSXMLDocument**-writeToURL:atomically:" />- <code>(BOOL) </code>
          <b>writeToURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxilliaryFile </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSBitmapCharSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSBitmapCharSet">NSBitmapCharSet</ref>: <ref id="NSCharacterSet">NSCharacterSet</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSBitmapCharSet.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="initWithBitmap:">
<label id="method**NSBitmapCharSet**-initWithBitmap:" />- <code>(id) </code>
          <b>initWithBitmap: </b>
          <code>(NSData*) </code><i>bitmap </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
      
</section>


</chapter>


<chapter name="GSFrameInvocation">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSFrameInvocation">GSFrameInvocation</ref>: <ref id="NSInvocation">NSInvocation</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSInvocation.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="GCObject">


<section name="Overview">
<b>Inherits From:  </b><ref id="GCObject">GCObject</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GCObject.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="gcCollectGarbage">
<label id="method**GCObject**+gcCollectGarbage" />+ <code>(void) </code>
          <b>gcCollectGarbage </b>
          <br><em>Description forthcoming.</em>


        



<section name="gcIsCollecting">
<label id="method**GCObject**+gcIsCollecting" />+ <code>(BOOL) </code>
          <b>gcIsCollecting </b>
          <br><em>Description forthcoming.</em>


        



<section name="gcObjectWillBeDeallocated:">
<label id="method**GCObject**+gcObjectWillBeDeallocated:" />+ <code>(void) </code>
          <b>gcObjectWillBeDeallocated: </b>
          <code>(GCObject*) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="gcDecrementRefCount">
<label id="method**GCObject**-gcDecrementRefCount" />- <code>(void) </code>
          <b>gcDecrementRefCount </b>
          <br><em>Description forthcoming.</em>


        



<section name="gcDecrementRefCountOfContainedObjects">
<label id="method**GCObject**-gcDecrementRefCountOfContainedObjects" />- <code>(void) </code>
          <b>gcDecrementRefCountOfContainedObjects </b>
          <br><em>Description forthcoming.</em>


        



<section name="gcIncrementRefCount">
<label id="method**GCObject**-gcIncrementRefCount" />- <code>(void) </code>
          <b>gcIncrementRefCount </b>
          <br><em>Description forthcoming.</em>


        



<section name="gcIncrementRefCountOfContainedObjects">
<label id="method**GCObject**-gcIncrementRefCountOfContainedObjects" />- <code>(BOOL) </code>
          <b>gcIncrementRefCountOfContainedObjects </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSData">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSData">NSData</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSMutableCopying
<br><b>Declared in: </b>NSData.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="data">
<label id="method**NSData**+data" />+ <code>(id) </code>
          <b>data </b>
          <br>Returns an empty data object.


        



<section name="dataWithBytes:length:">
<label id="method**NSData**+dataWithBytes:length:" />+ <code>(id) </code>
          <b>dataWithBytes: </b>
          <code>(const void*) </code><i>bytes </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br>Returns an autoreleased data object containing data
            copied from <i>bytes</i> and with the specified
            <i>length</i>. Invokes
            <ref id="method**NSData**-initWithBytes:length:">
              -initWithBytes:length:
            </ref>


        



<section name="dataWithBytesNoCopy:length:">
<label id="method**NSData**+dataWithBytesNoCopy:length:" />+ <code>(id) </code>
          <b>dataWithBytesNoCopy: </b>
          <code>(void*) </code><i>bytes </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br>Returns an autoreleased data object encapsulating
            the data at <i>bytes</i> and with the specified
            <i>length</i>. Invokes
            <ref id="method**NSData**-initWithBytesNoCopy:length:freeWhenDone:">-initWithBytesNoCopy:length:freeWhenDone:</ref> with <code>YES</code>


        



<section name="dataWithBytesNoCopy:length:freeWhenDone:">
<label id="method**NSData**+dataWithBytesNoCopy:length:freeWhenDone:" />+ <code>(id) </code>
          <b>dataWithBytesNoCopy: </b>
          <code>(void*) </code><i>aBuffer </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>bufferSize </i>
          <b>freeWhenDone: </b>
          <code>(BOOL) </code><i>shouldFree </i>
          <br>Returns an autoreleased data object encapsulating
            the data at bytes and with the specified length.
            Invokes
            <ref id="method**NSData**-initWithBytesNoCopy:length:freeWhenDone:">-initWithBytesNoCopy:length:freeWhenDone:</ref>


        



<section name="dataWithContentsOfFile:">
<label id="method**NSData**+dataWithContentsOfFile:" />+ <code>(id) </code>
          <b>dataWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns a data object encapsulating the contents of
            the specified file. Invokes
            <ref id="method**NSData**-initWithContentsOfFile:">
              -initWithContentsOfFile:
            </ref>


        



<section name="dataWithContentsOfMappedFile:">
<label id="method**NSData**+dataWithContentsOfMappedFile:" />+ <code>(id) </code>
          <b>dataWithContentsOfMappedFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns a data object encapsulating the contents of
            the specified file mapped directly into memory. Invokes
            <ref id="method**NSData**-initWithContentsOfMappedFile:">
              -initWithContentsOfMappedFile:
            </ref>


        



<section name="dataWithContentsOfURL:">
<label id="method**NSData**+dataWithContentsOfURL:" />+ <code>(id) </code>
          <b>dataWithContentsOfURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br>Retrieves the information at the specified
            <i>url</i> and returns an NSData instance
            encapsulating it.


        



<section name="dataWithData:">
<label id="method**NSData**+dataWithData:" />+ <code>(id) </code>
          <b>dataWithData: </b>
          <code>(NSData*) </code><i>data </i>
          <br>Returns an autoreleased instance initialised by
            copying the contents of <i>data</i>.


        



<section name="bytes">
<label id="method**NSData**-bytes" />- <code>(const void*) </code>
          <b>bytes </b>
          <br>Returns a pointer to the data encapsulated by the
            receiver.


        



<section name="description">
<label id="method**NSData**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br><em>Description forthcoming.</em>


        



<section name="deserializeAlignedBytesLengthAtCursor:">
<label id="method**NSData**-deserializeAlignedBytesLengthAtCursor:" />- <code>(unsigned int) </code>
          <b>deserializeAlignedBytesLengthAtCursor: </b>
          <code>(unsigned int*) </code><i>cursor </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializeBytes:length:atCursor:">
<label id="method**NSData**-deserializeBytes:length:atCursor:" />- <code>(void) </code>
          <b>deserializeBytes: </b>
          <code>(void*) </code><i>buffer </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>bytes </i>
          <b>atCursor: </b>
          <code>(unsigned int*) </code><i>cursor </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializeDataAt:ofObjCType:atCursor:context:">
<label id="method**NSData**-deserializeDataAt:ofObjCType:atCursor:context:" />- <code>(void) </code>
          <b>deserializeDataAt: </b>
          <code>(void*) </code><i>data </i>
          <b>ofObjCType: </b>
          <code>(const char*) </code><i>type </i>
          <b>atCursor: </b>
          <code>(unsigned int*) </code><i>cursor </i>
          <b>context: </b>
          <code>(id&#60;NSObjCTypeSerializationCallBack>) </code><i>callback </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializeIntAtCursor:">
<label id="method**NSData**-deserializeIntAtCursor:" />- <code>(int) </code>
          <b>deserializeIntAtCursor: </b>
          <code>(unsigned int*) </code><i>cursor </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializeIntAtIndex:">
<label id="method**NSData**-deserializeIntAtIndex:" />- <code>(int) </code>
          <b>deserializeIntAtIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializeInts:count:atCursor:">
<label id="method**NSData**-deserializeInts:count:atCursor:" />- <code>(void) </code>
          <b>deserializeInts: </b>
          <code>(int*) </code><i>intBuffer </i>
          <b>count: </b>
          <code>(unsigned int) </code><i>numInts </i>
          <b>atCursor: </b>
          <code>(unsigned int*) </code><i>cursor </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializeInts:count:atIndex:">
<label id="method**NSData**-deserializeInts:count:atIndex:" />- <code>(void) </code>
          <b>deserializeInts: </b>
          <code>(int*) </code><i>intBuffer </i>
          <b>count: </b>
          <code>(unsigned int) </code><i>numInts </i>
          <b>atIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="getBytes:">
<label id="method**NSData**-getBytes:" />- <code>(void) </code>
          <b>getBytes: </b>
          <code>(void*) </code><i>buffer </i>
          <br>Copies the contents of the memory encapsulated by
            the receiver into the specified <i>buffer</i>. The
            <i>buffer</i> must be large enough to contain
            <ref id="method**NSData**-length">
              -length
            </ref>
            bytes of data... if it isn't then a crash is likely
            to occur. 
<br>
 Invokes
            <ref id="method**NSData**-getBytes:range:">
              -getBytes:range:
            </ref>
            with the range set to the whole of the receiver.


        



<section name="getBytes:length:">
<label id="method**NSData**-getBytes:length:" />- <code>(void) </code>
          <b>getBytes: </b>
          <code>(void*) </code><i>buffer </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br>Copies <i>length</i> bytes of data from the
            memory encapsulated by the receiver into the
            specified <i>buffer</i>. The
            <i>buffer</i> must be large enough to contain
            <i>length</i> bytes of data... if it isn't then a
            crash is likely to occur. 
<br>
 Invokes
            <ref id="method**NSData**-getBytes:range:">
              -getBytes:range:
            </ref>
            with the range set to iNSMakeRange(0,
            <i>length</i>)


        



<section name="getBytes:range:">
<label id="method**NSData**-getBytes:range:" />- <code>(void) </code>
          <b>getBytes: </b>
          <code>(void*) </code><i>buffer </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Copies data from the memory encapsulated by the
            receiver (in the range specified by
            <i>aRange</i>) into the specified
            <i>buffer</i>. 
<br>
 The <i>buffer</i> must
            be large enough to contain the data... if it isn't then
            a crash is likely to occur. 
<br>
 If <i>aRange</i>
            specifies a range which does not entirely lie
            within the receiver, an exception is raised.


        



<section name="initWithBytes:length:">
<label id="method**NSData**-initWithBytes:length:" />- <code>(id) </code>
          <b>initWithBytes: </b>
          <code>(const void*) </code><i>aBuffer </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>bufferSize </i>
          <br>Makes a copy of <i>bufferSize</i> bytes of data
            at <i>aBuffer</i>, and passes it to
            <ref id="method**NSData**-initWithBytesNoCopy:length:freeWhenDone:">-initWithBytesNoCopy:length:freeWhenDone:</ref> with a <code>YES</code> argument in order to initialise the receiver. Returns the result.


        



<section name="initWithBytesNoCopy:length:">
<label id="method**NSData**-initWithBytesNoCopy:length:" />- <code>(id) </code>
          <b>initWithBytesNoCopy: </b>
          <code>(void*) </code><i>aBuffer </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>bufferSize </i>
          <br>Invokes
            <ref id="method**NSData**-initWithBytesNoCopy:length:freeWhenDone:">-initWithBytesNoCopy:length:freeWhenDone:</ref> with the last argument set to <code>YES</code>. Returns the resulting initialised data object (which may not be the receiver).


        



<section name="initWithBytesNoCopy:length:freeWhenDone:">
<label id="method**NSData**-initWithBytesNoCopy:length:freeWhenDone:" />- <code>(id) </code>
          <b>initWithBytesNoCopy: </b>
          <code>(void*) </code><i>aBuffer </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>bufferSize </i>
          <b>freeWhenDone: </b>
          <code>(BOOL) </code><i>shouldFree </i>
          <br>Initialises the receiver. 
<br>
 The value of
            <i>aBuffer</i> is a pointer to something to be
            stored. 
<br>
 The value of <i>bufferSize</i>
            is the number of bytes to use. 
<br>
 The value fo
            <i>shouldFree</i> specifies whether the receiver
            should attempt to free the memory pointer to by
            <i>aBuffer</i> when the receiver is deallocated
            ... ie. it says whether the receiver <em>owns</em> the
            memory. Supplying the wrong value here will lead to
            memory leaks or crashes.


        



<section name="initWithContentsOfFile:">
<label id="method**NSData**-initWithContentsOfFile:" />- <code>(id) </code>
          <b>initWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Initialises the receiver with the contents of
            the specified file. 
<br>
 Returns the resulting
            object. 
<br>
 Returns <code>nil</code> if the file
            does not exist or can not be read for some reason.


        



<section name="initWithContentsOfMappedFile:">
<label id="method**NSData**-initWithContentsOfMappedFile:" />- <code>(id) </code>
          <b>initWithContentsOfMappedFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithContentsOfURL:">
<label id="method**NSData**-initWithContentsOfURL:" />- <code>(id) </code>
          <b>initWithContentsOfURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithData:">
<label id="method**NSData**-initWithData:" />- <code>(id) </code>
          <b>initWithData: </b>
          <code>(NSData*) </code><i>data </i>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToData:">
<label id="method**NSData**-isEqualToData:" />- <code>(BOOL) </code>
          <b>isEqualToData: </b>
          <code>(NSData*) </code><i>other </i>
          <br>Returns a boolean value indicating if the receiver
            and <i>other</i> contain identical data (using a
            byte by byte comparison). Assumes that the
            <i>other</i> object is an NSData instance... may
            raise an exception if it isn't.


        



<section name="length">
<label id="method**NSData**-length" />- <code>(unsigned int) </code>
          <b>length </b>
          <br>Returns the number of bytes of data encapsulated by
            the receiver.


        



<section name="subdataWithRange:">
<label id="method**NSData**-subdataWithRange:" />- <code>(NSData*) </code>
          <b>subdataWithRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Returns an NSData instance encapsulating the memory
            from the reciever specified by the range
            <i>aRange</i>. 
<br>
 If <i>aRange</i>
            specifies a range which does not entirely lie
            within the receiver, an exception is raised.


        



<section name="writeToFile:atomically:">
<label id="method**NSData**-writeToFile:atomically:" />- <code>(BOOL) </code>
          <b>writeToFile: </b>
          <code>(NSString*) </code><i>path </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxiliaryFile </i>
          <br>Writes a copy of the data encapsulated by the
              receiver to a file at <i>path</i>. If the
              <i>useAuxiliaryFile</i> flag is
              <code>YES</code>, this writes to a temporary file
              and then renames that to the file at <i>path</i>,
              thus ensuring that <i>path</i> exists and does
              not contain partially written data at any point.
            On success returns <code>YES</code>, on failure
              returns <code>NO</code>.


        



<section name="writeToURL:atomically:">
<label id="method**NSData**-writeToURL:atomically:" />- <code>(BOOL) </code>
          <b>writeToURL: </b>
          <code>(NSURL*) </code><i>anURL </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>flag </i>
          <br>Writes a copy of the contents of the receiver to the
            specified URL.


        


</section>


</chapter>


<chapter name="NSURLHandle">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSURLHandle">NSURLHandle</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSURLHandle.h
</section>

<section name="Description">
<br>An NSURLHandle instance is used to manage the resource
            data corresponding to an NSURL object. A single
            NSURLHandle can be used to manage multiple
            NSURL objects as long as those objects all refer to
            the same resource.
          Different NSURLHandle subclasses are used to
            manage different types of URL (usually based on the
            scheme of the URL), and you can register new
            subclasses to extend (or replace) the standard
            ones.
          GNUstep comes with private subclasses to handle the
            common URL schemes -


</section>

<section name="Methods">


<section name="URLHandleClassForURL:">
<label id="method**NSURLHandle**+URLHandleClassForURL:" />+ <code>(Class) </code>
          <b>URLHandleClassForURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br>Returns the most recently registered NSURLHandle
            subclass that responds to
            <ref id="method**NSURLHandle**+canInitWithURL:">
              +canInitWithURL:
            </ref>
            with <code>YES</code>. If there is no such subclass,
            returns <code>nil</code>.


        



<section name="cachedHandleForURL:">
<label id="method**NSURLHandle**+cachedHandleForURL:" />+ <code>(NSURLHandle*) </code>
          <b>cachedHandleForURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br>Return a handle for the specified URL from the cache
            if possible. If the cache does not contain a matching
            handle, returns <code>nil</code>.


        



<section name="canInitWithURL:">
<label id="method**NSURLHandle**+canInitWithURL:" />+ <code>(BOOL) </code>
          <b>canInitWithURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br>Implemented by subclasses to say which URLs
            they can handle. This method is used to determine
            which subclasses can be used to handle a particular
            URL.


        



<section name="registerURLHandleClass:">
<label id="method**NSURLHandle**+registerURLHandleClass:" />+ <code>(void) </code>
          <b>registerURLHandleClass: </b>
          <code>(Class) </code><i>urlHandleSubclass </i>
          <br>Used to register a subclass as being available to
            handle URLs.


        



<section name="addClient:">
<label id="method**NSURLHandle**-addClient:" />- <code>(void) </code>
          <b>addClient: </b>
          <code>(id&#60;NSURLHandleClient>) </code><i>client </i>
          <br>Add a <i>client</i> object, making sure that it
            doesn't occur more than once. 
<br>
 The
            <i>client</i> object will receive messages
            notifying it of events on the handle.


        



<section name="availableResourceData">
<label id="method**NSURLHandle**-availableResourceData" />- <code>(NSData*) </code>
          <b>availableResourceData </b>
          <br>Returns the resource data that is currently
            available for the handle. This may be a partially
            loaded resource or may be empty of no data has been
            loaded yet.


        



<section name="backgroundLoadDidFailWithReason:">
<label id="method**NSURLHandle**-backgroundLoadDidFailWithReason:" />- <code>(void) </code>
          <b>backgroundLoadDidFailWithReason: </b>
          <code>(NSString*) </code><i>reason </i>
          <br>This method should be called when a background load
            fails. 
<br>
 The method passes the failure
            notification to the clients of the handle - so
            subclasses should call super's implementation at
            the end of their implementation of this method.


        



<section name="beginLoadInBackground">
<label id="method**NSURLHandle**-beginLoadInBackground" />- <code>(void) </code>
          <b>beginLoadInBackground </b>
          <br>This method is called by when a background load
            begins. Subclasses should call super's
            implementation at the end of their
            implementation of this method.


        



<section name="cancelLoadInBackground">
<label id="method**NSURLHandle**-cancelLoadInBackground" />- <code>(void) </code>
          <b>cancelLoadInBackground </b>
          <br>This method should be called to cancel a load
            currently in progress. The method calls
            <ref id="method**NSURLHandle**-endLoadInBackground">
              -endLoadInBackground
            </ref>
            Subclasses should call super's implementation at
            the end of their implementation of this method.


        



<section name="didLoadBytes:loadComplete:">
<label id="method**NSURLHandle**-didLoadBytes:loadComplete:" />- <code>(void) </code>
          <b>didLoadBytes: </b>
          <code>(NSData*) </code><i>newData </i>
          <b>loadComplete: </b>
          <code>(BOOL) </code><i>loadComplete </i>
          <br>Method called by subclasses during process of
            loading a resource. The base class maintains a copy
            of the data being read in and accumulates separate parts
            of the data.


        



<section name="endLoadInBackground">
<label id="method**NSURLHandle**-endLoadInBackground" />- <code>(void) </code>
          <b>endLoadInBackground </b>
          <br>This method is called to stop any background loading
            process.
            <ref id="method**NSURLHandle**-cancelLoadInBackground">
              -cancelLoadInBackground
            </ref>
            uses this method to cancel loading. Subclasses should
            call super's implementation at the end of their
            implementation of this method.


        



<section name="failureReason">
<label id="method**NSURLHandle**-failureReason" />- <code>(NSString*) </code>
          <b>failureReason </b>
          <br>Returns the failure reason for the last failure to
            load the resource data.


        



<section name="flushCachedData">
<label id="method**NSURLHandle**-flushCachedData" />- <code>(void) </code>
          <b>flushCachedData </b>
          <br>Flushes any cached resource data.


        



<section name="initWithURL:cached:">
<label id="method**NSURLHandle**-initWithURL:cached:" />- <code>(id) </code>
          <b>initWithURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <b>cached: </b>
          <code>(BOOL) </code><i>cached </i>
          <br>Initialises a handle with the specified URL.
            
<br>
 The flag determines whether the handle will
            cache resource data and respond to requests from
            equivalent URLs for the <i>cached</i> data.


        



<section name="loadInBackground">
<label id="method**NSURLHandle**-loadInBackground" />- <code>(void) </code>
          <b>loadInBackground </b>
          <br>Starts (or queues) loading of the handle's resource
            data in the background (asynchronously). 
<br>
 The
            default implementation uses loadInForeground - if
            this method is not overridden, loadInForeground MUST
            be.


        



<section name="loadInForeground">
<label id="method**NSURLHandle**-loadInForeground" />- <code>(NSData*) </code>
          <b>loadInForeground </b>
          <br>Loads the handle's resource data in the foreground
            (synchronously). 
<br>
 The default
            implementation starts a background load and
            waits for it to complete - if this method is not
            overridden, loadInBackground MUST be.


        



<section name="propertyForKey:">
<label id="method**NSURLHandle**-propertyForKey:" />- <code>(id) </code>
          <b>propertyForKey: </b>
          <code>(NSString*) </code><i>propertyKey </i>
          <br>Returns the property for the specified key, or
            <code>nil</code> if the key does not exist.


        



<section name="propertyForKeyIfAvailable:">
<label id="method**NSURLHandle**-propertyForKeyIfAvailable:" />- <code>(id) </code>
          <b>propertyForKeyIfAvailable: </b>
          <code>(NSString*) </code><i>propertyKey </i>
          <br>Returns the property for the specified key, but
            only if the handle does not need to do any work to
            retrieve it.


        



<section name="removeClient:">
<label id="method**NSURLHandle**-removeClient:" />- <code>(void) </code>
          <b>removeClient: </b>
          <code>(id&#60;NSURLHandleClient>) </code><i>client </i>
          <br>Removes an object from them list of clients
            notified of resource loading events by the URL
            handle.


        



<section name="resourceData">
<label id="method**NSURLHandle**-resourceData" />- <code>(NSData*) </code>
          <b>resourceData </b>
          <br>Returns the resource data belonging to the handle.
            Calls
            <ref id="method**NSURLHandle**-loadInForeground">
              -loadInForeground
            </ref>
            if necessary.
            The GNUstep implementation treats an <em>ftp:</em>
              request for a directory as a request to list the
              names of the directory contents.


        



<section name="status">
<label id="method**NSURLHandle**-status" />- <code>(NSURLHandleStatus) </code>
          <b>status </b>
          <br>Returns the current status of the handle.


        



<section name="writeData:">
<label id="method**NSURLHandle**-writeData:" />- <code>(BOOL) </code>
          <b>writeData: </b>
          <code>(NSData*) </code><i>data </i>
          <br>Writes resource <i>data</i> to the handle.
              Returns <code>YES</code> on success,
              <code>NO</code> on failure.
            The GNUstep implementation for <em>file:</em> writes
              the <i>data</i> directly to the local filesystem,
              and the return status reflects the result of that
              write operation.
            The GNUstep implementation for <em>http:</em> and
              <em>https:</em> sets the specified <i>data</i>
              as information to be POSTed to the URL next time it is
              loaded - so the method always returns
              <code>YES</code>.
            The GNUstep implementation for <em>ftp:</em> sets the
              specified <i>data</i> as information to be
              weitten to the URL next time it is loaded - so
              the method always returns <code>YES</code>.


        



<section name="writeProperty:forKey:">
<label id="method**NSURLHandle**-writeProperty:forKey:" />- <code>(BOOL) </code>
          <b>writeProperty: </b>
          <code>(id) </code><i>propertyValue </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>propertyKey </i>
          <br>Sets a property for handle. Returns <code>YES</code>
              on success, <code>NO</code> on failure.
            The GNUstep implementation sets the property as a
              header to be sent the next time the URL is loaded,
              and recognizes some special property keys which
              control the behavior of the next load.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GSFFIInvocation">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSFFIInvocation">GSFFIInvocation</ref>: <ref id="NSInvocation">NSInvocation</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSInvocation.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSNotification">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSNotification">NSNotification</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopyingNSCoding
<br><b>Declared in: </b>NSNotification.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
      

<section name="notificationWithName:object:">
<label id="method**NSNotification**+notificationWithName:object:" />+ <code>(NSNotification*) </code>
          <b>notificationWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>object: </b>
          <code>(id) </code><i>object </i>
          <br>Create a new autoreleased notification by calling
            <ref id="method**NSNotification**+notificationWithName:object:userInfo:">+notificationWithName:object:userInfo:</ref> with a <code>nil</code> user info argument.


        



<section name="notificationWithName:object:userInfo:">
<label id="method**NSNotification**+notificationWithName:object:userInfo:" />+ <code>(NSNotification*) </code>
          <b>notificationWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>object: </b>
          <code>(id) </code><i>object </i>
          <b>userInfo: </b>
          <code>(NSDictionary*) </code><i>info </i>
          <br>Create a new autoreleased notification. Concrete
            subclasses override this method to create actual
            notification objects.


        



<section name="name">
<label id="method**NSNotification**-name" />- <code>(NSString*) </code>
          <b>name </b>
          <br>Concrete subclasses of NSNotification are
            responsible for implementing this method to
            return the notification name.


        



<section name="object">
<label id="method**NSNotification**-object" />- <code>(id) </code>
          <b>object </b>
          <br>Concrete subclasses of NSNotification are
            responsible for implementing this method to
            return the notification object.


        



<section name="userInfo">
<label id="method**NSNotification**-userInfo" />- <code>(NSDictionary*) </code>
          <b>userInfo </b>
          <br>Concrete subclasses of NSNotification are
            responsible for implementing this method to
            return the notification user information.


        


</section>


</chapter>


<chapter name="NSUIntNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSUIntNumber">NSUIntNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSUShortNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSUShortNumber">NSUShortNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSDistributedNotificationCenter">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDistributedNotificationCenter">NSDistributedNotificationCenter</ref>: <ref id="NSNotificationCenter">NSNotificationCenter</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSDistributedNotificationCenter.h
</section>

<section name="Description">
<br>The NSDistributedNotificationCenter provides a
            versatile yet simple mechanism for objects in
            different processes to communicate effectively
            while knowing very little about each others
            internals. 
<br>
 A distributed notification
            center acts much like a normal notification center,
            but it handles notifications on a machine-wide (or
            local network wide) basis rather than just
            notifications within a single process.
            Objects are able to register themselves as
            observers for particular notification names and
            objects, and they will then receive notifications
            (including optional user information consisting
            of a dictionary of property-list objects) as they are
            posted.
          Since posting of distributed notifications involves
            inter-process (and sometimes inter-host)
            communication, it is fundamentally slower
            than normal notifications, and should be used
            relatively sparingly. In order to help with
            this, the NSDistributedNotificationCenter provides a
            notion of 'suspension', whereby a center can be
            suspended causing notifications for observers in
            the process where the center was suspended to cease
            receiving notifications. Observers can specify
            how notifications are to be handled in this case
            (queued or discarded) and posters can specify that
            particular notifications are to be delivered
            immediately irrespective of suspension.
          Distributed notifications are mediated by a
            server process which handles all notifications for a
            particular center type. In GNUstep this process
            is the gdnc tool, and when started without special
            options, a gdnc process acts as the local centre
            for the host it is running on. When started with the
            GSNetwork user default set to <code>YES</code>,
            the gdnc tool acts as a local network wide server (you
            should only run one copy of gdnc like this on your
            LAN). 
<br>
 The gdnc process should be started at
            machine boot time, but GNUstep will attempt to
            start it automatically if it can't find it.
          MacOS-X currently defines only a notification
            center for the local host. GNUstep also defines a
            local network center which can be used from multiple
            hosts. By default the system sends this to any gdnc
            process it can find which is configured as a
            network-wide server, but the GDNCHost user
            default may be used to specify a particular host to
            be contacted... this may be of use where you wish to
            have logically separate clusters of machines on a
            shared LAN.


</section>

<section name="Methods">


<section name="defaultCenter">
<label id="method**NSDistributedNotificationCenter**+defaultCenter" />+ <code>(NSNotificationCenter*) </code>
          <b>defaultCenter </b>
          <br>Returns the default notification center... a shared
            notification center for the local host. This
            is simply a convenience method equivalent to calling
            <ref id="method**NSDistributedNotificationCenter**+notificationCenterForType:">
              +notificationCenterForType:
            </ref>
            with NSLocalNotificationCenterType as its argument.


        



<section name="notificationCenterForType:">
<label id="method**NSDistributedNotificationCenter**+notificationCenterForType:" />+ <code>(NSNotificationCenter*) </code>
          <b>notificationCenterForType: </b>
          <code>(NSString*) </code><i>type </i>
          <br>Returns a notification center of the specified
            <i>type</i>. 
<br>
 The
            NSLocalNotificationCenterType
            provides a shared access to a notificatiuon center
            used by processes on the local host. 
<br>
 The
            GSNetworkNotificationCenterType
            provides a shared access to a notificatiuon center
            used by processes on the local network. 
<br>
 MacOS-X
            supports only NSLocalNotificationCenterType.


        



<section name="addObserver:selector:name:object:">
<label id="method**NSDistributedNotificationCenter**-addObserver:selector:name:object:" />- <code>(void) </code>
          <b>addObserver: </b>
          <code>(id) </code><i>anObserver </i>
          <b>selector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>name: </b>
          <code>(NSString*) </code><i>notificationName </i>
          <b>object: </b>
          <code>(NSString*) </code><i>anObject </i>
          <br>Adds an observer to the receiver. Calls
            <ref id="method**NSDistributedNotificationCenter**-addObserver:selector:name:object:suspensionBehavior:">-addObserver:selector:name:object:suspensionBehavior:</ref> with NSNotificationSuspensionBehaviorCoalesce.


        



<section name="addObserver:selector:name:object:suspensionBehavior:">
<label id="method**NSDistributedNotificationCenter**-addObserver:selector:name:object:suspensionBehavior:" />- <code>(void) </code>
          <b>addObserver: </b>
          <code>(id) </code><i>anObserver </i>
          <b>selector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>name: </b>
          <code>(NSString*) </code><i>notificationName </i>
          <b>object: </b>
          <code>(NSString*) </code><i>anObject </i>
          <b>suspensionBehavior: </b>
          <code>(NSNotificationSuspensionBehavior) </code><i>suspensionBehavior </i>
          <br>Adds an observer to the receiver. 
<br>
 When a
            notification matching
            <i>notificationName</i> and <i>anObject</i>
            is sent to the center, the object <i>anObserver</i>
            is sent the message <i>aSelector</i> with the
            notification info dictionary as its argument.
            
<br>
 The <i>suspensionBehavior</i> governs how
            the center deals with notifications when the process to
            which the notification should be delivered is
            suspended:


        



<section name="postNotification:">
<label id="method**NSDistributedNotificationCenter**-postNotification:" />- <code>(void) </code>
          <b>postNotification: </b>
          <code>(NSNotification*) </code><i>notification </i>
          <br>Posts the <i>notification</i> to the center using
            postNotificationName:object:userInfo:deliverImmediately:
            with the delivery flag set to <code>NO</code>.


        



<section name="postNotificationName:object:">
<label id="method**NSDistributedNotificationCenter**-postNotificationName:object:" />- <code>(void) </code>
          <b>postNotificationName: </b>
          <code>(NSString*) </code><i>notificationName </i>
          <b>object: </b>
          <code>(NSString*) </code><i>anObject </i>
          <br>Posts the <i>notificationName</i> and
            <i>anObject</i> to the center using
            postNotificationName:object:userInfo:deliverImmediately:
            with the user info set to <code>nil</code> and the
            delivery flag set to <code>NO</code>.


        



<section name="postNotificationName:object:userInfo:">
<label id="method**NSDistributedNotificationCenter**-postNotificationName:object:userInfo:" />- <code>(void) </code>
          <b>postNotificationName: </b>
          <code>(NSString*) </code><i>notificationName </i>
          <b>object: </b>
          <code>(NSString*) </code><i>anObject </i>
          <b>userInfo: </b>
          <code>(NSDictionary*) </code><i>userInfo </i>
          <br>Posts the <i>notificationName</i>,
            <i>anObject</i> and <i>userInfo</i> to the
            center using
            postNotificationName:object:userInfo:deliverImmediately:
            with the delivery flag set to <code>NO</code>.


        



<section name="postNotificationName:object:userInfo:deliverImmediately:">
<label id="method**NSDistributedNotificationCenter**-postNotificationName:object:userInfo:deliverImmediately:" />- <code>(void) </code>
          <b>postNotificationName: </b>
          <code>(NSString*) </code><i>notificationName </i>
          <b>object: </b>
          <code>(NSString*) </code><i>anObject </i>
          <b>userInfo: </b>
          <code>(NSDictionary*) </code><i>userInfo </i>
          <b>deliverImmediately: </b>
          <code>(BOOL) </code><i>deliverImmediately </i>
          <br>The primitive notification posting method... 
<br>
 The
            <i>userInfo</i> dictionary may contain only
            property-list objects. 
<br>
 The
            <i>deliverImmediately</i> flag specifies whether
            the suspension state of the receiving process is to be
            ignored.


        



<section name="removeObserver:name:object:">
<label id="method**NSDistributedNotificationCenter**-removeObserver:name:object:" />- <code>(void) </code>
          <b>removeObserver: </b>
          <code>(id) </code><i>anObserver </i>
          <b>name: </b>
          <code>(NSString*) </code><i>notificationName </i>
          <b>object: </b>
          <code>(NSString*) </code><i>anObject </i>
          <br>Removes the observer from the center.


        



<section name="setSuspended:">
<label id="method**NSDistributedNotificationCenter**-setSuspended:" />- <code>(void) </code>
          <b>setSuspended: </b>
          <code>(BOOL) </code><i>flag </i>
          <br>Sets the suspension state of the receiver... if the
            receiver is suspended, it won't handle
            notification until it is unsuspended again,
            unless the notifications are posted to be delivered
            immediately.


        



<section name="suspended">
<label id="method**NSDistributedNotificationCenter**-suspended" />- <code>(BOOL) </code>
          <b>suspended </b>
          <br>Returns the current suspension state of the
            receiver.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSNotificationQueue">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSNotificationQueue">NSNotificationQueue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSNotificationQueue.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="defaultQueue">
<label id="method**NSNotificationQueue**+defaultQueue" />+ <code>(NSNotificationQueue*) </code>
          <b>defaultQueue </b>
          <br><em>Description forthcoming.</em>


        



<section name="dequeueNotificationsMatching:coalesceMask:">
<label id="method**NSNotificationQueue**-dequeueNotificationsMatching:coalesceMask:" />- <code>(void) </code>
          <b>dequeueNotificationsMatching: </b>
          <code>(NSNotification*) </code><i>notification </i>
          <b>coalesceMask: </b>
          <code>(unsigned int) </code><i>coalesceMask </i>
          <br><em>Description forthcoming.</em>


        



<section name="enqueueNotification:postingStyle:">
<label id="method**NSNotificationQueue**-enqueueNotification:postingStyle:" />- <code>(void) </code>
          <b>enqueueNotification: </b>
          <code>(NSNotification*) </code><i>notification </i>
          <b>postingStyle: </b>
          <code>(NSPostingStyle) </code><i>postingStyle </i>
          <br><em>Description forthcoming.</em>


        



<section name="enqueueNotification:postingStyle:coalesceMask:forModes:">
<label id="method**NSNotificationQueue**-enqueueNotification:postingStyle:coalesceMask:forModes:" />- <code>(void) </code>
          <b>enqueueNotification: </b>
          <code>(NSNotification*) </code><i>notification </i>
          <b>postingStyle: </b>
          <code>(NSPostingStyle) </code><i>postingStyle </i>
          <b>coalesceMask: </b>
          <code>(unsigned int) </code><i>coalesceMask </i>
          <b>forModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithNotificationCenter:">
<label id="method**NSNotificationQueue**-initWithNotificationCenter:" />- <code>(id) </code>
          <b>initWithNotificationCenter: </b>
          <code>(NSNotificationCenter*) </code><i>notificationCenter </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GCArray">


<section name="Overview">
<b>Inherits From:  </b><ref id="GCArray">GCArray</ref>: <ref id="NSArray">NSArray</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GCObject.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="GCMutableDictionary">


<section name="Overview">
<b>Inherits From:  </b><ref id="GCMutableDictionary">GCMutableDictionary</ref>: <ref id="NSMutableDictionary">NSMutableDictionary</ref>: <ref id="NSDictionary">NSDictionary</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GCObject.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="GSMimeCodingContext">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSMimeCodingContext">GSMimeCodingContext</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSMime.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="atEnd">
<label id="method**GSMimeCodingContext**-atEnd" />- <code>(BOOL) </code>
          <b>atEnd </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodeData:length:intoData:">
<label id="method**GSMimeCodingContext**-decodeData:length:intoData:" />- <code>(BOOL) </code>
          <b>decodeData: </b>
          <code>(const void*) </code><i>sData </i>
          <b>length: </b>
          <code>(unsigned) </code><i>length </i>
          <b>intoData: </b>
          <code>(NSMutableData*) </code><i>dData </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAtEnd:">
<label id="method**GSMimeCodingContext**-setAtEnd:" />- <code>(void) </code>
          <b>setAtEnd: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
      
</section>


</chapter>


<chapter name="GSXPathString">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXPathString">GSXPathString</ref>: <ref id="GSXPathObject">GSXPathObject</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br>For XPath queries returning a string.


</section>

<section name="Methods">


<section name="stringValue">
<label id="method**GSXPathString**-stringValue" />- <code>(NSString*) </code>
          <b>stringValue </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
      
</section>


</chapter>


<chapter name="NSDate">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDate">NSDate</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopying
<br><b>Declared in: </b>NSDate.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="date">
<label id="method**NSDate**+date" />+ <code>(id) </code>
          <b>date </b>
          <br><em>Description forthcoming.</em>


        



<section name="dateWithNaturalLanguageString:">
<label id="method**NSDate**+dateWithNaturalLanguageString:" />+ <code>(id) </code>
          <b>dateWithNaturalLanguageString: </b>
          <code>(NSString*) </code><i>string </i>
          <br><em>Description forthcoming.</em>


        



<section name="dateWithNaturalLanguageString:locale:">
<label id="method**NSDate**+dateWithNaturalLanguageString:locale:" />+ <code>(id) </code>
          <b>dateWithNaturalLanguageString: </b>
          <code>(NSString*) </code><i>string </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br><em>Description forthcoming.</em>


        



<section name="dateWithString:">
<label id="method**NSDate**+dateWithString:" />+ <code>(id) </code>
          <b>dateWithString: </b>
          <code>(NSString*) </code><i>description </i>
          <br><em>Description forthcoming.</em>


        



<section name="dateWithTimeIntervalSince1970:">
<label id="method**NSDate**+dateWithTimeIntervalSince1970:" />+ <code>(id) </code>
          <b>dateWithTimeIntervalSince1970: </b>
          <code>(NSTimeInterval) </code><i>seconds </i>
          <br><em>Description forthcoming.</em>


        



<section name="dateWithTimeIntervalSinceNow:">
<label id="method**NSDate**+dateWithTimeIntervalSinceNow:" />+ <code>(id) </code>
          <b>dateWithTimeIntervalSinceNow: </b>
          <code>(NSTimeInterval) </code><i>seconds </i>
          <br><em>Description forthcoming.</em>


        



<section name="dateWithTimeIntervalSinceReferenceDate:">
<label id="method**NSDate**+dateWithTimeIntervalSinceReferenceDate:" />+ <code>(id) </code>
          <b>dateWithTimeIntervalSinceReferenceDate: </b>
          <code>(NSTimeInterval) </code><i>seconds </i>
          <br><em>Description forthcoming.</em>


        



<section name="distantFuture">
<label id="method**NSDate**+distantFuture" />+ <code>(id) </code>
          <b>distantFuture </b>
          <br><em>Description forthcoming.</em>


        



<section name="distantPast">
<label id="method**NSDate**+distantPast" />+ <code>(id) </code>
          <b>distantPast </b>
          <br><em>Description forthcoming.</em>


        



<section name="timeIntervalSinceReferenceDate">
<label id="method**NSDate**+timeIntervalSinceReferenceDate" />+ <code>(NSTimeInterval) </code>
          <b>timeIntervalSinceReferenceDate </b>
          <br><em>Description forthcoming.</em>


        



<section name="addTimeInterval:">
<label id="method**NSDate**-addTimeInterval:" />- <code>(id) </code>
          <b>addTimeInterval: </b>
          <code>(NSTimeInterval) </code><i>seconds </i>
          <br><em>Description forthcoming.</em>


        



<section name="compare:">
<label id="method**NSDate**-compare:" />- <code>(NSComparisonResult) </code>
          <b>compare: </b>
          <code>(NSDate*) </code><i>otherDate </i>
          <br><em>Description forthcoming.</em>


        



<section name="dateWithCalendarFormat:timeZone:">
<label id="method**NSDate**-dateWithCalendarFormat:timeZone:" />- <code>(NSCalendarDate*) </code>
          <b>dateWithCalendarFormat: </b>
          <code>(NSString*) </code><i>formatString </i>
          <b>timeZone: </b>
          <code>(NSTimeZone*) </code><i>timeZone </i>
          <br><em>Description forthcoming.</em>


        



<section name="description">
<label id="method**NSDate**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br><em>Description forthcoming.</em>


        



<section name="descriptionWithCalendarFormat:timeZone:locale:">
<label id="method**NSDate**-descriptionWithCalendarFormat:timeZone:locale:" />- <code>(NSString*) </code>
          <b>descriptionWithCalendarFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>timeZone: </b>
          <code>(NSTimeZone*) </code><i>aTimeZone </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>l </i>
          <br><em>Description forthcoming.</em>


        



<section name="descriptionWithLocale:">
<label id="method**NSDate**-descriptionWithLocale:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br><em>Description forthcoming.</em>


        



<section name="earlierDate:">
<label id="method**NSDate**-earlierDate:" />- <code>(NSDate*) </code>
          <b>earlierDate: </b>
          <code>(NSDate*) </code><i>otherDate </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithString:">
<label id="method**NSDate**-initWithString:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>description </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithTimeInterval:sinceDate:">
<label id="method**NSDate**-initWithTimeInterval:sinceDate:" />- <code>(id) </code>
          <b>initWithTimeInterval: </b>
          <code>(NSTimeInterval) </code><i>secsToBeAdded </i>
          <b>sinceDate: </b>
          <code>(NSDate*) </code><i>anotherDate </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithTimeIntervalSince1970:">
<label id="method**NSDate**-initWithTimeIntervalSince1970:" />- <code>(id) </code>
          <b>initWithTimeIntervalSince1970: </b>
          <code>(NSTimeInterval) </code><i>seconds </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithTimeIntervalSinceNow:">
<label id="method**NSDate**-initWithTimeIntervalSinceNow:" />- <code>(id) </code>
          <b>initWithTimeIntervalSinceNow: </b>
          <code>(NSTimeInterval) </code><i>secsToBeAdded </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithTimeIntervalSinceReferenceDate:">
<label id="method**NSDate**-initWithTimeIntervalSinceReferenceDate:" />- <code>(id) </code>
          <b>initWithTimeIntervalSinceReferenceDate: </b>
          <code>(NSTimeInterval) </code><i>secs </i>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToDate:">
<label id="method**NSDate**-isEqualToDate:" />- <code>(BOOL) </code>
          <b>isEqualToDate: </b>
          <code>(NSDate*) </code><i>other </i>
          <br><em>Description forthcoming.</em>


        



<section name="laterDate:">
<label id="method**NSDate**-laterDate:" />- <code>(NSDate*) </code>
          <b>laterDate: </b>
          <code>(NSDate*) </code><i>otherDate </i>
          <br><em>Description forthcoming.</em>


        



<section name="timeIntervalSince1970">
<label id="method**NSDate**-timeIntervalSince1970" />- <code>(NSTimeInterval) </code>
          <b>timeIntervalSince1970 </b>
          <br><em>Description forthcoming.</em>


        



<section name="timeIntervalSinceDate:">
<label id="method**NSDate**-timeIntervalSinceDate:" />- <code>(NSTimeInterval) </code>
          <b>timeIntervalSinceDate: </b>
          <code>(NSDate*) </code><i>otherDate </i>
          <br><em>Description forthcoming.</em>


        



<section name="timeIntervalSinceNow">
<label id="method**NSDate**-timeIntervalSinceNow" />- <code>(NSTimeInterval) </code>
          <b>timeIntervalSinceNow </b>
          <br><em>Description forthcoming.</em>


        



<section name="timeIntervalSinceReferenceDate">
<label id="method**NSDate**-timeIntervalSinceReferenceDate" />- <code>(NSTimeInterval) </code>
          <b>timeIntervalSinceReferenceDate </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="GSXMLNamespace">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXMLNamespace">GSXMLNamespace</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopying
<br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
      

<section name="descriptionFromType:">
<label id="method**GSXMLNamespace**+descriptionFromType:" />+ <code>(NSString*) </code>
          <b>descriptionFromType: </b>
          <code>(int) </code><i>type </i>
          <br><em>Description forthcoming.</em>


        



<section name="typeFromDescription:">
<label id="method**GSXMLNamespace**+typeFromDescription:" />+ <code>(int) </code>
          <b>typeFromDescription: </b>
          <code>(NSString*) </code><i>desc </i>
          <br><em>Description forthcoming.</em>


        



<section name="href">
<label id="method**GSXMLNamespace**-href" />- <code>(NSString*) </code>
          <b>href </b>
          <br><em>Description forthcoming.</em>


        



<section name="lib">
<label id="method**GSXMLNamespace**-lib" />- <code>(void*) </code>
          <b>lib </b>
          <br><em>Description forthcoming.</em>


        



<section name="next">
<label id="method**GSXMLNamespace**-next" />- <code>(GSXMLNamespace*) </code>
          <b>next </b>
          <br><em>Description forthcoming.</em>


        



<section name="prefix">
<label id="method**GSXMLNamespace**-prefix" />- <code>(NSString*) </code>
          <b>prefix </b>
          <br><em>Description forthcoming.</em>


        



<section name="type">
<label id="method**GSXMLNamespace**-type" />- <code>(int) </code>
          <b>type </b>
          <br><em>Description forthcoming.</em>


        



<section name="typeDescription">
<label id="method**GSXMLNamespace**-typeDescription" />- <code>(NSString*) </code>
          <b>typeDescription </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSSerializer">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSSerializer">NSSerializer</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSSerialization.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="serializePropertyList:">
<label id="method**NSSerializer**+serializePropertyList:" />+ <code>(NSData*) </code>
          <b>serializePropertyList: </b>
          <code>(id) </code><i>propertyList </i>
          <br><em>Description forthcoming.</em>


        



<section name="serializePropertyList:intoData:">
<label id="method**NSSerializer**+serializePropertyList:intoData:" />+ <code>(void) </code>
          <b>serializePropertyList: </b>
          <code>(id) </code><i>propertyList </i>
          <b>intoData: </b>
          <code>(NSMutableData*) </code><i>d </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
      
</section>


</chapter>


<chapter name="GSMimeDocument">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSMimeDocument">GSMimeDocument</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSMime.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="charsetFromEncoding:">
<label id="method**GSMimeDocument**+charsetFromEncoding:" />+ <code>(NSString*) </code>
          <b>charsetFromEncoding: </b>
          <code>(NSStringEncoding) </code><i>enc </i>
          <br><em>Description forthcoming.</em>


        



<section name="decodeBase64:">
<label id="method**GSMimeDocument**+decodeBase64:" />+ <code>(NSData*) </code>
          <b>decodeBase64: </b>
          <code>(NSData*) </code><i>source </i>
          <br><em>Description forthcoming.</em>


        



<section name="decodeBase64String:">
<label id="method**GSMimeDocument**+decodeBase64String:" />+ <code>(NSString*) </code>
          <b>decodeBase64String: </b>
          <code>(NSString*) </code><i>source </i>
          <br><em>Description forthcoming.</em>


        



<section name="documentWithContent:type:name:">
<label id="method**GSMimeDocument**+documentWithContent:type:name:" />+ <code>(GSMimeDocument*) </code>
          <b>documentWithContent: </b>
          <code>(id) </code><i>newContent </i>
          <b>type: </b>
          <code>(NSString*) </code><i>type </i>
          <b>name: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeBase64:">
<label id="method**GSMimeDocument**+encodeBase64:" />+ <code>(NSData*) </code>
          <b>encodeBase64: </b>
          <code>(NSData*) </code><i>source </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeBase64String:">
<label id="method**GSMimeDocument**+encodeBase64String:" />+ <code>(NSString*) </code>
          <b>encodeBase64String: </b>
          <code>(NSString*) </code><i>source </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodingFromCharset:">
<label id="method**GSMimeDocument**+encodingFromCharset:" />+ <code>(NSStringEncoding) </code>
          <b>encodingFromCharset: </b>
          <code>(NSString*) </code><i>charset </i>
          <br><em>Description forthcoming.</em>


        



<section name="addContent:">
<label id="method**GSMimeDocument**-addContent:" />- <code>(void) </code>
          <b>addContent: </b>
          <code>(id) </code><i>newContent </i>
          <br><em>Description forthcoming.</em>


        



<section name="addHeader:">
<label id="method**GSMimeDocument**-addHeader:" />- <code>(void) </code>
          <b>addHeader: </b>
          <code>(GSMimeHeader*) </code><i>info </i>
          <br><em>Description forthcoming.</em>


        



<section name="allHeaders">
<label id="method**GSMimeDocument**-allHeaders" />- <code>(NSArray*) </code>
          <b>allHeaders </b>
          <br><em>Description forthcoming.</em>


        



<section name="content">
<label id="method**GSMimeDocument**-content" />- <code>(id) </code>
          <b>content </b>
          <br><em>Description forthcoming.</em>


        



<section name="contentByID:">
<label id="method**GSMimeDocument**-contentByID:" />- <code>(id) </code>
          <b>contentByID: </b>
          <code>(NSString*) </code><i>key </i>
          <br><em>Description forthcoming.</em>


        



<section name="contentByName:">
<label id="method**GSMimeDocument**-contentByName:" />- <code>(id) </code>
          <b>contentByName: </b>
          <code>(NSString*) </code><i>key </i>
          <br><em>Description forthcoming.</em>


        



<section name="contentFile">
<label id="method**GSMimeDocument**-contentFile" />- <code>(NSString*) </code>
          <b>contentFile </b>
          <br><em>Description forthcoming.</em>


        



<section name="contentID">
<label id="method**GSMimeDocument**-contentID" />- <code>(NSString*) </code>
          <b>contentID </b>
          <br><em>Description forthcoming.</em>


        



<section name="contentName">
<label id="method**GSMimeDocument**-contentName" />- <code>(NSString*) </code>
          <b>contentName </b>
          <br><em>Description forthcoming.</em>


        



<section name="contentSubtype">
<label id="method**GSMimeDocument**-contentSubtype" />- <code>(NSString*) </code>
          <b>contentSubtype </b>
          <br><em>Description forthcoming.</em>


        



<section name="contentType">
<label id="method**GSMimeDocument**-contentType" />- <code>(NSString*) </code>
          <b>contentType </b>
          <br><em>Description forthcoming.</em>


        



<section name="contentsByName:">
<label id="method**GSMimeDocument**-contentsByName:" />- <code>(NSArray*) </code>
          <b>contentsByName: </b>
          <code>(NSString*) </code><i>key </i>
          <br><em>Description forthcoming.</em>


        



<section name="convertToData">
<label id="method**GSMimeDocument**-convertToData" />- <code>(NSData*) </code>
          <b>convertToData </b>
          <br><em>Description forthcoming.</em>


        



<section name="convertToText">
<label id="method**GSMimeDocument**-convertToText" />- <code>(NSString*) </code>
          <b>convertToText </b>
          <br><em>Description forthcoming.</em>


        



<section name="deleteHeader:">
<label id="method**GSMimeDocument**-deleteHeader:" />- <code>(void) </code>
          <b>deleteHeader: </b>
          <code>(GSMimeHeader*) </code><i>aHeader </i>
          <br><em>Description forthcoming.</em>


        



<section name="deleteHeaderNamed:">
<label id="method**GSMimeDocument**-deleteHeaderNamed:" />- <code>(void) </code>
          <b>deleteHeaderNamed: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="headerNamed:">
<label id="method**GSMimeDocument**-headerNamed:" />- <code>(GSMimeHeader*) </code>
          <b>headerNamed: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="headersNamed:">
<label id="method**GSMimeDocument**-headersNamed:" />- <code>(NSArray*) </code>
          <b>headersNamed: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeBoundary">
<label id="method**GSMimeDocument**-makeBoundary" />- <code>(NSString*) </code>
          <b>makeBoundary </b>
          <br><em>Description forthcoming.</em>


        



<section name="makeContentID">
<label id="method**GSMimeDocument**-makeContentID" />- <code>(GSMimeHeader*) </code>
          <b>makeContentID </b>
          <br><em>Description forthcoming.</em>


        



<section name="makeMessageID">
<label id="method**GSMimeDocument**-makeMessageID" />- <code>(GSMimeHeader*) </code>
          <b>makeMessageID </b>
          <br><em>Description forthcoming.</em>


        



<section name="rawMimeData">
<label id="method**GSMimeDocument**-rawMimeData" />- <code>(NSMutableData*) </code>
          <b>rawMimeData </b>
          <br><em>Description forthcoming.</em>


        



<section name="rawMimeData:">
<label id="method**GSMimeDocument**-rawMimeData:" />- <code>(NSMutableData*) </code>
          <b>rawMimeData: </b>
          <code>(BOOL) </code><i>isOuter </i>
          <br><em>Description forthcoming.</em>


        



<section name="setContent:">
<label id="method**GSMimeDocument**-setContent:" />- <code>(void) </code>
          <b>setContent: </b>
          <code>(id) </code><i>newContent </i>
          <br><em>Description forthcoming.</em>


        



<section name="setContent:type:">
<label id="method**GSMimeDocument**-setContent:type:" />- <code>(void) </code>
          <b>setContent: </b>
          <code>(id) </code><i>newContent </i>
          <b>type: </b>
          <code>(NSString*) </code><i>type </i>
          <br><em>Description forthcoming.</em>


        



<section name="setContent:type:name:">
<label id="method**GSMimeDocument**-setContent:type:name:" />- <code>(void) </code>
          <b>setContent: </b>
          <code>(id) </code><i>newContent </i>
          <b>type: </b>
          <code>(NSString*) </code><i>type </i>
          <b>name: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="setHeader:">
<label id="method**GSMimeDocument**-setHeader:" />- <code>(void) </code>
          <b>setHeader: </b>
          <code>(GSMimeHeader*) </code><i>info </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NXConstantString">


<section name="Overview">
<b>Inherits From:  </b><ref id="NXConstantString">NXConstantString</ref>: <ref id="NSString">NSString</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSString.h
</section>

<section name="Description">
<br>The NXConstantString class is used to hold constant
            8-bit character string objects produced by the
            compiler where it sees @"..." in the source. The
            compiler generates the instances of this class -
            which has three instance variables -
          
          In older versions of the compiler, the isa variable is
            always set to the NXConstantString class. In newer
            versions a compiler option was added for GNUstep,
            to permit the isa variable to be set to another class,
            and GNUstep uses this to avoid conflicts with the
            default implementation of NXConstantString in the
            ObjC runtime library (the preprocessor is used to
            change all occurances of NXConstantString in the
            source code to NSConstantString).
          Since GNUstep will generally use the GNUstep
            extension to the compiler, you should never refer
            to the constnat string class by name, but should use the
            <ref id="method**NSString**+constantStringClass">[NSString% unknown entity: nbsp
+constantStringClass]</ref> method to get the actual class being used for constant strings.
          What follows is a dummy declaration of the class to keep
          the compiler happy.


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSEnumerator">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSEnumerator">NSEnumerator</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSEnumerator.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="allObjects">
<label id="method**NSEnumerator**-allObjects" />- <code>(NSArray*) </code>
          <b>allObjects </b>
          <br><em>Description forthcoming.</em>


        



<section name="nextObject">
<label id="method**NSEnumerator**-nextObject" />- <code>(id) </code>
          <b>nextObject </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
      
</section>


</chapter>


<chapter name="GSMimeHeader">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSMimeHeader">GSMimeHeader</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSMime.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="makeQuoted:always:">
<label id="method**GSMimeHeader**+makeQuoted:always:" />+ <code>(NSString*) </code>
          <b>makeQuoted: </b>
          <code>(NSString*) </code><i>v </i>
          <b>always: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeToken:">
<label id="method**GSMimeHeader**+makeToken:" />+ <code>(NSString*) </code>
          <b>makeToken: </b>
          <code>(NSString*) </code><i>t </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithName:value:">
<label id="method**GSMimeHeader**-initWithName:value:" />- <code>(id) </code>
          <b>initWithName: </b>
          <code>(NSString*) </code><i>n </i>
          <b>value: </b>
          <code>(NSString*) </code><i>v </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithName:value:parameters:">
<label id="method**GSMimeHeader**-initWithName:value:parameters:" />- <code>(id) </code>
          <b>initWithName: </b>
          <code>(NSString*) </code><i>n </i>
          <b>value: </b>
          <code>(NSString*) </code><i>v </i>
          <b>parameters: </b>
          <code>(NSDictionary*) </code><i>p </i>
          <br><em>Description forthcoming.</em>


        



<section name="name">
<label id="method**GSMimeHeader**-name" />- <code>(NSString*) </code>
          <b>name </b>
          <br><em>Description forthcoming.</em>


        



<section name="objectForKey:">
<label id="method**GSMimeHeader**-objectForKey:" />- <code>(id) </code>
          <b>objectForKey: </b>
          <code>(NSString*) </code><i>k </i>
          <br><em>Description forthcoming.</em>


        



<section name="objects">
<label id="method**GSMimeHeader**-objects" />- <code>(NSDictionary*) </code>
          <b>objects </b>
          <br><em>Description forthcoming.</em>


        



<section name="parameterForKey:">
<label id="method**GSMimeHeader**-parameterForKey:" />- <code>(NSString*) </code>
          <b>parameterForKey: </b>
          <code>(NSString*) </code><i>k </i>
          <br><em>Description forthcoming.</em>


        



<section name="parameters">
<label id="method**GSMimeHeader**-parameters" />- <code>(NSDictionary*) </code>
          <b>parameters </b>
          <br><em>Description forthcoming.</em>


        



<section name="rawMimeData">
<label id="method**GSMimeHeader**-rawMimeData" />- <code>(NSMutableData*) </code>
          <b>rawMimeData </b>
          <br><em>Description forthcoming.</em>


        



<section name="setName:">
<label id="method**GSMimeHeader**-setName:" />- <code>(void) </code>
          <b>setName: </b>
          <code>(NSString*) </code><i>s </i>
          <br><em>Description forthcoming.</em>


        



<section name="setObject:forKey:">
<label id="method**GSMimeHeader**-setObject:forKey:" />- <code>(void) </code>
          <b>setObject: </b>
          <code>(id) </code><i>o </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>k </i>
          <br><em>Description forthcoming.</em>


        



<section name="setParameter:forKey:">
<label id="method**GSMimeHeader**-setParameter:forKey:" />- <code>(void) </code>
          <b>setParameter: </b>
          <code>(NSString*) </code><i>v </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>k </i>
          <br><em>Description forthcoming.</em>


        



<section name="setParameters:">
<label id="method**GSMimeHeader**-setParameters:" />- <code>(void) </code>
          <b>setParameters: </b>
          <code>(NSDictionary*) </code><i>d </i>
          <br><em>Description forthcoming.</em>


        



<section name="setValue:">
<label id="method**GSMimeHeader**-setValue:" />- <code>(void) </code>
          <b>setValue: </b>
          <code>(NSString*) </code><i>s </i>
          <br><em>Description forthcoming.</em>


        



<section name="text">
<label id="method**GSMimeHeader**-text" />- <code>(NSString*) </code>
          <b>text </b>
          <br><em>Description forthcoming.</em>


        



<section name="value">
<label id="method**GSMimeHeader**-value" />- <code>(NSString*) </code>
          <b>value </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GSXPathNodeSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXPathNodeSet">GSXPathNodeSet</ref>: <ref id="GSXPathObject">GSXPathObject</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br>For XPath queries returning a node set.


</section>

<section name="Methods">


<section name="count">
<label id="method**GSXPathNodeSet**-count" />- <code>(unsigned int) </code>
          <b>count </b>
          <br><em>Description forthcoming.</em>


        



<section name="length">
<label id="method**GSXPathNodeSet**-length" />- <code>(unsigned int) </code>
          <b>length </b>
          <br><em>Description forthcoming.</em>


        



<section name="nodeAtIndex:">
<label id="method**GSXPathNodeSet**-nodeAtIndex:" />- <code>(GSXMLNode*) </code>
          <b>nodeAtIndex: </b>
          <code>(unsigned) </code><i>index </i>
          <br>Please note that <i>index</i> starts from 0.


        


        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSUnarchiver">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSUnarchiver">NSUnarchiver</ref>: <ref id="NSCoder">NSCoder</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSArchiver.h
</section>

<section name="Description">
<br>This class reconstructs objects from an archive. 
<br>

          <b>Re-using the archiver</b> 
<br>

          The
            <ref id="method**NSUnarchiver**-resetUnarchiverWithData:atIndex:">
              -resetUnarchiverWithData:atIndex:
            </ref>
            method lets you re-use the archive to decode a new
            data object or, in conjunction with the 'cursor'
            method (which reports the current decoding position
            in the archive), decode a second archive that exists in
            the data object after the first one.
          <b>Subclassing with different input format.</b>
          
<br>
 NSUnarchiver normally reads directly from an
          NSData object using the methods -
          
          And uses other NSData methods to read the archive
            header information from within the method:
            <ref id="method**NSUnarchiver**-deserializeHeaderAt:version:classes:objects:pointers:">[-deserializeHeaderAt:version:classes:objects:pointers:]</ref> to read a fixed size header including archiver version (obtained by [self systemVersion]) and crossreference table sizes.
          To subclass NSUnarchiver, you must implement your own
            versions of the four methods above, and override
            the 'directDataAccess' method to return <code>NO</code>
            so that the archiver knows to use your serialization
            methods rather than those in the NSData object.


</section>

<section name="Methods">


<section name="classNameDecodedForArchiveClassName:">
<label id="method**NSUnarchiver**+classNameDecodedForArchiveClassName:" />+ <code>(NSString*) </code>
          <b>classNameDecodedForArchiveClassName: </b>
          <code>(NSString*) </code><i>nameInArchive </i>
          <br><em>Description forthcoming.</em>


        



<section name="decodeClassName:asClassName:">
<label id="method**NSUnarchiver**+decodeClassName:asClassName:" />+ <code>(void) </code>
          <b>decodeClassName: </b>
          <code>(NSString*) </code><i>nameInArchive </i>
          <b>asClassName: </b>
          <code>(NSString*) </code><i>trueName </i>
          <br><em>Description forthcoming.</em>


        



<section name="unarchiveObjectWithData:">
<label id="method**NSUnarchiver**+unarchiveObjectWithData:" />+ <code>(id) </code>
          <b>unarchiveObjectWithData: </b>
          <code>(NSData*) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="unarchiveObjectWithFile:">
<label id="method**NSUnarchiver**+unarchiveObjectWithFile:" />+ <code>(id) </code>
          <b>unarchiveObjectWithFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="classNameDecodedForArchiveClassName:">
<label id="method**NSUnarchiver**-classNameDecodedForArchiveClassName:" />- <code>(NSString*) </code>
          <b>classNameDecodedForArchiveClassName: </b>
          <code>(NSString*) </code><i>nameInArchive </i>
          <br><em>Description forthcoming.</em>


        



<section name="decodeClassName:asClassName:">
<label id="method**NSUnarchiver**-decodeClassName:asClassName:" />- <code>(void) </code>
          <b>decodeClassName: </b>
          <code>(NSString*) </code><i>nameInArchive </i>
          <b>asClassName: </b>
          <code>(NSString*) </code><i>trueName </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForReadingWithData:">
<label id="method**NSUnarchiver**-initForReadingWithData:" />- <code>(id) </code>
          <b>initForReadingWithData: </b>
          <code>(NSData*) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="isAtEnd">
<label id="method**NSUnarchiver**-isAtEnd" />- <code>(BOOL) </code>
          <b>isAtEnd </b>
          <br><em>Description forthcoming.</em>


        



<section name="objectZone">
<label id="method**NSUnarchiver**-objectZone" />- <code>(NSZone*) </code>
          <b>objectZone </b>
          <br><em>Description forthcoming.</em>


        



<section name="replaceObject:withObject:">
<label id="method**NSUnarchiver**-replaceObject:withObject:" />- <code>(void) </code>
          <b>replaceObject: </b>
          <code>(id) </code><i>anObject </i>
          <b>withObject: </b>
          <code>(id) </code><i>replacement </i>
          <br><em>Description forthcoming.</em>


        



<section name="setObjectZone:">
<label id="method**NSUnarchiver**-setObjectZone:" />- <code>(void) </code>
          <b>setObjectZone: </b>
          <code>(NSZone*) </code><i>aZone </i>
          <br><em>Description forthcoming.</em>


        



<section name="systemVersion">
<label id="method**NSUnarchiver**-systemVersion" />- <code>(unsigned int) </code>
          <b>systemVersion </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSDeserializer">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDeserializer">NSDeserializer</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSSerialization.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="deserializePropertyListFromData:atCursor:mutableContainers:">
<label id="method**NSDeserializer**+deserializePropertyListFromData:atCursor:mutableContainers:" />+ <code>(id) </code>
          <b>deserializePropertyListFromData: </b>
          <code>(NSData*) </code><i>data </i>
          <b>atCursor: </b>
          <code>(unsigned int*) </code><i>cursor </i>
          <b>mutableContainers: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializePropertyListFromData:mutableContainers:">
<label id="method**NSDeserializer**+deserializePropertyListFromData:mutableContainers:" />+ <code>(id) </code>
          <b>deserializePropertyListFromData: </b>
          <code>(NSData*) </code><i>data </i>
          <b>mutableContainers: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="deserializePropertyListLazilyFromData:atCursor:length:mutableContainers:">
<label id="method**NSDeserializer**+deserializePropertyListLazilyFromData:atCursor:length:mutableContainers:" />+ <code>(id) </code>
          <b>deserializePropertyListLazilyFromData: </b>
          <code>(NSData*) </code><i>data </i>
          <b>atCursor: </b>
          <code>(unsigned*) </code><i>cursor </i>
          <b>length: </b>
          <code>(unsigned) </code><i>length </i>
          <b>mutableContainers: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSTimer">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSTimer">NSTimer</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSTimer.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="scheduledTimerWithTimeInterval:invocation:repeats:">
<label id="method**NSTimer**+scheduledTimerWithTimeInterval:invocation:repeats:" />+ <code>(NSTimer*) </code>
          <b>scheduledTimerWithTimeInterval: </b>
          <code>(NSTimeInterval) </code><i>ti </i>
          <b>invocation: </b>
          <code>(NSInvocation*) </code><i>invocation </i>
          <b>repeats: </b>
          <code>(BOOL) </code><i>f </i>
          <br>Create a timer which will fire after <i>ti</i>
            seconds and, if <i>f</i> is <code>YES</code>,
            every <i>ti</i> seconds thereafter. On firing,
            <i>invocation</i> will be performed. 
<br>
 This
            timer will automatically be added to the current run
            loop and will fire in the default run loop mode.


        



<section name="scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:">
<label id="method**NSTimer**+scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:" />+ <code>(NSTimer*) </code>
          <b>scheduledTimerWithTimeInterval: </b>
          <code>(NSTimeInterval) </code><i>ti </i>
          <b>target: </b>
          <code>(id) </code><i>object </i>
          <b>selector: </b>
          <code>(SEL) </code><i>selector </i>
          <b>userInfo: </b>
          <code>(id) </code><i>info </i>
          <b>repeats: </b>
          <code>(BOOL) </code><i>f </i>
          <br>Create a timer which will fire after <i>ti</i>
            seconds and, if <i>f</i> is <code>YES</code>,
            every <i>ti</i> seconds thereafter. On firing,
            the target <i>object</i> will be sent a message
            specified by <i>selector</i> and with the
            <i>object</i> <i>info</i> as an argument.
            
<br>
 This timer will automatically be added to the
            current run loop and will fire in the default run
            loop mode.


        



<section name="timerWithTimeInterval:invocation:repeats:">
<label id="method**NSTimer**+timerWithTimeInterval:invocation:repeats:" />+ <code>(NSTimer*) </code>
          <b>timerWithTimeInterval: </b>
          <code>(NSTimeInterval) </code><i>ti </i>
          <b>invocation: </b>
          <code>(NSInvocation*) </code><i>invocation </i>
          <b>repeats: </b>
          <code>(BOOL) </code><i>f </i>
          <br>Create a timer wchich will fire after <i>ti</i>
            seconds and, if <i>f</i> is <code>YES</code>,
            every <i>ti</i> seconds thereafter. On firing,
            <i>invocation</i> will be performed. 
<br>
 NB.
            To make the timer operate, you must add it to a run
            loop.


        



<section name="timerWithTimeInterval:target:selector:userInfo:repeats:">
<label id="method**NSTimer**+timerWithTimeInterval:target:selector:userInfo:repeats:" />+ <code>(NSTimer*) </code>
          <b>timerWithTimeInterval: </b>
          <code>(NSTimeInterval) </code><i>ti </i>
          <b>target: </b>
          <code>(id) </code><i>object </i>
          <b>selector: </b>
          <code>(SEL) </code><i>selector </i>
          <b>userInfo: </b>
          <code>(id) </code><i>info </i>
          <b>repeats: </b>
          <code>(BOOL) </code><i>f </i>
          <br>Create a timer wchich will fire after <i>ti</i>
            seconds and, if <i>f</i> is <code>YES</code>,
            every <i>ti</i> seconds thereafter. On firing,
            the target <i>object</i> will be sent a message
            specified by <i>selector</i> and with the
            <i>object</i> <i>info</i> as an argument.
            
<br>
 NB. To make the timer operate, you must add
            it to a run loop.


        



<section name="fire">
<label id="method**NSTimer**-fire" />- <code>(void) </code>
          <b>fire </b>
          <br>Fires the timer... either performs an invocation or
            ssends a message to a target object, depending on
            how the timer was set up. 
<br>
 If the timer is not
            set to repeat, it is automatically invalidated.


        



<section name="fireDate">
<label id="method**NSTimer**-fireDate" />- <code>(NSDate*) </code>
          <b>fireDate </b>
          <br>Returns the date/time at which the timer is next
            due to fire.


        



<section name="initWithFireDate:interval:target:selector:userInfo:repeats:">
<label id="method**NSTimer**-initWithFireDate:interval:target:selector:userInfo:repeats:" />- <code>(id) </code>
          <b>initWithFireDate: </b>
          <code>(NSDate*) </code><i>fd </i>
          <b>interval: </b>
          <code>(NSTimeInterval) </code><i>ti </i>
          <b>target: </b>
          <code>(id) </code><i>object </i>
          <b>selector: </b>
          <code>(SEL) </code><i>selector </i>
          <b>userInfo: </b>
          <code>(id) </code><i>info </i>
          <b>repeats: </b>
          <code>(BOOL) </code><i>f </i>
          <br>Initialise the receive, a newly allocated
            NSTimer <i>object</i>. 
<br>
 The <i>fd</i>
            argument specifies an initial fire date... if it
            is not supplied (a <code>nil</code> <i>object</i>)
            then the <i>ti</i> argument is used to create a
            start date relative to the current time. 
<br>
 The
            <i>ti</i> argument specifies the time (in
            seconds) between the firing. If it is less than or
            equal to 0.0 then a small interval is chosen
            automatically. 
<br>
 The <i>f</i>
            argument specifies whether the timer will fire
            repeatedly or just once. 
<br>
 If the
            <i>selector</i> argument is zero, then then
            <i>object</i> is an invocation to be used when
            the timer fires. otherwise, the <i>object</i> is
            sent the message specified by the <i>selector</i>
            and with the timer as an argument. 
<br>
 The
            <i>fd</i>, <i>object</i> and <i>info</i>
            arguments will be retained until the timer is
            invalidated. 
<br>


        



<section name="invalidate">
<label id="method**NSTimer**-invalidate" />- <code>(void) </code>
          <b>invalidate </b>
          <br>Marks the timer as invalid, causing its
            target/invocation and user info objects
            to be released. 
<br>
 Invalidated timers are
            automatically removed from the run loop when
            it detects them.


        



<section name="isValid">
<label id="method**NSTimer**-isValid" />- <code>(BOOL) </code>
          <b>isValid </b>
          <br>Checks to see if the timer has been invalidated.


        



<section name="setFireDate:">
<label id="method**NSTimer**-setFireDate:" />- <code>(void) </code>
          <b>setFireDate: </b>
          <code>(NSDate*) </code><i>fireDate </i>
          <br>Change the fire date for the receiver. 
<br>
 NB.
            You should <em>NOT</em> use this method for a timer
            which has been added to a run loop. The only time
            when it is safe to modify the fire date of a timer in
            a run loop is for a repeating timer when the timer is
            actually in the process of firing.


        



<section name="timeInterval">
<label id="method**NSTimer**-timeInterval" />- <code>(NSTimeInterval) </code>
          <b>timeInterval </b>
          <br>Returns the interval beteen firings.


        



<section name="userInfo">
<label id="method**NSTimer**-userInfo" />- <code>(id) </code>
          <b>userInfo </b>
          <br>Returns the user info which was set for the timer
            when it was created, or <code>nil</code> if none was
            set or the timer is invalid.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GSFFCallInvocation">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSFFCallInvocation">GSFFCallInvocation</ref>: <ref id="NSInvocation">NSInvocation</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSInvocation.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSFloatNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSFloatNumber">NSFloatNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSDistributedLock">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDistributedLock">NSDistributedLock</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSDistributedLock.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="lockWithPath:">
<label id="method**NSDistributedLock**+lockWithPath:" />+ <code>(NSDistributedLock*) </code>
          <b>lockWithPath: </b>
          <code>(NSString*) </code><i>aPath </i>
          <br>Return a distributed lock for <i>aPath</i>. See
            <ref id="method**NSDistributedLock**-initWithPath:">
              -initWithPath:
            </ref>
            for details.


        



<section name="breakLock">
<label id="method**NSDistributedLock**-breakLock" />- <code>(void) </code>
          <b>breakLock </b>
          <br>Forces release of the lock whether the receiver owns
            it or not. 
<br>
 Raises an NSGenericException if unable
            to remove the lock.


        



<section name="initWithPath:">
<label id="method**NSDistributedLock**-initWithPath:" />- <code>(NSDistributedLock*) </code>
          <b>initWithPath: </b>
          <code>(NSString*) </code><i>aPath </i>
          <br>Initialises the reciever with the specified
            filesystem path. 
<br>
 The location in the
            filesystem must be accessible for this to be
            usable. That is, the processes using the lock must
            be able to access, create, and destroy files at the
            path. 
<br>
 The directory in which the last path
            component resides must already exist... create it
            using NSFileManager if you need to.


        



<section name="lockDate">
<label id="method**NSDistributedLock**-lockDate" />- <code>(NSDate*) </code>
          <b>lockDate </b>
          <br>Returns the date at which the lock was aquired by
            any NSDistributedLock using the same path. If nothing
            has the lock, this returns <code>nil</code>.


        



<section name="tryLock">
<label id="method**NSDistributedLock**-tryLock" />- <code>(BOOL) </code>
          <b>tryLock </b>
          <br>Attempt to aquire the lock and return
            <code>YES</code> on success, <code>NO</code> on
            failure. 
<br>
 May raise an NSGenericException if
            a problem occurs.


        



<section name="unlock">
<label id="method**NSDistributedLock**-unlock" />- <code>(void) </code>
          <b>unlock </b>
          <br>Releases the lock. Raises an NSGenericException if
            unable to release the lock (for instance if the
            receiver does not own it or another process has
            broken it).


        


        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSDictionary">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDictionary">NSDictionary</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSMutableCopying
<br><b>Declared in: </b>NSDictionary.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="dictionary">
<label id="method**NSDictionary**+dictionary" />+ <code>(id) </code>
          <b>dictionary </b>
          <br><em>Description forthcoming.</em>


        



<section name="dictionaryWithContentsOfFile:">
<label id="method**NSDictionary**+dictionaryWithContentsOfFile:" />+ <code>(id) </code>
          <b>dictionaryWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns a dictionary using the file located at
            <i>path</i>. The file must be a property list
            containing a dictionary as its root object.


        



<section name="dictionaryWithDictionary:">
<label id="method**NSDictionary**+dictionaryWithDictionary:" />+ <code>(id) </code>
          <b>dictionaryWithDictionary: </b>
          <code>(NSDictionary*) </code><i>otherDictionary </i>
          <br>Returns a newly created dictionary with the keys
            and objects of <i>otherDictionary</i>. (The keys
            and objects are not copied.)


        



<section name="dictionaryWithObject:forKey:">
<label id="method**NSDictionary**+dictionaryWithObject:forKey:" />+ <code>(id) </code>
          <b>dictionaryWithObject: </b>
          <code>(id) </code><i>object </i>
          <b>forKey: </b>
          <code>(id) </code><i>key </i>
          <br>Returns a dictionary containing only one
            <i>object</i> which is associated with a
            <i>key</i>.


        



<section name="dictionaryWithObjects:forKeys:">
<label id="method**NSDictionary**+dictionaryWithObjects:forKeys:" />+ <code>(id) </code>
          <b>dictionaryWithObjects: </b>
          <code>(NSArray*) </code><i>objects </i>
          <b>forKeys: </b>
          <code>(NSArray*) </code><i>keys </i>
          <br><em>Description forthcoming.</em>


        



<section name="dictionaryWithObjects:forKeys:count:">
<label id="method**NSDictionary**+dictionaryWithObjects:forKeys:count:" />+ <code>(id) </code>
          <b>dictionaryWithObjects: </b>
          <code>(id*) </code><i>objects </i>
          <b>forKeys: </b>
          <code>(id*) </code><i>keys </i>
          <b>count: </b>
          <code>(unsigned) </code><i>count </i>
          <br>Returns a dictionary created using the given
            <i>objects</i> and <i>keys</i>. The two
            arrays must have the same size. The n th element of
            the <i>objects</i> array is associated with the n
            th element of the <i>keys</i> array.


        



<section name="dictionaryWithObjectsAndKeys:">
<label id="method**NSDictionary**+dictionaryWithObjectsAndKeys:" />+ <code>(id) </code>
          <b>dictionaryWithObjectsAndKeys: </b>
          <code>(id) </code><i>firstObject </i>
          
          <br>Returns a dictionary created using the list given
            as argument. The list is alernately composed of objects
            and keys. Thus, the list's length must be pair.


        



<section name="allKeys">
<label id="method**NSDictionary**-allKeys" />- <code>(NSArray*) </code>
          <b>allKeys </b>
          <br>Returns an array containing all the dictionary's
            keys.


        



<section name="allKeysForObject:">
<label id="method**NSDictionary**-allKeysForObject:" />- <code>(NSArray*) </code>
          <b>allKeysForObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Returns an array containing all the dictionary's
            keys that are associated with <i>anObject</i>.


        



<section name="allValues">
<label id="method**NSDictionary**-allValues" />- <code>(NSArray*) </code>
          <b>allValues </b>
          <br>Returns an array containing all the dictionary's
            objects.


        



<section name="count">
<label id="method**NSDictionary**-count" />- <code>(unsigned) </code>
          <b>count </b>
          <br>Returns an unsigned integer which is the number of
            elements stored in the dictionary.


        



<section name="description">
<label id="method**NSDictionary**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br>Returns the result of invoking
            <ref id="method**NSDictionary**-descriptionWithLocale:indent:">
              -descriptionWithLocale:indent:
            </ref>
            with a <code>nil</code> locale and zero indent.


        



<section name="descriptionInStringsFileFormat">
<label id="method**NSDictionary**-descriptionInStringsFileFormat" />- <code>(NSString*) </code>
          <b>descriptionInStringsFileFormat </b>
          <br>Returns the receiver as a text property list
            strings file format. 
<br>
 See
            <ref id="method**NSString**-propertyListFromStringsFileFormat">[NSString% unknown entity: nbsp
-propertyListFromStringsFileFormat]</ref> for details. 
<br>
 The order of the items is undefined.


        



<section name="descriptionWithLocale:">
<label id="method**NSDictionary**-descriptionWithLocale:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br>Returns the result of invoking
            <ref id="method**NSDictionary**-descriptionWithLocale:indent:">
              -descriptionWithLocale:indent:
            </ref>
            with a zero indent.


        



<section name="descriptionWithLocale:indent:">
<label id="method**NSDictionary**-descriptionWithLocale:indent:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <b>indent: </b>
          <code>(unsigned int) </code><i>level </i>
          <br>Returns the receiver as a text property list in the
            traditional format. 
<br>
 See
            <ref id="method**NSString**-propertyList">
              [NSString% unknown entity: nbsp
-propertyList]
            </ref>
            for details. 
<br>
 If <i>locale</i> is
            <code>nil</code>, no formatting is done, otherwise
            entries are formatted according to the
            <i>locale</i>, and indented according to
            <i>level</i>. 
<br>
 Unless <i>locale</i> is
            <code>nil</code>, a <i>level</i> of zero indents
            items by four spaces, while a <i>level</i> of one
            indents them by a tab. 
<br>
 If the keys in the
            dictionary respond to
            <ref id="method**NSDictionary**-compare:">
              -compare:
            </ref>
            , the items are listed by key in ascending order. If not,
            the order in which the items are listed is undefined.


        



<section name="initWithContentsOfFile:">
<label id="method**NSDictionary**-initWithContentsOfFile:" />- <code>(id) </code>
          <b>initWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Initialises the dictionary with the contents
              of the specified file, which must contain a dictionary
              in property-list format.
            In GNUstep, the property-list format may be either the
              OpenStep format (ASCII data), or the MacOS-X
              format (URF8 XML data)... this method will
              recognise which it is.
            If there is a failure to load the file for any reason,
              the receiver will be released and the method will
              return <code>nil</code>.
            Works by invoking
              <ref id="method**NSString**-initWithContentsOfFile:">[NSString% unknown entity: nbsp
-initWithContentsOfFile:]</ref> and <ref id="method**NSString**-propertyList">[NSString% unknown entity: nbsp
-propertyList]</ref> then checking that the result is a dictionary.


        



<section name="initWithDictionary:">
<label id="method**NSDictionary**-initWithDictionary:" />- <code>(id) </code>
          <b>initWithDictionary: </b>
          <code>(NSDictionary*) </code><i>otherDictionary </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithDictionary:copyItems:">
<label id="method**NSDictionary**-initWithDictionary:copyItems:" />- <code>(id) </code>
          <b>initWithDictionary: </b>
          <code>(NSDictionary*) </code><i>other </i>
          <b>copyItems: </b>
          <code>(BOOL) </code><i>shouldCopy </i>
          <br>Initialise dictionary with the keys and values
            of otherDictionary. If the <i>shouldCopy</i> flag is
            <code>YES</code> then the values are copied into the
            newly initialised dictionary, otherwise they are
            simply retained.


        



<section name="initWithObjects:forKeys:">
<label id="method**NSDictionary**-initWithObjects:forKeys:" />- <code>(id) </code>
          <b>initWithObjects: </b>
          <code>(NSArray*) </code><i>objects </i>
          <b>forKeys: </b>
          <code>(NSArray*) </code><i>keys </i>
          <br>Initialises a dictionary created using the
            given <i>objects</i> and <i>keys</i>. The two
            arrays must have the same size. The n th element of
            the <i>objects</i> array is associated with the n
            th element of the <i>keys</i> array.


        



<section name="initWithObjects:forKeys:count:">
<label id="method**NSDictionary**-initWithObjects:forKeys:count:" />- <code>(id) </code>
          <b>initWithObjects: </b>
          <code>(id*) </code><i>objects </i>
          <b>forKeys: </b>
          <code>(id*) </code><i>keys </i>
          <b>count: </b>
          <code>(unsigned) </code><i>count </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithObjectsAndKeys:">
<label id="method**NSDictionary**-initWithObjectsAndKeys:" />- <code>(id) </code>
          <b>initWithObjectsAndKeys: </b>
          <code>(id) </code><i>firstObject </i>
          
          <br>Initialises a dictionary created using the list
            given as argument. The list is alernately composed of
            objects and keys. Thus, the list's length must be
            pair.


        



<section name="isEqualToDictionary:">
<label id="method**NSDictionary**-isEqualToDictionary:" />- <code>(BOOL) </code>
          <b>isEqualToDictionary: </b>
          <code>(NSDictionary*) </code><i>other </i>
          <br><em>Description forthcoming.</em>


        



<section name="keyEnumerator">
<label id="method**NSDictionary**-keyEnumerator" />- <code>(NSEnumerator*) </code>
          <b>keyEnumerator </b>
          <br>Return an enumerator object containing all the keys
            of the dictionary.


        



<section name="keysSortedByValueUsingSelector:">
<label id="method**NSDictionary**-keysSortedByValueUsingSelector:" />- <code>(NSArray*) </code>
          <b>keysSortedByValueUsingSelector: </b>
          <code>(SEL) </code><i>comp </i>
          <br><em>Description forthcoming.</em>


        



<section name="objectEnumerator">
<label id="method**NSDictionary**-objectEnumerator" />- <code>(NSEnumerator*) </code>
          <b>objectEnumerator </b>
          <br>Return an enumerator object containing all the
            objects of the dictionary.


        



<section name="objectForKey:">
<label id="method**NSDictionary**-objectForKey:" />- <code>(id) </code>
          <b>objectForKey: </b>
          <code>(id) </code><i>aKey </i>
          <br>Returns the object in the dictionary corresponding
            to <i>aKey</i>, or <code>nil</code> if the key is
            not present.


        



<section name="objectsForKeys:notFoundMarker:">
<label id="method**NSDictionary**-objectsForKeys:notFoundMarker:" />- <code>(NSArray*) </code>
          <b>objectsForKeys: </b>
          <code>(NSArray*) </code><i>keys </i>
          <b>notFoundMarker: </b>
          <code>(id) </code><i>marker </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueForKey:">
<label id="method**NSDictionary**-valueForKey:" />- <code>(id) </code>
          <b>valueForKey: </b>
          <code>(NSString*) </code><i>key </i>
          <br>Default implementation for this class is to return
            the value stored in the dictionary under the specified
            <i>key</i>, or <code>nil</code> if there is no
            value.


        



<section name="writeToFile:atomically:">
<label id="method**NSDictionary**-writeToFile:atomically:" />- <code>(BOOL) </code>
          <b>writeToFile: </b>
          <code>(NSString*) </code><i>path </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxiliaryFile </i>
          <br>Writes the contents of the dictionary to the file
              specified by <i>path</i>. The file contents
              will be in property-list format... under GNUstep
              this is either OpenStep style (ASCII characters
              using \U hexadecimal escape sequences for unicode),
              or MacOS-X style (XML in the UTF8 character set).
            If the <i>useAuxiliaryFile</i> flag is
              <code>YES</code>, the file write operation is
              atomic... the data is written to a temporary file,
              which is then renamed to the actual file name.
            If the conversion of data into the correct
              property-list format fails or the write
              operation fails, the method returns
              <code>NO</code>, otherwise it returns
              <code>YES</code>.
            NB. The fact that the file is in property-list format
              does not necessarily mean that it can be used to
              reconstruct the dictionary using the
              <ref id="method**NSDictionary**-initWithContentsOfFile:">
                -initWithContentsOfFile:
              </ref>
              method. If the original dictionary contains
              non-property-list objects, the
              descriptions of those objects will have been
              written, and reading in the file as a
              property-list will result in a new
              dictionary containing the string descriptions.


        



<section name="writeToURL:atomically:">
<label id="method**NSDictionary**-writeToURL:atomically:" />- <code>(BOOL) </code>
          <b>writeToURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxiliaryFile </i>
          <br>Writes the contents of the dictionary to the
              specified <i>url</i>. This functions just
              like
              <ref id="method**NSDictionary**-writeToFile:atomically:">
                -writeToFile:atomically:
              </ref>
              except that the output may be written to any URL,
              not just a local file.


        


</section>


</chapter>


<chapter name="NSMutableAttributedString">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableAttributedString">NSMutableAttributedString</ref>: <ref id="NSAttributedString">NSAttributedString</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSAttributedString.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="addAttribute:value:range:">
<label id="method**NSMutableAttributedString**-addAttribute:value:range:" />- <code>(void) </code>
          <b>addAttribute: </b>
          <code>(NSString*) </code><i>name </i>
          <b>value: </b>
          <code>(id) </code><i>value </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="addAttributes:range:">
<label id="method**NSMutableAttributedString**-addAttributes:range:" />- <code>(void) </code>
          <b>addAttributes: </b>
          <code>(NSDictionary*) </code><i>attributes </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="appendAttributedString:">
<label id="method**NSMutableAttributedString**-appendAttributedString:" />- <code>(void) </code>
          <b>appendAttributedString: </b>
          <code>(NSAttributedString*) </code><i>attributedString </i>
          <br><em>Description forthcoming.</em>


        



<section name="beginEditing">
<label id="method**NSMutableAttributedString**-beginEditing" />- <code>(void) </code>
          <b>beginEditing </b>
          <br><em>Description forthcoming.</em>


        



<section name="deleteCharactersInRange:">
<label id="method**NSMutableAttributedString**-deleteCharactersInRange:" />- <code>(void) </code>
          <b>deleteCharactersInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="endEditing">
<label id="method**NSMutableAttributedString**-endEditing" />- <code>(void) </code>
          <b>endEditing </b>
          <br><em>Description forthcoming.</em>


        



<section name="insertAttributedString:atIndex:">
<label id="method**NSMutableAttributedString**-insertAttributedString:atIndex:" />- <code>(void) </code>
          <b>insertAttributedString: </b>
          <code>(NSAttributedString*) </code><i>attributedString </i>
          <b>atIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="mutableString">
<label id="method**NSMutableAttributedString**-mutableString" />- <code>(NSMutableString*) </code>
          <b>mutableString </b>
          <br><em>Description forthcoming.</em>


        



<section name="removeAttribute:range:">
<label id="method**NSMutableAttributedString**-removeAttribute:range:" />- <code>(void) </code>
          <b>removeAttribute: </b>
          <code>(NSString*) </code><i>name </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="replaceCharactersInRange:withAttributedString:">
<label id="method**NSMutableAttributedString**-replaceCharactersInRange:withAttributedString:" />- <code>(void) </code>
          <b>replaceCharactersInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>withAttributedString: </b>
          <code>(NSAttributedString*) </code><i>attributedString </i>
          <br><em>Description forthcoming.</em>


        



<section name="replaceCharactersInRange:withString:">
<label id="method**NSMutableAttributedString**-replaceCharactersInRange:withString:" />- <code>(void) </code>
          <b>replaceCharactersInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>withString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAttributedString:">
<label id="method**NSMutableAttributedString**-setAttributedString:" />- <code>(void) </code>
          <b>setAttributedString: </b>
          <code>(NSAttributedString*) </code><i>attributedString </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAttributes:range:">
<label id="method**NSMutableAttributedString**-setAttributes:range:" />- <code>(void) </code>
          <b>setAttributes: </b>
          <code>(NSDictionary*) </code><i>attributes </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSNumberFormatter">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSNumberFormatter">NSNumberFormatter</ref>: <ref id="NSFormatter">NSFormatter</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSNumberFormatter.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="allowsFloats">
<label id="method**NSNumberFormatter**-allowsFloats" />- <code>(BOOL) </code>
          <b>allowsFloats </b>
          <br><em>Description forthcoming.</em>


        



<section name="attributedStringForNil">
<label id="method**NSNumberFormatter**-attributedStringForNil" />- <code>(NSAttributedString*) </code>
          <b>attributedStringForNil </b>
          <br><em>Description forthcoming.</em>


        



<section name="attributedStringForNotANumber">
<label id="method**NSNumberFormatter**-attributedStringForNotANumber" />- <code>(NSAttributedString*) </code>
          <b>attributedStringForNotANumber </b>
          <br><em>Description forthcoming.</em>


        



<section name="attributedStringForZero">
<label id="method**NSNumberFormatter**-attributedStringForZero" />- <code>(NSAttributedString*) </code>
          <b>attributedStringForZero </b>
          <br><em>Description forthcoming.</em>


        



<section name="decimalSeparator">
<label id="method**NSNumberFormatter**-decimalSeparator" />- <code>(NSString*) </code>
          <b>decimalSeparator </b>
          <br><em>Description forthcoming.</em>


        



<section name="format">
<label id="method**NSNumberFormatter**-format" />- <code>(NSString*) </code>
          <b>format </b>
          <br><em>Description forthcoming.</em>


        



<section name="hasThousandSeparators">
<label id="method**NSNumberFormatter**-hasThousandSeparators" />- <code>(BOOL) </code>
          <b>hasThousandSeparators </b>
          <br><em>Description forthcoming.</em>


        



<section name="localizesFormat">
<label id="method**NSNumberFormatter**-localizesFormat" />- <code>(BOOL) </code>
          <b>localizesFormat </b>
          <br><em>Description forthcoming.</em>


        



<section name="maximum">
<label id="method**NSNumberFormatter**-maximum" />- <code>(NSDecimalNumber*) </code>
          <b>maximum </b>
          <br><em>Description forthcoming.</em>


        



<section name="minimum">
<label id="method**NSNumberFormatter**-minimum" />- <code>(NSDecimalNumber*) </code>
          <b>minimum </b>
          <br><em>Description forthcoming.</em>


        



<section name="negativeFormat">
<label id="method**NSNumberFormatter**-negativeFormat" />- <code>(NSString*) </code>
          <b>negativeFormat </b>
          <br><em>Description forthcoming.</em>


        



<section name="positiveFormat">
<label id="method**NSNumberFormatter**-positiveFormat" />- <code>(NSString*) </code>
          <b>positiveFormat </b>
          <br><em>Description forthcoming.</em>


        



<section name="roundingBehavior">
<label id="method**NSNumberFormatter**-roundingBehavior" />- <code>(NSDecimalNumberHandler*) </code>
          <b>roundingBehavior </b>
          <br><em>Description forthcoming.</em>


        



<section name="setAllowsFloats:">
<label id="method**NSNumberFormatter**-setAllowsFloats:" />- <code>(void) </code>
          <b>setAllowsFloats: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAttributedStringForNil:">
<label id="method**NSNumberFormatter**-setAttributedStringForNil:" />- <code>(void) </code>
          <b>setAttributedStringForNil: </b>
          <code>(NSAttributedString*) </code><i>newAttributedString </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAttributedStringForNotANumber:">
<label id="method**NSNumberFormatter**-setAttributedStringForNotANumber:" />- <code>(void) </code>
          <b>setAttributedStringForNotANumber: </b>
          <code>(NSAttributedString*) </code><i>newAttributedString </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAttributedStringForZero:">
<label id="method**NSNumberFormatter**-setAttributedStringForZero:" />- <code>(void) </code>
          <b>setAttributedStringForZero: </b>
          <code>(NSAttributedString*) </code><i>newAttributedString </i>
          <br><em>Description forthcoming.</em>


        



<section name="setDecimalSeparator:">
<label id="method**NSNumberFormatter**-setDecimalSeparator:" />- <code>(void) </code>
          <b>setDecimalSeparator: </b>
          <code>(NSString*) </code><i>newSeparator </i>
          <br><em>Description forthcoming.</em>


        



<section name="setFormat:">
<label id="method**NSNumberFormatter**-setFormat:" />- <code>(void) </code>
          <b>setFormat: </b>
          <code>(NSString*) </code><i>aFormat </i>
          <br><em>Description forthcoming.</em>


        



<section name="setHasThousandSeparators:">
<label id="method**NSNumberFormatter**-setHasThousandSeparators:" />- <code>(void) </code>
          <b>setHasThousandSeparators: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="setLocalizesFormat:">
<label id="method**NSNumberFormatter**-setLocalizesFormat:" />- <code>(void) </code>
          <b>setLocalizesFormat: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="setMaximum:">
<label id="method**NSNumberFormatter**-setMaximum:" />- <code>(void) </code>
          <b>setMaximum: </b>
          <code>(NSDecimalNumber*) </code><i>aMaximum </i>
          <br><em>Description forthcoming.</em>


        



<section name="setMinimum:">
<label id="method**NSNumberFormatter**-setMinimum:" />- <code>(void) </code>
          <b>setMinimum: </b>
          <code>(NSDecimalNumber*) </code><i>aMinimum </i>
          <br><em>Description forthcoming.</em>


        



<section name="setNegativeFormat:">
<label id="method**NSNumberFormatter**-setNegativeFormat:" />- <code>(void) </code>
          <b>setNegativeFormat: </b>
          <code>(NSString*) </code><i>aFormat </i>
          <br><em>Description forthcoming.</em>


        



<section name="setPositiveFormat:">
<label id="method**NSNumberFormatter**-setPositiveFormat:" />- <code>(void) </code>
          <b>setPositiveFormat: </b>
          <code>(NSString*) </code><i>aFormat </i>
          <br><em>Description forthcoming.</em>


        



<section name="setRoundingBehavior:">
<label id="method**NSNumberFormatter**-setRoundingBehavior:" />- <code>(void) </code>
          <b>setRoundingBehavior: </b>
          <code>(NSDecimalNumberHandler*) </code><i>newRoundingBehavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="setTextAttributesForNegativeValues:">
<label id="method**NSNumberFormatter**-setTextAttributesForNegativeValues:" />- <code>(void) </code>
          <b>setTextAttributesForNegativeValues: </b>
          <code>(NSDictionary*) </code><i>newAttributes </i>
          <br><em>Description forthcoming.</em>


        



<section name="setTextAttributesForPositiveValues:">
<label id="method**NSNumberFormatter**-setTextAttributesForPositiveValues:" />- <code>(void) </code>
          <b>setTextAttributesForPositiveValues: </b>
          <code>(NSDictionary*) </code><i>newAttributes </i>
          <br><em>Description forthcoming.</em>


        



<section name="setThousandSeparator:">
<label id="method**NSNumberFormatter**-setThousandSeparator:" />- <code>(void) </code>
          <b>setThousandSeparator: </b>
          <code>(NSString*) </code><i>newSeparator </i>
          <br><em>Description forthcoming.</em>


        



<section name="textAttributesForNegativeValues">
<label id="method**NSNumberFormatter**-textAttributesForNegativeValues" />- <code>(NSDictionary*) </code>
          <b>textAttributesForNegativeValues </b>
          <br><em>Description forthcoming.</em>


        



<section name="textAttributesForPositiveValues">
<label id="method**NSNumberFormatter**-textAttributesForPositiveValues" />- <code>(NSDictionary*) </code>
          <b>textAttributesForPositiveValues </b>
          <br><em>Description forthcoming.</em>


        



<section name="thousandSeparator">
<label id="method**NSNumberFormatter**-thousandSeparator" />- <code>(NSString*) </code>
          <b>thousandSeparator </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSArchiver">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSArchiver">NSArchiver</ref>: <ref id="NSCoder">NSCoder</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSArchiver.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="archiveRootObject:toFile:">
<label id="method**NSArchiver**+archiveRootObject:toFile:" />+ <code>(BOOL) </code>
          <b>archiveRootObject: </b>
          <code>(id) </code><i>rootObject </i>
          <b>toFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="archivedDataWithRootObject:">
<label id="method**NSArchiver**+archivedDataWithRootObject:" />+ <code>(NSData*) </code>
          <b>archivedDataWithRootObject: </b>
          <code>(id) </code><i>rootObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="archiverData">
<label id="method**NSArchiver**-archiverData" />- <code>(NSMutableData*) </code>
          <b>archiverData </b>
          <br><em>Description forthcoming.</em>


        



<section name="classNameEncodedForTrueClassName:">
<label id="method**NSArchiver**-classNameEncodedForTrueClassName:" />- <code>(NSString*) </code>
          <b>classNameEncodedForTrueClassName: </b>
          <code>(NSString*) </code><i>trueName </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeClassName:intoClassName:">
<label id="method**NSArchiver**-encodeClassName:intoClassName:" />- <code>(void) </code>
          <b>encodeClassName: </b>
          <code>(NSString*) </code><i>trueName </i>
          <b>intoClassName: </b>
          <code>(NSString*) </code><i>inArchiveName </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForWritingWithMutableData:">
<label id="method**NSArchiver**-initForWritingWithMutableData:" />- <code>(id) </code>
          <b>initForWritingWithMutableData: </b>
          <code>(NSMutableData*) </code><i>mdata </i>
          <br><em>Description forthcoming.</em>


        



<section name="replaceObject:withObject:">
<label id="method**NSArchiver**-replaceObject:withObject:" />- <code>(void) </code>
          <b>replaceObject: </b>
          <code>(id) </code><i>object </i>
          <b>withObject: </b>
          <code>(id) </code><i>newObject </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSNotificationCenter">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSNotificationCenter">NSNotificationCenter</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>GCFinalization
<br><b>Declared in: </b>NSNotification.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
      

<section name="defaultCenter">
<label id="method**NSNotificationCenter**+defaultCenter" />+ <code>(NSNotificationCenter*) </code>
          <b>defaultCenter </b>
          <br><em>Description forthcoming.</em>


        



<section name="addObserver:selector:name:object:">
<label id="method**NSNotificationCenter**-addObserver:selector:name:object:" />- <code>(void) </code>
          <b>addObserver: </b>
          <code>(id) </code><i>observer </i>
          <b>selector: </b>
          <code>(SEL) </code><i>selector </i>
          <b>name: </b>
          <code>(NSString*) </code><i>name </i>
          <b>object: </b>
          <code>(id) </code><i>object </i>
          <br><em>Description forthcoming.</em>


        



<section name="postNotification:">
<label id="method**NSNotificationCenter**-postNotification:" />- <code>(void) </code>
          <b>postNotification: </b>
          <code>(NSNotification*) </code><i>notification </i>
          <br>Posts <i>notification</i> to all the observers
            that match its NAME and OBJECT. 
<br>
 The GNUstep
            implementation calls
            <ref id="method**NSNotificationCenter**-postNotificationName:object:userInfo:">-postNotificationName:object:userInfo:</ref> to perform the actual posting.


        



<section name="postNotificationName:object:">
<label id="method**NSNotificationCenter**-postNotificationName:object:" />- <code>(void) </code>
          <b>postNotificationName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>object: </b>
          <code>(id) </code><i>object </i>
          <br>Creates and posts a notification using the
            <ref id="method**NSNotificationCenter**-postNotificationName:object:userInfo:">-postNotificationName:object:userInfo:</ref> passing a <code>nil</code> user info argument.


        



<section name="postNotificationName:object:userInfo:">
<label id="method**NSNotificationCenter**-postNotificationName:object:userInfo:" />- <code>(void) </code>
          <b>postNotificationName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>object: </b>
          <code>(id) </code><i>object </i>
          <b>userInfo: </b>
          <code>(NSDictionary*) </code><i>info </i>
          <br>The preferred method for posting a notification. 
<br>

            For performance reasons, we don't wrap an exception
            handler round every message sent to an observer.
            This means that, if one observer raises an exception,
            later observers in the lists will not get the
            notification.


        



<section name="removeObserver:">
<label id="method**NSNotificationCenter**-removeObserver:" />- <code>(void) </code>
          <b>removeObserver: </b>
          <code>(id) </code><i>observer </i>
          <br><em>Description forthcoming.</em>


        



<section name="removeObserver:name:object:">
<label id="method**NSNotificationCenter**-removeObserver:name:object:" />- <code>(void) </code>
          <b>removeObserver: </b>
          <code>(id) </code><i>observer </i>
          <b>name: </b>
          <code>(NSString*) </code><i>name </i>
          <b>object: </b>
          <code>(id) </code><i>object </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSAutoreleasePool">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSAutoreleasePool">NSAutoreleasePool</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSAutoreleasePool.h
</section>

<section name="Description">
<br>This class maintains a stack of autorelease pools
            objects in each thread.
          When an autorelease pool is created, it is
            automatically added to the stack of pools in
            the thread.
          When a pool is destroyed, it (and any pool later in
            the stack) is removed from the stack.


</section>

<section name="Methods">


<section name="_endThread:">
<label id="method**NSAutoreleasePool**+_endThread:" />+ <code>(void) </code>
          <b>_endThread: </b>
          <code>(NSThread*) </code><i>thread </i>
          <br><em>Warning</em> the underscore at the start of the
            name of this method indicates that it is private, for
            internal use only, and you should not use the
            method in your code.


        



<section name="addObject:">
<label id="method**NSAutoreleasePool**+addObject:" />+ <code>(void) </code>
          <b>addObject: </b>
          <code>(id) </code><i>anObj </i>
          <br>Adds the specified object to the current autorelease
            pool. If there is no autorelease pool in the thread,
            a warning is logged.


        



<section name="autoreleaseCountForObject:">
<label id="method**NSAutoreleasePool**+autoreleaseCountForObject:" />+ <code>(unsigned) </code>
          <b>autoreleaseCountForObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Counts the number of times that the specified
              object occurs in autorelease pools in the current
              thread.
            This method is <em>slow</em> and should probably
              only be used for debugging purposes.


        



<section name="enableRelease:">
<label id="method**NSAutoreleasePool**+enableRelease:" />+ <code>(void) </code>
          <b>enableRelease: </b>
          <code>(BOOL) </code><i>enable </i>
          <br>Specifies whether objects contained in
              autorelease pools are to be released when the
              pools are deallocated (by default <code>YES</code>
              ).
            You can set this to <code>NO</code> for debugging
              purposes.


        



<section name="freeCache">
<label id="method**NSAutoreleasePool**+freeCache" />+ <code>(void) </code>
          <b>freeCache </b>
          <br>When autorelease pools are deallocated, the memory
              they used is retained in a cache for re-use so that
              new polls can be created very quickly.
            This method may be used to empty that cache,
              ensuring that the minimum memory is used by the
              application.


        



<section name="resetTotalAutoreleasedObjects">
<label id="method**NSAutoreleasePool**+resetTotalAutoreleasedObjects" />+ <code>(void) </code>
          <b>resetTotalAutoreleasedObjects </b>
          <br><em>Description forthcoming.</em>


        



<section name="setPoolCountThreshhold:">
<label id="method**NSAutoreleasePool**+setPoolCountThreshhold:" />+ <code>(void) </code>
          <b>setPoolCountThreshhold: </b>
          <code>(unsigned) </code><i>c </i>
          <br>Specifies a limit to the number of objects that
              may be added to an autorelease pool. When this limit
              is reached an exception is raised.
            You can set this to a smallish value to catch
              problems with code that autoreleases too many
              objects to operate efficiently.
            Default value is maxint.


        



<section name="totalAutoreleasedObjects">
<label id="method**NSAutoreleasePool**+totalAutoreleasedObjects" />+ <code>(unsigned) </code>
          <b>totalAutoreleasedObjects </b>
          <br><em>Description forthcoming.</em>


        



<section name="addObject:">
<label id="method**NSAutoreleasePool**-addObject:" />- <code>(void) </code>
          <b>addObject: </b>
          <code>(id) </code><i>anObj </i>
          <br>Adds the specified object to this autorelease pool.


        


        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSPort">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSPort">NSPort</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopying
<br><b>Declared in: </b>NSPort.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="port">
<label id="method**NSPort**+port" />+ <code>(NSPort*) </code>
          <b>port </b>
          <br><em>Description forthcoming.</em>


        



<section name="portWithMachPort:">
<label id="method**NSPort**+portWithMachPort:" />+ <code>(NSPort*) </code>
          <b>portWithMachPort: </b>
          <code>(int) </code><i>machPort </i>
          <br><em>Description forthcoming.</em>


        



<section name="addConnection:toRunLoop:forMode:">
<label id="method**NSPort**-addConnection:toRunLoop:forMode:" />- <code>(void) </code>
          <b>addConnection: </b>
          <code>(NSConnection*) </code><i>aConnection </i>
          <b>toRunLoop: </b>
          <code>(NSRunLoop*) </code><i>aLoop </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>aMode </i>
          <br><em>Description forthcoming.</em>


        



<section name="delegate">
<label id="method**NSPort**-delegate" />- <code>(id) </code>
          <b>delegate </b>
          <br><em>Description forthcoming.</em>


        



<section name="init">
<label id="method**NSPort**-init" />- <code>(id) </code>
          <b>init </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithMachPort:">
<label id="method**NSPort**-initWithMachPort:" />- <code>(id) </code>
          <b>initWithMachPort: </b>
          <code>(int) </code><i>machPort </i>
          <br><em>Description forthcoming.</em>


        



<section name="invalidate">
<label id="method**NSPort**-invalidate" />- <code>(void) </code>
          <b>invalidate </b>
          <br><em>Description forthcoming.</em>


        



<section name="isValid">
<label id="method**NSPort**-isValid" />- <code>(BOOL) </code>
          <b>isValid </b>
          <br><em>Description forthcoming.</em>


        



<section name="machPort">
<label id="method**NSPort**-machPort" />- <code>(int) </code>
          <b>machPort </b>
          <br><em>Description forthcoming.</em>


        



<section name="removeConnection:fromRunLoop:forMode:">
<label id="method**NSPort**-removeConnection:fromRunLoop:forMode:" />- <code>(void) </code>
          <b>removeConnection: </b>
          <code>(NSConnection*) </code><i>aConnection </i>
          <b>fromRunLoop: </b>
          <code>(NSRunLoop*) </code><i>aLoop </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>aMode </i>
          <br><em>Description forthcoming.</em>


        



<section name="reservedSpaceLength">
<label id="method**NSPort**-reservedSpaceLength" />- <code>(unsigned) </code>
          <b>reservedSpaceLength </b>
          <br><em>Description forthcoming.</em>


        



<section name="sendBeforeDate:components:from:reserved:">
<label id="method**NSPort**-sendBeforeDate:components:from:reserved:" />- <code>(BOOL) </code>
          <b>sendBeforeDate: </b>
          <code>(NSDate*) </code><i>when </i>
          <b>components: </b>
          <code>(NSMutableArray*) </code><i>components </i>
          <b>from: </b>
          <code>(NSPort*) </code><i>receivingPort </i>
          <b>reserved: </b>
          <code>(unsigned) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="sendBeforeDate:msgid:components:from:reserved:">
<label id="method**NSPort**-sendBeforeDate:msgid:components:from:reserved:" />- <code>(BOOL) </code>
          <b>sendBeforeDate: </b>
          <code>(NSDate*) </code><i>when </i>
          <b>msgid: </b>
          <code>(int) </code><i>msgid </i>
          <b>components: </b>
          <code>(NSMutableArray*) </code><i>components </i>
          <b>from: </b>
          <code>(NSPort*) </code><i>receivingPort </i>
          <b>reserved: </b>
          <code>(unsigned) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="setDelegate:">
<label id="method**NSPort**-setDelegate:" />- <code>(void) </code>
          <b>setDelegate: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="GSXPathContext">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXPathContext">GSXPathContext</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="evaluateExpression:">
<label id="method**GSXPathContext**-evaluateExpression:" />- <code>(GSXPathObject*) </code>
          <b>evaluateExpression: </b>
          <code>(NSString*) </code><i>XPathExpression </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithDocument:">
<label id="method**GSXPathContext**-initWithDocument:" />- <code>(id) </code>
          <b>initWithDocument: </b>
          <code>(GSXMLDocument*) </code><i>d </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
      
</section>


</chapter>


<chapter name="NSDecimalNumberHandler">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDecimalNumberHandler">NSDecimalNumberHandler</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSDecimalNumberBehaviors
<br><b>Declared in: </b>NSDecimalNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
      

<section name="decimalNumberHandlerWithRoundingMode:scale:raiseOnExactness:raiseOnOverflow:raiseOnUnderflow:raiseOnDivideByZero:">
<label id="method**NSDecimalNumberHandler**+decimalNumberHandlerWithRoundingMode:scale:raiseOnExactness:raiseOnOverflow:raiseOnUnderflow:raiseOnDivideByZero:" />+ <code>(id) </code>
          <b>decimalNumberHandlerWithRoundingMode: </b>
          <code>(NSRoundingMode) </code><i>roundingMode </i>
          <b>scale: </b>
          <code>(short) </code><i>scale </i>
          <b>raiseOnExactness: </b>
          <code>(BOOL) </code><i>raiseOnExactness </i>
          <b>raiseOnOverflow: </b>
          <code>(BOOL) </code><i>raiseOnOverflow </i>
          <b>raiseOnUnderflow: </b>
          <code>(BOOL) </code><i>raiseOnUnderflow </i>
          <b>raiseOnDivideByZero: </b>
          <code>(BOOL) </code><i>raiseOnDivideByZero </i>
          <br><em>Description forthcoming.</em>


        



<section name="defaultDecimalNumberHandler">
<label id="method**NSDecimalNumberHandler**+defaultDecimalNumberHandler" />+ <code>(id) </code>
          <b>defaultDecimalNumberHandler </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithRoundingMode:scale:raiseOnExactness:raiseOnOverflow:raiseOnUnderflow:raiseOnDivideByZero:">
<label id="method**NSDecimalNumberHandler**-initWithRoundingMode:scale:raiseOnExactness:raiseOnOverflow:raiseOnUnderflow:raiseOnDivideByZero:" />- <code>(id) </code>
          <b>initWithRoundingMode: </b>
          <code>(NSRoundingMode) </code><i>roundingMode </i>
          <b>scale: </b>
          <code>(short) </code><i>scale </i>
          <b>raiseOnExactness: </b>
          <code>(BOOL) </code><i>raiseOnExactness </i>
          <b>raiseOnOverflow: </b>
          <code>(BOOL) </code><i>raiseOnOverflow </i>
          <b>raiseOnUnderflow: </b>
          <code>(BOOL) </code><i>raiseOnUnderflow </i>
          <b>raiseOnDivideByZero: </b>
          <code>(BOOL) </code><i>raiseOnDivideByZero </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSULongLongNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSULongLongNumber">NSULongLongNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSValue">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopyingNSCoding
<br><b>Declared in: </b>NSValue.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="value:withObjCType:">
<label id="method**NSValue**+value:withObjCType:" />+ <code>(NSValue*) </code>
          <b>value: </b>
          <code>(const void*) </code><i>value </i>
          <b>withObjCType: </b>
          <code>(const char*) </code><i>type </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueFromString:">
<label id="method**NSValue**+valueFromString:" />+ <code>(NSValue*) </code>
          <b>valueFromString: </b>
          <code>(NSString*) </code><i>string </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueWithBytes:objCType:">
<label id="method**NSValue**+valueWithBytes:objCType:" />+ <code>(NSValue*) </code>
          <b>valueWithBytes: </b>
          <code>(const void*) </code><i>value </i>
          <b>objCType: </b>
          <code>(const char*) </code><i>type </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueWithNonretainedObject:">
<label id="method**NSValue**+valueWithNonretainedObject:" />+ <code>(NSValue*) </code>
          <b>valueWithNonretainedObject: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueWithPoint:">
<label id="method**NSValue**+valueWithPoint:" />+ <code>(NSValue*) </code>
          <b>valueWithPoint: </b>
          <code>(NSPoint) </code><i>point </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueWithPointer:">
<label id="method**NSValue**+valueWithPointer:" />+ <code>(NSValue*) </code>
          <b>valueWithPointer: </b>
          <code>(const void*) </code><i>pointer </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueWithRange:">
<label id="method**NSValue**+valueWithRange:" />+ <code>(NSValue*) </code>
          <b>valueWithRange: </b>
          <code>(NSRange) </code><i>range </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueWithRect:">
<label id="method**NSValue**+valueWithRect:" />+ <code>(NSValue*) </code>
          <b>valueWithRect: </b>
          <code>(NSRect) </code><i>rect </i>
          <br><em>Description forthcoming.</em>


        



<section name="valueWithSize:">
<label id="method**NSValue**+valueWithSize:" />+ <code>(NSValue*) </code>
          <b>valueWithSize: </b>
          <code>(NSSize) </code><i>size </i>
          <br><em>Description forthcoming.</em>


        



<section name="getValue:">
<label id="method**NSValue**-getValue:" />- <code>(void) </code>
          <b>getValue: </b>
          <code>(void*) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithBytes:objCType:">
<label id="method**NSValue**-initWithBytes:objCType:" />- <code>(id) </code>
          <b>initWithBytes: </b>
          <code>(const void*) </code><i>data </i>
          <b>objCType: </b>
          <code>(const char*) </code><i>type </i>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToValue:">
<label id="method**NSValue**-isEqualToValue:" />- <code>(BOOL) </code>
          <b>isEqualToValue: </b>
          <code>(NSValue*) </code><i>other </i>
          <br><em>Description forthcoming.</em>


        



<section name="nonretainedObjectValue">
<label id="method**NSValue**-nonretainedObjectValue" />- <code>(id) </code>
          <b>nonretainedObjectValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="objCType">
<label id="method**NSValue**-objCType" />- <code>(const char*) </code>
          <b>objCType </b>
          <br><em>Description forthcoming.</em>


        



<section name="pointValue">
<label id="method**NSValue**-pointValue" />- <code>(NSPoint) </code>
          <b>pointValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="pointerValue">
<label id="method**NSValue**-pointerValue" />- <code>(void*) </code>
          <b>pointerValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="rangeValue">
<label id="method**NSValue**-rangeValue" />- <code>(NSRange) </code>
          <b>rangeValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="rectValue">
<label id="method**NSValue**-rectValue" />- <code>(NSRect) </code>
          <b>rectValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="sizeValue">
<label id="method**NSValue**-sizeValue" />- <code>(NSSize) </code>
          <b>sizeValue </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSBoolNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSBoolNumber">NSBoolNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="GSFileHandle">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSFileHandle">GSFileHandle</ref>: <ref id="NSFileHandle">NSFileHandle</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>RunLoopEventsGCFinalization
<br><b>Declared in: </b>GSFileHandle.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="checkAccept">
<label id="method**GSFileHandle**-checkAccept" />- <code>(void) </code>
          <b>checkAccept </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkConnect">
<label id="method**GSFileHandle**-checkConnect" />- <code>(void) </code>
          <b>checkConnect </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkRead">
<label id="method**GSFileHandle**-checkRead" />- <code>(void) </code>
          <b>checkRead </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkWrite">
<label id="method**GSFileHandle**-checkWrite" />- <code>(void) </code>
          <b>checkWrite </b>
          <br><em>Description forthcoming.</em>


        



<section name="ignoreReadDescriptor">
<label id="method**GSFileHandle**-ignoreReadDescriptor" />- <code>(void) </code>
          <b>ignoreReadDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="ignoreWriteDescriptor">
<label id="method**GSFileHandle**-ignoreWriteDescriptor" />- <code>(void) </code>
          <b>ignoreWriteDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="initAsClientAtAddress:service:protocol:">
<label id="method**GSFileHandle**-initAsClientAtAddress:service:protocol:" />- <code>(id) </code>
          <b>initAsClientAtAddress: </b>
          <code>(NSString*) </code><i>a </i>
          <b>service: </b>
          <code>(NSString*) </code><i>s </i>
          <b>protocol: </b>
          <code>(NSString*) </code><i>p </i>
          <br>Initialise as <i>a</i> client socket
            connection... do this by using
            <ref id="method**GSFileHandle**-initAsClientInBackgroundAtAddress:service:protocol:forModes:">[-initAsClientInBackgroundAtAddress:service:protocol:forModes:]</ref> and running the current run loop in NSDefaultRunLoopMode until the connection attempt succeeds, fails, or times out.


        



<section name="initAsClientInBackgroundAtAddress:service:protocol:forModes:">
<label id="method**GSFileHandle**-initAsClientInBackgroundAtAddress:service:protocol:forModes:" />- <code>(id) </code>
          <b>initAsClientInBackgroundAtAddress: </b>
          <code>(NSString*) </code><i>a </i>
          <b>service: </b>
          <code>(NSString*) </code><i>s </i>
          <b>protocol: </b>
          <code>(NSString*) </code><i>p </i>
          <b>forModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br>A protocol fo the form 'socks-...' controls socks
            operation, overriding defaults and environment
            variables. 
<br>
 If it is just 'socks-' it
            turns off socks for this fiel handle. 
<br>

            Otherwise, the following text must be the name
            of the socks server (optionally followed by :port).


        



<section name="initAsServerAtAddress:service:protocol:">
<label id="method**GSFileHandle**-initAsServerAtAddress:service:protocol:" />- <code>(id) </code>
          <b>initAsServerAtAddress: </b>
          <code>(NSString*) </code><i>a </i>
          <b>service: </b>
          <code>(NSString*) </code><i>s </i>
          <b>protocol: </b>
          <code>(NSString*) </code><i>p </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForReadingAtPath:">
<label id="method**GSFileHandle**-initForReadingAtPath:" />- <code>(id) </code>
          <b>initForReadingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForUpdatingAtPath:">
<label id="method**GSFileHandle**-initForUpdatingAtPath:" />- <code>(id) </code>
          <b>initForUpdatingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForWritingAtPath:">
<label id="method**GSFileHandle**-initForWritingAtPath:" />- <code>(id) </code>
          <b>initForWritingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithNullDevice">
<label id="method**GSFileHandle**-initWithNullDevice" />- <code>(id) </code>
          <b>initWithNullDevice </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardError">
<label id="method**GSFileHandle**-initWithStandardError" />- <code>(id) </code>
          <b>initWithStandardError </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardInput">
<label id="method**GSFileHandle**-initWithStandardInput" />- <code>(id) </code>
          <b>initWithStandardInput </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardOutput">
<label id="method**GSFileHandle**-initWithStandardOutput" />- <code>(id) </code>
          <b>initWithStandardOutput </b>
          <br><em>Description forthcoming.</em>


        



<section name="postReadNotification">
<label id="method**GSFileHandle**-postReadNotification" />- <code>(void) </code>
          <b>postReadNotification </b>
          <br><em>Description forthcoming.</em>


        



<section name="postWriteNotification">
<label id="method**GSFileHandle**-postWriteNotification" />- <code>(void) </code>
          <b>postWriteNotification </b>
          <br><em>Description forthcoming.</em>


        



<section name="read:length:">
<label id="method**GSFileHandle**-read:length:" />- <code>(int) </code>
          <b>read: </b>
          <code>(void*) </code><i>buf </i>
          <b>length: </b>
          <code>(int) </code><i>len </i>
          <br>Encapsulates low level read operation to get
            data from the operating system.


        



<section name="receivedEvent:type:extra:forMode:">
<label id="method**GSFileHandle**-receivedEvent:type:extra:forMode:" />- <code>(void) </code>
          <b>receivedEvent: </b>
          <code>(void*) </code><i>data </i>
          <b>type: </b>
          <code>(RunLoopEventType) </code><i>type </i>
          <b>extra: </b>
          <code>(void*) </code><i>extra </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAddr:">
<label id="method**GSFileHandle**-setAddr:" />- <code>(void) </code>
          <b>setAddr: </b>
          <code>(struct sockaddr_in*) </code><i>sin </i>
          <br><em>Description forthcoming.</em>


        



<section name="setNonBlocking:">
<label id="method**GSFileHandle**-setNonBlocking:" />- <code>(void) </code>
          <b>setNonBlocking: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="timedOutEvent:type:forMode:">
<label id="method**GSFileHandle**-timedOutEvent:type:forMode:" />- <code>(NSDate*) </code>
          <b>timedOutEvent: </b>
          <code>(void*) </code><i>data </i>
          <b>type: </b>
          <code>(RunLoopEventType) </code><i>type </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br><em>Description forthcoming.</em>


        



<section name="useCompression">
<label id="method**GSFileHandle**-useCompression" />- <code>(BOOL) </code>
          <b>useCompression </b>
          <br><em>Description forthcoming.</em>


        



<section name="watchReadDescriptorForModes:">
<label id="method**GSFileHandle**-watchReadDescriptorForModes:" />- <code>(void) </code>
          <b>watchReadDescriptorForModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br><em>Description forthcoming.</em>


        



<section name="watchWriteDescriptor">
<label id="method**GSFileHandle**-watchWriteDescriptor" />- <code>(void) </code>
          <b>watchWriteDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="write:length:">
<label id="method**GSFileHandle**-write:length:" />- <code>(int) </code>
          <b>write: </b>
          <code>(const void*) </code><i>buf </i>
          <b>length: </b>
          <code>(int) </code><i>len </i>
          <br>Encapsulates low level write operation to send
            data to the operating system.


        


</section>


</chapter>


<chapter name="NSHost">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSHost">NSHost</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSHost.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="currentHost">
<label id="method**NSHost**+currentHost" />+ <code>(NSHost*) </code>
          <b>currentHost </b>
          <br><em>Description forthcoming.</em>


        



<section name="flushHostCache">
<label id="method**NSHost**+flushHostCache" />+ <code>(void) </code>
          <b>flushHostCache </b>
          <br><em>Description forthcoming.</em>


        



<section name="hostWithAddress:">
<label id="method**NSHost**+hostWithAddress:" />+ <code>(NSHost*) </code>
          <b>hostWithAddress: </b>
          <code>(NSString*) </code><i>address </i>
          <br><em>Description forthcoming.</em>


        



<section name="hostWithName:">
<label id="method**NSHost**+hostWithName:" />+ <code>(NSHost*) </code>
          <b>hostWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="isHostCacheEnabled">
<label id="method**NSHost**+isHostCacheEnabled" />+ <code>(BOOL) </code>
          <b>isHostCacheEnabled </b>
          <br><em>Description forthcoming.</em>


        



<section name="setHostCacheEnabled:">
<label id="method**NSHost**+setHostCacheEnabled:" />+ <code>(void) </code>
          <b>setHostCacheEnabled: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="address">
<label id="method**NSHost**-address" />- <code>(NSString*) </code>
          <b>address </b>
          <br><em>Description forthcoming.</em>


        



<section name="addresses">
<label id="method**NSHost**-addresses" />- <code>(NSArray*) </code>
          <b>addresses </b>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToHost:">
<label id="method**NSHost**-isEqualToHost:" />- <code>(BOOL) </code>
          <b>isEqualToHost: </b>
          <code>(NSHost*) </code><i>aHost </i>
          <br><em>Description forthcoming.</em>


        



<section name="name">
<label id="method**NSHost**-name" />- <code>(NSString*) </code>
          <b>name </b>
          <br><em>Description forthcoming.</em>


        



<section name="names">
<label id="method**NSHost**-names" />- <code>(NSArray*) </code>
          <b>names </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSString">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSString">NSString</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSMutableCopying
<br><b>Declared in: </b>NSString.h
</section>

<section name="Description">
<br>NSString objects represent an immutable string of
            characters. NSString itself is an abstract
            class which provides factory methods to generate
            objects of unspecified subclasses.
          A constant NSString can be created using the following
            syntax: <code>@"..."</code>, where the contents of
            the quotes are the string, using only ASCII characters.
          To create a concrete subclass of NSString, you must have
            your class inherit from NSString and override at least
            the two primitive methods - length and
            characterAtIndex:
          In general the rule is that your subclass must override
            any initialiser that you want to use with it. The
            GNUstep implementation relaxes that to say that,
            you may override only the
            <em>designated initialiser</em> and the other
            initialisation methods should work.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="availableStringEncodings">
<label id="method**NSString**+availableStringEncodings" />+ <code>(NSStringEncoding*) </code>
          <b>availableStringEncodings </b>
          <br>Returns an array of all available string encodings,
            terminated by a null value.


        



<section name="constantStringClass">
<label id="method**NSString**+constantStringClass" />+ <code>(Class) </code>
          <b>constantStringClass </b>
          <br>Return the class used to store constant strings
            (those ascii strings placed in the source code using
            the @"this is a string" syntax). 
<br>
 Use this method
            to obtain the constant string class rather than using
            the obsolete name <em>NXConstantString</em> in your
            code... with more recent compiler versions the name of
            this class is variable (and will automatically be
            changed by GNUstep to avoid conflicts with the
            default implementation in the Objective-C runtime
            library).


        



<section name="defaultCStringEncoding">
<label id="method**NSString**+defaultCStringEncoding" />+ <code>(NSStringEncoding) </code>
          <b>defaultCStringEncoding </b>
          <br>Returns the encoding used for any method
              accepting a C string. This value is determined
              automatically from the programs environment
              and cannot be changed programmatically.
            You should <em>NOT</em> override this method in an
              attempt to change the encoding being used... it
              won't work.
            In GNUstep, this encoding is determined by the initial
              value of the <code>GNUSTEP_STRING_ENCODING</code>
              environment variable. If this is not defined,
              <code>NSISOLatin1StringEncoding</code> is assumed.


        



<section name="localizedNameOfStringEncoding:">
<label id="method**NSString**+localizedNameOfStringEncoding:" />+ <code>(NSString*) </code>
          <b>localizedNameOfStringEncoding: </b>
          <code>(NSStringEncoding) </code><i>encoding </i>
          <br>Returns the localized name of the
            <i>encoding</i> specified.


        



<section name="localizedStringWithFormat:">
<label id="method**NSString**+localizedStringWithFormat:" />+ <code>(NSString*) </code>
          <b>localizedStringWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="pathWithComponents:">
<label id="method**NSString**+pathWithComponents:" />+ <code>(NSString*) </code>
          <b>pathWithComponents: </b>
          <code>(NSArray*) </code><i>components </i>
          <br>Concatenates the strings in the
            <i>components</i> array placing a path separator
            between each one and returns the result.


        



<section name="string">
<label id="method**NSString**+string" />+ <code>(id) </code>
          <b>string </b>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithCString:">
<label id="method**NSString**+stringWithCString:" />+ <code>(id) </code>
          <b>stringWithCString: </b>
          <code>(const char*) </code><i>byteString </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithCString:length:">
<label id="method**NSString**+stringWithCString:length:" />+ <code>(id) </code>
          <b>stringWithCString: </b>
          <code>(const char*) </code><i>byteString </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithCharacters:length:">
<label id="method**NSString**+stringWithCharacters:length:" />+ <code>(id) </code>
          <b>stringWithCharacters: </b>
          <code>(const unichar*) </code><i>chars </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithContentsOfFile:">
<label id="method**NSString**+stringWithContentsOfFile:" />+ <code>(id) </code>
          <b>stringWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithContentsOfURL:">
<label id="method**NSString**+stringWithContentsOfURL:" />+ <code>(id) </code>
          <b>stringWithContentsOfURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithFormat:">
<label id="method**NSString**+stringWithFormat:" />+ <code>(id) </code>
          <b>stringWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="stringWithFormat:arguments:">
<label id="method**NSString**+stringWithFormat:arguments:" />+ <code>(id) </code>
          <b>stringWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>arguments: </b>
          <code>(va_list) </code><i>argList </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithString:">
<label id="method**NSString**+stringWithString:" />+ <code>(id) </code>
          <b>stringWithString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithUTF8String:">
<label id="method**NSString**+stringWithUTF8String:" />+ <code>(id) </code>
          <b>stringWithUTF8String: </b>
          <code>(const char*) </code><i>bytes </i>
          <br><em>Description forthcoming.</em>


        



<section name="UTF8String">
<label id="method**NSString**-UTF8String" />- <code>(const char*) </code>
          <b>UTF8String </b>
          <br><em>Description forthcoming.</em>


        



<section name="_baseLength">
<label id="method**NSString**-_baseLength" />- <code>(int) </code>
          <b>_baseLength </b>
          <br><em>Warning</em> the underscore at the start of the
            name of this method indicates that it is private, for
            internal use only, and you should not use the
            method in your code.


        



<section name="boolValue">
<label id="method**NSString**-boolValue" />- <code>(BOOL) </code>
          <b>boolValue </b>
          <br>If the string consists of the words 'true' or 'yes'
            (case insensitive) or begins with a non-zero numeric
            value, return <code>YES</code>, otherwise return
            <code>NO</code>.


        



<section name="cString">
<label id="method**NSString**-cString" />- <code>(const char*) </code>
          <b>cString </b>
          <br>Returns a pointer to a null terminated string of
            8-bit characters in the default encoding. The memory
            pointed to is not owned by the caller, so the
            caller must copy its contents to keep it.


        



<section name="cStringLength">
<label id="method**NSString**-cStringLength" />- <code>(unsigned int) </code>
          <b>cStringLength </b>
          <br><em>Description forthcoming.</em>


        



<section name="canBeConvertedToEncoding:">
<label id="method**NSString**-canBeConvertedToEncoding:" />- <code>(BOOL) </code>
          <b>canBeConvertedToEncoding: </b>
          <code>(NSStringEncoding) </code><i>encoding </i>
          <br><em>Description forthcoming.</em>


        



<section name="capitalizedString">
<label id="method**NSString**-capitalizedString" />- <code>(NSString*) </code>
          <b>capitalizedString </b>
          <br><em>Description forthcoming.</em>


        



<section name="caseInsensitiveCompare:">
<label id="method**NSString**-caseInsensitiveCompare:" />- <code>(NSComparisonResult) </code>
          <b>caseInsensitiveCompare: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="characterAtIndex:">
<label id="method**NSString**-characterAtIndex:" />- <code>(unichar) </code>
          <b>characterAtIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="commonPrefixWithString:options:">
<label id="method**NSString**-commonPrefixWithString:options:" />- <code>(NSString*) </code>
          <b>commonPrefixWithString: </b>
          <code>(NSString*) </code><i>aString </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <br><em>Description forthcoming.</em>


        



<section name="compare:">
<label id="method**NSString**-compare:" />- <code>(NSComparisonResult) </code>
          <b>compare: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="compare:options:">
<label id="method**NSString**-compare:options:" />- <code>(NSComparisonResult) </code>
          <b>compare: </b>
          <code>(NSString*) </code><i>aString </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <br><em>Description forthcoming.</em>


        



<section name="compare:options:range:">
<label id="method**NSString**-compare:options:range:" />- <code>(NSComparisonResult) </code>
          <b>compare: </b>
          <code>(NSString*) </code><i>aString </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="compare:options:range:locale:">
<label id="method**NSString**-compare:options:range:locale:" />- <code>(NSComparisonResult) </code>
          <b>compare: </b>
          <code>(NSString*) </code><i>string </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <b>range: </b>
          <code>(NSRange) </code><i>compareRange </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>dict </i>
          <br><em>Description forthcoming.</em>


        



<section name="completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:">
<label id="method**NSString**-completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:" />- <code>(unsigned int) </code>
          <b>completePathIntoString: </b>
          <code>(NSString**) </code><i>outputName </i>
          <b>caseSensitive: </b>
          <code>(BOOL) </code><i>flag </i>
          <b>matchesIntoArray: </b>
          <code>(NSArray**) </code><i>outputArray </i>
          <b>filterTypes: </b>
          <code>(NSArray*) </code><i>filterTypes </i>
          <br><em>Description forthcoming.</em>


        



<section name="componentsSeparatedByString:">
<label id="method**NSString**-componentsSeparatedByString:" />- <code>(NSArray*) </code>
          <b>componentsSeparatedByString: </b>
          <code>(NSString*) </code><i>separator </i>
          <br><em>Description forthcoming.</em>


        



<section name="dataUsingEncoding:">
<label id="method**NSString**-dataUsingEncoding:" />- <code>(NSData*) </code>
          <b>dataUsingEncoding: </b>
          <code>(NSStringEncoding) </code><i>encoding </i>
          <br><em>Description forthcoming.</em>


        



<section name="dataUsingEncoding:allowLossyConversion:">
<label id="method**NSString**-dataUsingEncoding:allowLossyConversion:" />- <code>(NSData*) </code>
          <b>dataUsingEncoding: </b>
          <code>(NSStringEncoding) </code><i>encoding </i>
          <b>allowLossyConversion: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="description">
<label id="method**NSString**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br><em>Description forthcoming.</em>


        



<section name="doubleValue">
<label id="method**NSString**-doubleValue" />- <code>(double) </code>
          <b>doubleValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="fastestEncoding">
<label id="method**NSString**-fastestEncoding" />- <code>(NSStringEncoding) </code>
          <b>fastestEncoding </b>
          <br><em>Description forthcoming.</em>


        



<section name="fileSystemRepresentation">
<label id="method**NSString**-fileSystemRepresentation" />- <code>(const char*) </code>
          <b>fileSystemRepresentation </b>
          <br><em>Description forthcoming.</em>


        



<section name="floatValue">
<label id="method**NSString**-floatValue" />- <code>(float) </code>
          <b>floatValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="getCString:">
<label id="method**NSString**-getCString:" />- <code>(void) </code>
          <b>getCString: </b>
          <code>(char*) </code><i>buffer </i>
          <br>Retrieve the contents of the receiver into the
            <i>buffer</i>. 
<br>
 The <i>buffer</i> must
            be large enought to contain the CString representation
            of the characters in the receiver, plus a null
            terminator which this method adds.


        



<section name="getCString:maxLength:">
<label id="method**NSString**-getCString:maxLength:" />- <code>(void) </code>
          <b>getCString: </b>
          <code>(char*) </code><i>buffer </i>
          <b>maxLength: </b>
          <code>(unsigned int) </code><i>maxLength </i>
          <br>Retrieve up to <i>maxLength</i> characters
            from the receiver into the <i>buffer</i>. 
<br>

            The <i>buffer</i> must be at least
            <i>maxLength</i> characters long, so that it has
            room for the null terminator that this method adds.


        



<section name="getCString:maxLength:range:remainingRange:">
<label id="method**NSString**-getCString:maxLength:range:remainingRange:" />- <code>(void) </code>
          <b>getCString: </b>
          <code>(char*) </code><i>buffer </i>
          <b>maxLength: </b>
          <code>(unsigned int) </code><i>maxLength </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>remainingRange: </b>
          <code>(NSRange*) </code><i>leftoverRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="getCharacters:">
<label id="method**NSString**-getCharacters:" />- <code>(void) </code>
          <b>getCharacters: </b>
          <code>(unichar*) </code><i>buffer </i>
          <br><em>Description forthcoming.</em>


        



<section name="getCharacters:range:">
<label id="method**NSString**-getCharacters:range:" />- <code>(void) </code>
          <b>getCharacters: </b>
          <code>(unichar*) </code><i>buffer </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="getFileSystemRepresentation:maxLength:">
<label id="method**NSString**-getFileSystemRepresentation:maxLength:" />- <code>(BOOL) </code>
          <b>getFileSystemRepresentation: </b>
          <code>(char*) </code><i>buffer </i>
          <b>maxLength: </b>
          <code>(unsigned int) </code><i>size </i>
          <br><em>Description forthcoming.</em>


        



<section name="getLineStart:end:contentsEnd:forRange:">
<label id="method**NSString**-getLineStart:end:contentsEnd:forRange:" />- <code>(void) </code>
          <b>getLineStart: </b>
          <code>(unsigned int*) </code><i>startIndex </i>
          <b>end: </b>
          <code>(unsigned int*) </code><i>lineEndIndex </i>
          <b>contentsEnd: </b>
          <code>(unsigned int*) </code><i>contentsEndIndex </i>
          <b>forRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Determines the smallest range of lines
            containing <i>aRange</i> and returns the
            locations in that range. 
<br>
 Lines are
            delimited by any of these character sequences,
            the longest (CRLF) sequence preferred.
            
            The index of the first character of the line at or
            before <i>aRange</i> is returned in
            <i>startIndex</i>. 
<br>
 The index of the first
            character of the next line after the line
            terminator is returned in endIndex. 
<br>
 The
            index of the last character before the line
            terminator is returned
            <i>contentsEndIndex</i>. 
<br>
 Raises an
            NSRangeException if the range is invalid,
            but permits the index arguments to be null pointers (in
            which case no value is returned in that argument).


        



<section name="hasPrefix:">
<label id="method**NSString**-hasPrefix:" />- <code>(BOOL) </code>
          <b>hasPrefix: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="hasSuffix:">
<label id="method**NSString**-hasSuffix:" />- <code>(BOOL) </code>
          <b>hasSuffix: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="hash">
<label id="method**NSString**-hash" />- <code>(unsigned int) </code>
          <b>hash </b>
          <br>Return 28-bit hash value (in 32-bit integer). The
            top few bits are used for other purposes in a bitfield
            in the concrete string subclasses, so we must not use
            the full unsigned integer.


        



<section name="init">
<label id="method**NSString**-init" />- <code>(id) </code>
          <b>init </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCString:">
<label id="method**NSString**-initWithCString:" />- <code>(id) </code>
          <b>initWithCString: </b>
          <code>(const char*) </code><i>byteString </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCString:length:">
<label id="method**NSString**-initWithCString:length:" />- <code>(id) </code>
          <b>initWithCString: </b>
          <code>(const char*) </code><i>byteString </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCStringNoCopy:length:freeWhenDone:">
<label id="method**NSString**-initWithCStringNoCopy:length:freeWhenDone:" />- <code>(id) </code>
          <b>initWithCStringNoCopy: </b>
          <code>(char*) </code><i>byteString </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <b>freeWhenDone: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCharacters:length:">
<label id="method**NSString**-initWithCharacters:length:" />- <code>(id) </code>
          <b>initWithCharacters: </b>
          <code>(const unichar*) </code><i>chars </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCharactersNoCopy:length:freeWhenDone:">
<label id="method**NSString**-initWithCharactersNoCopy:length:freeWhenDone:" />- <code>(id) </code>
          <b>initWithCharactersNoCopy: </b>
          <code>(unichar*) </code><i>chars </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <b>freeWhenDone: </b>
          <code>(BOOL) </code><i>flag </i>
          <br>This is the most basic initialiser for unicode
            strings. In the GNUstep implementation, your
            subclasses may override this initialiser in
            order to have all others function.


        



<section name="initWithContentsOfFile:">
<label id="method**NSString**-initWithContentsOfFile:" />- <code>(id) </code>
          <b>initWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Initialises the receiver with the contents of
              the file at <i>path</i>.
            Invokes
              <ref id="method**NSData**-initWithContentsOfFile:">[NSData% unknown entity: nbsp
-initWithContentsOfFile:]</ref> to read the file, then examines the data to infer its encoding type, and converts the data to a string using <ref id="method**NSString**-initWithData:encoding:">-initWithData:encoding:</ref>
            The encoding to use is determined as follows... if
              the data begins with the 16-bit unicode Byte Order
              Marker, then it is assumed to be unicode data in
              the appropriate ordering and converted as such.
              
<br>
 If it begins with a UTF8 representation of
              the BOM, the UTF8 encoding is used. 
<br>
 Otherwise,
              the default C String encoding is used.
            Releases the receiver and returns
              <code>nil</code> if the file could not be read and
              converted to a string.


        



<section name="initWithContentsOfURL:">
<label id="method**NSString**-initWithContentsOfURL:" />- <code>(id) </code>
          <b>initWithContentsOfURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithData:encoding:">
<label id="method**NSString**-initWithData:encoding:" />- <code>(id) </code>
          <b>initWithData: </b>
          <code>(NSData*) </code><i>data </i>
          <b>encoding: </b>
          <code>(NSStringEncoding) </code><i>encoding </i>
          <br>Initialises the receiver with the supplied
            <i>data</i>, using the specified
            <i>encoding</i>. 
<br>
 For
            NSUnicodeStringEncoding and
            NSUTF8String <i>encoding</i>, a Byte Order
            Marker (if present at the start of the
            <i>data</i>) is removed automatically. 
<br>
 If
            the <i>data</i> can not be interpreted using the
            <i>encoding</i>, the receiver is released and
            <code>nil</code> is returned.


        



<section name="initWithFormat:">
<label id="method**NSString**-initWithFormat:" />- <code>(id) </code>
          <b>initWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br>Invokes
            <ref id="method**NSString**-initWithFormat:locale:arguments:">
              -initWithFormat:locale:arguments:
            </ref>
            with a <code>nil</code> locale.


        



<section name="initWithFormat:arguments:">
<label id="method**NSString**-initWithFormat:arguments:" />- <code>(id) </code>
          <b>initWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>arguments: </b>
          <code>(va_list) </code><i>argList </i>
          <br>Invokes
            <ref id="method**NSString**-initWithFormat:locale:arguments:">
              -initWithFormat:locale:arguments:
            </ref>
            with a <code>nil</code> locale.


        



<section name="initWithFormat:locale:">
<label id="method**NSString**-initWithFormat:locale:" />- <code>(id) </code>
          <b>initWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          
          <br>Invokes
            <ref id="method**NSString**-initWithFormat:locale:arguments:">
              -initWithFormat:locale:arguments:
            </ref>


        



<section name="initWithFormat:locale:arguments:">
<label id="method**NSString**-initWithFormat:locale:arguments:" />- <code>(id) </code>
          <b>initWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <b>arguments: </b>
          <code>(va_list) </code><i>argList </i>
          <br>Initialises the string using the specified
            <i>format</i> and <i>locale</i> to
            <i>format</i> the following arguments.


        



<section name="initWithString:">
<label id="method**NSString**-initWithString:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>string </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithUTF8String:">
<label id="method**NSString**-initWithUTF8String:" />- <code>(id) </code>
          <b>initWithUTF8String: </b>
          <code>(const char*) </code><i>bytes </i>
          <br><em>Description forthcoming.</em>


        



<section name="intValue">
<label id="method**NSString**-intValue" />- <code>(int) </code>
          <b>intValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="isAbsolutePath">
<label id="method**NSString**-isAbsolutePath" />- <code>(BOOL) </code>
          <b>isAbsolutePath </b>
          <br><em>Description forthcoming.</em>


        



<section name="isEqual:">
<label id="method**NSString**-isEqual:" />- <code>(BOOL) </code>
          <b>isEqual: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToString:">
<label id="method**NSString**-isEqualToString:" />- <code>(BOOL) </code>
          <b>isEqualToString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="lastPathComponent">
<label id="method**NSString**-lastPathComponent" />- <code>(NSString*) </code>
          <b>lastPathComponent </b>
          <br>Returns a string containing the last path component
            of the receiver. 
<br>
 The path component is the last
            non-empty substring delimited by the ends of the
            string or by path * separator ('/') characters.
            
<br>
 If the receiver is an empty string, it is
            simply returned. 
<br>
 If there are no non-empty
            substrings, the root string is returned.


        



<section name="length">
<label id="method**NSString**-length" />- <code>(unsigned int) </code>
          <b>length </b>
          <br><em>Description forthcoming.</em>


        



<section name="lineRangeForRange:">
<label id="method**NSString**-lineRangeForRange:" />- <code>(NSRange) </code>
          <b>lineRangeForRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Determines the smallest range of lines
            containing <i>aRange</i> and returns the
            information as a range. 
<br>
 Calls
            <ref id="method**NSString**-getLineStart:end:contentsEnd:forRange:">-getLineStart:end:contentsEnd:forRange:</ref> to do the work.


        



<section name="localizedCaseInsensitiveCompare:">
<label id="method**NSString**-localizedCaseInsensitiveCompare:" />- <code>(NSComparisonResult) </code>
          <b>localizedCaseInsensitiveCompare: </b>
          <code>(NSString*) </code><i>string </i>
          <br><em>Description forthcoming.</em>


        



<section name="localizedCompare:">
<label id="method**NSString**-localizedCompare:" />- <code>(NSComparisonResult) </code>
          <b>localizedCompare: </b>
          <code>(NSString*) </code><i>string </i>
          <br><em>Description forthcoming.</em>


        



<section name="lossyCString">
<label id="method**NSString**-lossyCString" />- <code>(const char*) </code>
          <b>lossyCString </b>
          <br><em>Description forthcoming.</em>


        



<section name="lowercaseString">
<label id="method**NSString**-lowercaseString" />- <code>(NSString*) </code>
          <b>lowercaseString </b>
          <br>Returns a copy of the receiver with all characters
            converted to lowercase.


        



<section name="pathComponents">
<label id="method**NSString**-pathComponents" />- <code>(NSArray*) </code>
          <b>pathComponents </b>
          <br>Returns the path components of the reciever
            separated into an array. 
<br>
 If the receiver
            begins with a '/' character then that is used as the
            first element in the array. 
<br>
 Empty components
            are removed.


        



<section name="pathExtension">
<label id="method**NSString**-pathExtension" />- <code>(NSString*) </code>
          <b>pathExtension </b>
          <br>Returns a new string containing the path extension
            of the receiver. 
<br>
 The path extension is a suffix
            on the last path component which starts with the
            extension separator (a '.') (for example.tiff is
            the pathExtension for /foo/bar.tiff). 
<br>
 Returns an
            empty string if no such extension exists.


        



<section name="propertyList">
<label id="method**NSString**-propertyList" />- <code>(id) </code>
          <b>propertyList </b>
          <br>Attempts to interpret the receiver as a
              <em>property list</em> and returns the result. If
              the receiver does not contain a string representation
              of a <em>property list</em> then the method returns
              <code>nil</code>.
            There are three readable <em>property list</em>
              storage formats - The binary format used by
              <ref id="class**NSString**NSSerializer">NSSerializer</ref>
                does not concern us here, but there are two 'human
                readable' formats, the <em>traditional</em>
                OpenStep format (which is extended in GNUstep)
                and the <em>XML</em> format.
              The
                <ref id="method**NSArray**-descriptionWithLocale:indent:">[NSArray% unknown entity: nbsp
-descriptionWithLocale:indent:]</ref> and <ref id="method**NSDictionary**-descriptionWithLocale:indent:">[NSDictionary% unknown entity: nbsp
-descriptionWithLocale:indent:]</ref> methods both generate strings containing traditional style <em>property lists</em>, but <ref id="method**NSArray**-writeToFile:atomically:">[NSArray% unknown entity: nbsp
-writeToFile:atomically:]</ref> and <ref id="method**NSDictionary**-writeToFile:atomically:">[NSDictionary% unknown entity: nbsp
-writeToFile:atomically:]</ref> generate either traditional or XML style <em>property lists</em> depending on the value of the GSMacOSXCompatible and NSWriteOldStylePropertyLists user defaults. 
<br>
 If GSMacOSXCompatible is <code>YES</code> then XML <em>property lists</em> are written unless NSWriteOldStylePropertyLists is also <code>YES</code>. 
<br>
 By default GNUstep writes old style data and always supports reading of either style.
              The traditional format is more compact and more
                easily readable by people, but (without the
                GNUstep extensions) cannot represent date and
                number objects (except as strings). The XML
                format is more verbose and less readable, but
                can be fed into modern XML tools and thus used to
                pass data to non-OpenStep applications more
                readily.
              The traditional format is strictly ascii encoded,
                with any unicode characters represented by escape
                sequences. The XML format is encoded as UTF8
                data.
              Both the traditional format and the XML format
                permit comments to be placed in
                <em>property list</em> documents. In traditional
                format the comment notations used in ObjectiveC
                programming are supported, while in XML
                format, the standard SGML comment sequences are
                used.
              A <em>property list</em> may only be one of the
              following classes -


        



<section name="propertyListFromStringsFileFormat">
<label id="method**NSString**-propertyListFromStringsFileFormat" />- <code>(NSDictionary*) </code>
          <b>propertyListFromStringsFileFormat </b>
          <br>Reads a <em>property list</em> (see -propertyList)
              from a simplified file format. This format is a
              traditional style property list file
              containing a single dictionary, but with the
              leading '{' and trailing '}' characters omitted.
            That is to say, the file contains only semicolon
              separated key/value pairs (and optionally
              comments). As a convenience, it is possible to
              omit the equals sign and the value, so an entry
              consists of a key string followed by a
              semicolon. In this case, the value for that
              key is assumed to be an empty string.


        



<section name="rangeOfCharacterFromSet:">
<label id="method**NSString**-rangeOfCharacterFromSet:" />- <code>(NSRange) </code>
          <b>rangeOfCharacterFromSet: </b>
          <code>(NSCharacterSet*) </code><i>aSet </i>
          <br><em>Description forthcoming.</em>


        



<section name="rangeOfCharacterFromSet:options:">
<label id="method**NSString**-rangeOfCharacterFromSet:options:" />- <code>(NSRange) </code>
          <b>rangeOfCharacterFromSet: </b>
          <code>(NSCharacterSet*) </code><i>aSet </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <br><em>Description forthcoming.</em>


        



<section name="rangeOfCharacterFromSet:options:range:">
<label id="method**NSString**-rangeOfCharacterFromSet:options:range:" />- <code>(NSRange) </code>
          <b>rangeOfCharacterFromSet: </b>
          <code>(NSCharacterSet*) </code><i>aSet </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="rangeOfComposedCharacterSequenceAtIndex:">
<label id="method**NSString**-rangeOfComposedCharacterSequenceAtIndex:" />- <code>(NSRange) </code>
          <b>rangeOfComposedCharacterSequenceAtIndex: </b>
          <code>(unsigned int) </code><i>anIndex </i>
          <br><em>Description forthcoming.</em>


        



<section name="rangeOfString:">
<label id="method**NSString**-rangeOfString:" />- <code>(NSRange) </code>
          <b>rangeOfString: </b>
          <code>(NSString*) </code><i>string </i>
          <br>Invokes
            <ref id="method**NSString**-rangeOfString:options:">
              -rangeOfString:options:
            </ref>
            with the options mask set to zero.


        



<section name="rangeOfString:options:">
<label id="method**NSString**-rangeOfString:options:" />- <code>(NSRange) </code>
          <b>rangeOfString: </b>
          <code>(NSString*) </code><i>string </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <br>Invokes
            <ref id="method**NSString**-rangeOfString:options:range:">
              -rangeOfString:options:range:
            </ref>
            with the range set set to the range of the whole of
            the reciever.


        



<section name="rangeOfString:options:range:">
<label id="method**NSString**-rangeOfString:options:range:" />- <code>(NSRange) </code>
          <b>rangeOfString: </b>
          <code>(NSString*) </code><i>aString </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>mask </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Returns the range giving the location and length of
            the first occurrence of <i>aString</i> within
            <i>aRange</i>. 
<br>
 If <i>aString</i> does
            not exist in the receiver (an empty string is never
            considered to exist in the receiver), the length
            of the returned range is zero. 
<br>
 If
            <i>aString</i> is <code>nil</code>, an exception
            is raised. 
<br>
 If any part of <i>aRange</i> lies
            outside the range of the receiver, an exception is
            raised. 
<br>
 The options <i>mask</i> may
            contain the following options -


        



<section name="smallestEncoding">
<label id="method**NSString**-smallestEncoding" />- <code>(NSStringEncoding) </code>
          <b>smallestEncoding </b>
          <br><em>Description forthcoming.</em>


        



<section name="stringByAbbreviatingWithTildeInPath">
<label id="method**NSString**-stringByAbbreviatingWithTildeInPath" />- <code>(NSString*) </code>
          <b>stringByAbbreviatingWithTildeInPath </b>
          <br>Returns a string where a prefix of the current
            user's home directory is abbreviated by '~', or
            returns the receiver if it was not found to have
            the home directory as a prefix.


        



<section name="stringByAppendingFormat:">
<label id="method**NSString**-stringByAppendingFormat:" />- <code>(NSString*) </code>
          <b>stringByAppendingFormat: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="stringByAppendingPathComponent:">
<label id="method**NSString**-stringByAppendingPathComponent:" />- <code>(NSString*) </code>
          <b>stringByAppendingPathComponent: </b>
          <code>(NSString*) </code><i>aString </i>
          <br>Returns a new string with the path component given
            in <i>aString</i> appended to the receiver. Removes
            trailing separators and multiple separators.


        



<section name="stringByAppendingPathExtension:">
<label id="method**NSString**-stringByAppendingPathExtension:" />- <code>(NSString*) </code>
          <b>stringByAppendingPathExtension: </b>
          <code>(NSString*) </code><i>aString </i>
          <br>Returns a new string with the path extension given
            in <i>aString</i> appended to the receiver after the
            extensionSeparator ('.'). 
<br>
 If the
            receiver has trailing '/' characters which are not
            part of the root directory, those '/' characters are
            stripped before the extension separator is added.


        



<section name="stringByAppendingString:">
<label id="method**NSString**-stringByAppendingString:" />- <code>(NSString*) </code>
          <b>stringByAppendingString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringByDeletingLastPathComponent">
<label id="method**NSString**-stringByDeletingLastPathComponent" />- <code>(NSString*) </code>
          <b>stringByDeletingLastPathComponent </b>
          <br>Returns a new string with the last path component
            (including any final path separators) removed
            from the receiver. 
<br>
 A string without a path
            component other than the root is returned without
            alteration. 
<br>
 See
            <ref id="method**NSString**-lastPathComponent">
              -lastPathComponent
            </ref>
            for a definition of a path component.


        



<section name="stringByDeletingPathExtension">
<label id="method**NSString**-stringByDeletingPathExtension" />- <code>(NSString*) </code>
          <b>stringByDeletingPathExtension </b>
          <br>Returns a new string with the path extension
            removed from the receiver. 
<br>
 Strips any
            trailing path separators before checking for the
            extension separator. 
<br>
 Does not consider a
            string starting with the extension separator ('.')
            to be a path extension.


        



<section name="stringByExpandingTildeInPath">
<label id="method**NSString**-stringByExpandingTildeInPath" />- <code>(NSString*) </code>
          <b>stringByExpandingTildeInPath </b>
          <br>Returns a string created by expanding the initial
            tilde ('~') and any following username to be the home
            directory of the current user or the named user.
            
<br>
 Returns the receiver if it was not possible
            to expand it.


        



<section name="stringByPaddingToLength:withString:startingAtIndex:">
<label id="method**NSString**-stringByPaddingToLength:withString:startingAtIndex:" />- <code>(NSString*) </code>
          <b>stringByPaddingToLength: </b>
          <code>(unsigned int) </code><i>newLength </i>
          <b>withString: </b>
          <code>(NSString*) </code><i>padString </i>
          <b>startingAtIndex: </b>
          <code>(unsigned int) </code><i>padIndex </i>
          <br>Returns a string formed by extending or truncating
            the receiver to <i>newLength</i> characters. If the
            new string is larger, it is padded by appending
            characters from <i>padString</i> (appending
            it as many times as required). The first character from
            <i>padString</i> to be appended is specified by
            <i>padIndex</i>. 
<br>


        



<section name="stringByResolvingSymlinksInPath">
<label id="method**NSString**-stringByResolvingSymlinksInPath" />- <code>(NSString*) </code>
          <b>stringByResolvingSymlinksInPath </b>
          <br><em>Description forthcoming.</em>


        



<section name="stringByStandardizingPath">
<label id="method**NSString**-stringByStandardizingPath" />- <code>(NSString*) </code>
          <b>stringByStandardizingPath </b>
          <br>Returns a standardised form of the receiver, with
            unnecessary parts removed, tilde characters
            expanded, and symbolic links resolved where
            possible. 
<br>
 If the string is an invalid
            path, the unmodified receiver is returned. 
<br>

            Uses
              <ref id="method**NSString**-stringByExpandingTildeInPath">
                -stringByExpandingTildeInPath
              </ref>
              to expand tilde expressions. 
<br>
 Simplifies '//'
              and '/./' sequences. 
<br>
 Removes any '/private'
              prefix.
            For absolute paths, uses
              <ref id="method**NSString**-stringByResolvingSymlinksInPath">-stringByResolvingSymlinksInPath</ref> to resolve any links, then gets rid of '/../' sequences.


        



<section name="stringByTrimmingCharactersInSet:">
<label id="method**NSString**-stringByTrimmingCharactersInSet:" />- <code>(NSString*) </code>
          <b>stringByTrimmingCharactersInSet: </b>
          <code>(NSCharacterSet*) </code><i>aSet </i>
          <br>Return a string formed by removing characters from
            the ends of the receiver. Characters are removed only
            if they are in <i>aSet</i>. 
<br>
 If the string
            consists entirely of characters in <i>aSet</i>
            , an empty string is returned. 
<br>
 The <i>aSet</i>
            argument nust not be <code>nil</code>. 
<br>


        



<section name="stringsByAppendingPaths:">
<label id="method**NSString**-stringsByAppendingPaths:" />- <code>(NSArray*) </code>
          <b>stringsByAppendingPaths: </b>
          <code>(NSArray*) </code><i>paths </i>
          <br>Returns an array of strings made by appending the
            values in <i>paths</i> to the receiver.


        



<section name="substringFromIndex:">
<label id="method**NSString**-substringFromIndex:" />- <code>(NSString*) </code>
          <b>substringFromIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br>Returns a substring of the receiver from character
            at the specified <i>index</i> to the end of the
            string. 
<br>
 So, supplying an <i>index</i> of
            3 would return a substring consisting of the entire
            string apart from the first three character (those
            would be at <i>index</i> 0, 1, and 2). 
<br>
 If
            the supplied <i>index</i> is greater than or equal
            to the length of the receiver an exception is raised.


        



<section name="substringFromRange:">
<label id="method**NSString**-substringFromRange:" />- <code>(NSString*) </code>
          <b>substringFromRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>An obsolete name for
            <ref id="method**NSString**-substringWithRange:">
              -substringWithRange:
            </ref>
            ... deprecated.


        



<section name="substringToIndex:">
<label id="method**NSString**-substringToIndex:" />- <code>(NSString*) </code>
          <b>substringToIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br>Returns a substring of the receiver from the start
            of the string to (but not including) the specified
            <i>index</i> position. 
<br>
 So, supplying an
            <i>index</i> of 3 would return a substring
            consisting of the first three characters of the
            receiver. 
<br>
 If the supplied <i>index</i>
            is greater than the length of the receiver an exception
            is raised.


        



<section name="substringWithRange:">
<label id="method**NSString**-substringWithRange:" />- <code>(NSString*) </code>
          <b>substringWithRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Returns a substring of the receiver containing the
            characters in <i>aRange</i>. 
<br>
 If
            <i>aRange</i> specifies any character position
            not present in the receiver, an exception is raised.
            
<br>
 If <i>aRange</i> has a length of zero, an
            empty string is returned.


        



<section name="uppercaseString">
<label id="method**NSString**-uppercaseString" />- <code>(NSString*) </code>
          <b>uppercaseString </b>
          <br>Returns a copy of the receiver with all characters
            converted to uppercase.


        



<section name="writeToFile:atomically:">
<label id="method**NSString**-writeToFile:atomically:" />- <code>(BOOL) </code>
          <b>writeToFile: </b>
          <code>(NSString*) </code><i>filename </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxiliaryFile </i>
          <br><em>Description forthcoming.</em>


        



<section name="writeToURL:atomically:">
<label id="method**NSString**-writeToURL:atomically:" />- <code>(BOOL) </code>
          <b>writeToURL: </b>
          <code>(NSURL*) </code><i>anURL </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>atomically </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSUndoManager">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSUndoManager">NSUndoManager</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSUndoManager.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="beginUndoGrouping">
<label id="method**NSUndoManager**-beginUndoGrouping" />- <code>(void) </code>
          <b>beginUndoGrouping </b>
          <br><em>Description forthcoming.</em>


        



<section name="canRedo">
<label id="method**NSUndoManager**-canRedo" />- <code>(BOOL) </code>
          <b>canRedo </b>
          <br><em>Description forthcoming.</em>


        



<section name="canUndo">
<label id="method**NSUndoManager**-canUndo" />- <code>(BOOL) </code>
          <b>canUndo </b>
          <br><em>Description forthcoming.</em>


        



<section name="disableUndoRegistration">
<label id="method**NSUndoManager**-disableUndoRegistration" />- <code>(void) </code>
          <b>disableUndoRegistration </b>
          <br><em>Description forthcoming.</em>


        



<section name="enableUndoRegistration">
<label id="method**NSUndoManager**-enableUndoRegistration" />- <code>(void) </code>
          <b>enableUndoRegistration </b>
          <br><em>Description forthcoming.</em>


        



<section name="endUndoGrouping">
<label id="method**NSUndoManager**-endUndoGrouping" />- <code>(void) </code>
          <b>endUndoGrouping </b>
          <br><em>Description forthcoming.</em>


        



<section name="forwardInvocation:">
<label id="method**NSUndoManager**-forwardInvocation:" />- <code>(void) </code>
          <b>forwardInvocation: </b>
          <code>(NSInvocation*) </code><i>anInvocation </i>
          <br><em>Description forthcoming.</em>


        



<section name="groupingLevel">
<label id="method**NSUndoManager**-groupingLevel" />- <code>(int) </code>
          <b>groupingLevel </b>
          <br><em>Description forthcoming.</em>


        



<section name="groupsByEvent">
<label id="method**NSUndoManager**-groupsByEvent" />- <code>(BOOL) </code>
          <b>groupsByEvent </b>
          <br><em>Description forthcoming.</em>


        



<section name="isRedoing">
<label id="method**NSUndoManager**-isRedoing" />- <code>(BOOL) </code>
          <b>isRedoing </b>
          <br><em>Description forthcoming.</em>


        



<section name="isUndoRegistrationEnabled">
<label id="method**NSUndoManager**-isUndoRegistrationEnabled" />- <code>(BOOL) </code>
          <b>isUndoRegistrationEnabled </b>
          <br><em>Description forthcoming.</em>


        



<section name="isUndoing">
<label id="method**NSUndoManager**-isUndoing" />- <code>(BOOL) </code>
          <b>isUndoing </b>
          <br><em>Description forthcoming.</em>


        



<section name="levelsOfUndo">
<label id="method**NSUndoManager**-levelsOfUndo" />- <code>(unsigned int) </code>
          <b>levelsOfUndo </b>
          <br><em>Description forthcoming.</em>


        



<section name="prepareWithInvocationTarget:">
<label id="method**NSUndoManager**-prepareWithInvocationTarget:" />- <code>(id) </code>
          <b>prepareWithInvocationTarget: </b>
          <code>(id) </code><i>target </i>
          <br><em>Description forthcoming.</em>


        



<section name="redo">
<label id="method**NSUndoManager**-redo" />- <code>(void) </code>
          <b>redo </b>
          <br><em>Description forthcoming.</em>


        



<section name="redoActionName">
<label id="method**NSUndoManager**-redoActionName" />- <code>(NSString*) </code>
          <b>redoActionName </b>
          <br><em>Description forthcoming.</em>


        



<section name="redoMenuItemTitle">
<label id="method**NSUndoManager**-redoMenuItemTitle" />- <code>(NSString*) </code>
          <b>redoMenuItemTitle </b>
          <br><em>Description forthcoming.</em>


        



<section name="redoMenuTitleForUndoActionName:">
<label id="method**NSUndoManager**-redoMenuTitleForUndoActionName:" />- <code>(NSString*) </code>
          <b>redoMenuTitleForUndoActionName: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="registerUndoWithTarget:selector:object:">
<label id="method**NSUndoManager**-registerUndoWithTarget:selector:object:" />- <code>(void) </code>
          <b>registerUndoWithTarget: </b>
          <code>(id) </code><i>target </i>
          <b>selector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>object: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="removeAllActions">
<label id="method**NSUndoManager**-removeAllActions" />- <code>(void) </code>
          <b>removeAllActions </b>
          <br><em>Description forthcoming.</em>


        



<section name="removeAllActionsWithTarget:">
<label id="method**NSUndoManager**-removeAllActionsWithTarget:" />- <code>(void) </code>
          <b>removeAllActionsWithTarget: </b>
          <code>(id) </code><i>target </i>
          <br><em>Description forthcoming.</em>


        



<section name="runLoopModes">
<label id="method**NSUndoManager**-runLoopModes" />- <code>(NSArray*) </code>
          <b>runLoopModes </b>
          <br><em>Description forthcoming.</em>


        



<section name="setActionName:">
<label id="method**NSUndoManager**-setActionName:" />- <code>(void) </code>
          <b>setActionName: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="setGroupsByEvent:">
<label id="method**NSUndoManager**-setGroupsByEvent:" />- <code>(void) </code>
          <b>setGroupsByEvent: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="setLevelsOfUndo:">
<label id="method**NSUndoManager**-setLevelsOfUndo:" />- <code>(void) </code>
          <b>setLevelsOfUndo: </b>
          <code>(unsigned) </code><i>num </i>
          <br><em>Description forthcoming.</em>


        



<section name="setRunLoopModes:">
<label id="method**NSUndoManager**-setRunLoopModes:" />- <code>(void) </code>
          <b>setRunLoopModes: </b>
          <code>(NSArray*) </code><i>newModes </i>
          <br><em>Description forthcoming.</em>


        



<section name="undo">
<label id="method**NSUndoManager**-undo" />- <code>(void) </code>
          <b>undo </b>
          <br><em>Description forthcoming.</em>


        



<section name="undoActionName">
<label id="method**NSUndoManager**-undoActionName" />- <code>(NSString*) </code>
          <b>undoActionName </b>
          <br><em>Description forthcoming.</em>


        



<section name="undoMenuItemTitle">
<label id="method**NSUndoManager**-undoMenuItemTitle" />- <code>(NSString*) </code>
          <b>undoMenuItemTitle </b>
          <br><em>Description forthcoming.</em>


        



<section name="undoMenuTitleForUndoActionName:">
<label id="method**NSUndoManager**-undoMenuTitleForUndoActionName:" />- <code>(NSString*) </code>
          <b>undoMenuTitleForUndoActionName: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="undoNestedGroup">
<label id="method**NSUndoManager**-undoNestedGroup" />- <code>(void) </code>
          <b>undoNestedGroup </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSMutableData">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableData">NSMutableData</ref>: <ref id="NSData">NSData</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSData.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="dataWithCapacity:">
<label id="method**NSMutableData**+dataWithCapacity:" />+ <code>(id) </code>
          <b>dataWithCapacity: </b>
          <code>(unsigned int) </code><i>numBytes </i>
          <br><em>Description forthcoming.</em>


        



<section name="dataWithLength:">
<label id="method**NSMutableData**+dataWithLength:" />+ <code>(id) </code>
          <b>dataWithLength: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="appendBytes:length:">
<label id="method**NSMutableData**-appendBytes:length:" />- <code>(void) </code>
          <b>appendBytes: </b>
          <code>(const void*) </code><i>aBuffer </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>bufferSize </i>
          <br><em>Description forthcoming.</em>


        



<section name="appendData:">
<label id="method**NSMutableData**-appendData:" />- <code>(void) </code>
          <b>appendData: </b>
          <code>(NSData*) </code><i>other </i>
          <br><em>Description forthcoming.</em>


        



<section name="increaseLengthBy:">
<label id="method**NSMutableData**-increaseLengthBy:" />- <code>(void) </code>
          <b>increaseLengthBy: </b>
          <code>(unsigned int) </code><i>extraLength </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCapacity:">
<label id="method**NSMutableData**-initWithCapacity:" />- <code>(id) </code>
          <b>initWithCapacity: </b>
          <code>(unsigned int) </code><i>capacity </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithLength:">
<label id="method**NSMutableData**-initWithLength:" />- <code>(id) </code>
          <b>initWithLength: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="mutableBytes">
<label id="method**NSMutableData**-mutableBytes" />- <code>(void*) </code>
          <b>mutableBytes </b>
          <br>Returns a pointer to the data storage of the
              receiver. 
<br>
 Modifications to the memory
              pointed to by this pointer will change the
              contents of the object. It is important that
              your code should not try to modify the memory beyond
              the number of bytes given by the
              <code><ref id="method**NSMutableData**-length">
                  -length
                </ref></code>
              method.
            NB. if the object is released, or any method that
              changes its size or content is called, then the
              pointer previously returned by this method may
              cease to be valid.
            This is a 'primitive' method... you need to
              implement it if you write a subclass of
              NSMutableData.


        



<section name="replaceBytesInRange:withBytes:">
<label id="method**NSMutableData**-replaceBytesInRange:withBytes:" />- <code>(void) </code>
          <b>replaceBytesInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>withBytes: </b>
          <code>(const void*) </code><i>bytes </i>
          <br>Replaces the <i>bytes</i> of data in the
            specified range with a copy of the new
            <i>bytes</i> supplied. 
<br>
 If the location of
            the range specified lies beyond the end of the data (
            <code>[self length] % unknown entity: lt
 range.location</code>) then
            a range exception is raised. 
<br>
 Otherwise, if the
            range specified extends beyond the end of the data,
            then the size of the data is increased to accomodate
            the new <i>bytes</i>. 
<br>


        



<section name="replaceBytesInRange:withBytes:length:">
<label id="method**NSMutableData**-replaceBytesInRange:withBytes:length:" />- <code>(void) </code>
          <b>replaceBytesInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>withBytes: </b>
          <code>(const void*) </code><i>bytes </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br>Replace the content of the receiver which lies in
            <i>aRange</i> with the specified
            <i>length</i> of data from the buffer pointed to
            by <i>bytes</i>. 
<br>
 The size of the receiver is
            adjusted to allow for the change.


        



<section name="resetBytesInRange:">
<label id="method**NSMutableData**-resetBytesInRange:" />- <code>(void) </code>
          <b>resetBytesInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="serializeAlignedBytesLength:">
<label id="method**NSMutableData**-serializeAlignedBytesLength:" />- <code>(void) </code>
          <b>serializeAlignedBytesLength: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="serializeDataAt:ofObjCType:context:">
<label id="method**NSMutableData**-serializeDataAt:ofObjCType:context:" />- <code>(void) </code>
          <b>serializeDataAt: </b>
          <code>(const void*) </code><i>data </i>
          <b>ofObjCType: </b>
          <code>(const char*) </code><i>type </i>
          <b>context: </b>
          <code>(id&#60;NSObjCTypeSerializationCallBack>) </code><i>callback </i>
          <br><em>Description forthcoming.</em>


        



<section name="serializeInt:">
<label id="method**NSMutableData**-serializeInt:" />- <code>(void) </code>
          <b>serializeInt: </b>
          <code>(int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="serializeInt:atIndex:">
<label id="method**NSMutableData**-serializeInt:atIndex:" />- <code>(void) </code>
          <b>serializeInt: </b>
          <code>(int) </code><i>value </i>
          <b>atIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="serializeInts:count:">
<label id="method**NSMutableData**-serializeInts:count:" />- <code>(void) </code>
          <b>serializeInts: </b>
          <code>(int*) </code><i>intBuffer </i>
          <b>count: </b>
          <code>(unsigned int) </code><i>numInts </i>
          <br><em>Description forthcoming.</em>


        



<section name="serializeInts:count:atIndex:">
<label id="method**NSMutableData**-serializeInts:count:atIndex:" />- <code>(void) </code>
          <b>serializeInts: </b>
          <code>(int*) </code><i>intBuffer </i>
          <b>count: </b>
          <code>(unsigned int) </code><i>numInts </i>
          <b>atIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="setData:">
<label id="method**NSMutableData**-setData:" />- <code>(void) </code>
          <b>setData: </b>
          <code>(NSData*) </code><i>data </i>
          <br><em>Description forthcoming.</em>


        



<section name="setLength:">
<label id="method**NSMutableData**-setLength:" />- <code>(void) </code>
          <b>setLength: </b>
          <code>(unsigned int) </code><i>size </i>
          <br>Sets the length of the NSMutableData object. If the
              length is increased, the newly allocated data area
              is filled with zero bytes.
            This is a 'primitive' method... you need to
              implement it if you write a subclass of
              NSMutableData.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSMethodSignature">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMethodSignature">NSMethodSignature</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSMethodSignature.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="signatureWithObjCTypes:">
<label id="method**NSMethodSignature**+signatureWithObjCTypes:" />+ <code>(NSMethodSignature*) </code>
          <b>signatureWithObjCTypes: </b>
          <code>(const char*) </code><i>t </i>
          <br><em>Description forthcoming.</em>


        



<section name="argumentInfoAtIndex:">
<label id="method**NSMethodSignature**-argumentInfoAtIndex:" />- <code>(NSArgumentInfo) </code>
          <b>argumentInfoAtIndex: </b>
          <code>(unsigned) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="frameLength">
<label id="method**NSMethodSignature**-frameLength" />- <code>(unsigned) </code>
          <b>frameLength </b>
          <br><em>Description forthcoming.</em>


        



<section name="getArgumentTypeAtIndex:">
<label id="method**NSMethodSignature**-getArgumentTypeAtIndex:" />- <code>(const char*) </code>
          <b>getArgumentTypeAtIndex: </b>
          <code>(unsigned) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="isOneway">
<label id="method**NSMethodSignature**-isOneway" />- <code>(BOOL) </code>
          <b>isOneway </b>
          <br><em>Description forthcoming.</em>


        



<section name="methodReturnLength">
<label id="method**NSMethodSignature**-methodReturnLength" />- <code>(unsigned) </code>
          <b>methodReturnLength </b>
          <br><em>Description forthcoming.</em>


        



<section name="methodReturnType">
<label id="method**NSMethodSignature**-methodReturnType" />- <code>(const char*) </code>
          <b>methodReturnType </b>
          <br><em>Description forthcoming.</em>


        



<section name="numberOfArguments">
<label id="method**NSMethodSignature**-numberOfArguments" />- <code>(unsigned) </code>
          <b>numberOfArguments </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSUCharNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSUCharNumber">NSUCharNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSCharacterSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSCharacterSet">NSCharacterSet</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSMutableCopying
<br><b>Declared in: </b>NSCharacterSet.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="alphanumericCharacterSet">
<label id="method**NSCharacterSet**+alphanumericCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>alphanumericCharacterSet </b>
          <br><em>Description forthcoming.</em>


        



<section name="characterSetWithBitmapRepresentation:">
<label id="method**NSCharacterSet**+characterSetWithBitmapRepresentation:" />+ <code>(NSCharacterSet*) </code>
          <b>characterSetWithBitmapRepresentation: </b>
          <code>(NSData*) </code><i>data </i>
          <br>Returns a character set containing characters as
            encoded in the <i>data</i> object.


        



<section name="characterSetWithCharactersInString:">
<label id="method**NSCharacterSet**+characterSetWithCharactersInString:" />+ <code>(NSCharacterSet*) </code>
          <b>characterSetWithCharactersInString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="characterSetWithContentsOfFile:">
<label id="method**NSCharacterSet**+characterSetWithContentsOfFile:" />+ <code>(NSCharacterSet*) </code>
          <b>characterSetWithContentsOfFile: </b>
          <code>(NSString*) </code><i>aFile </i>
          <br><em>Description forthcoming.</em>


        



<section name="characterSetWithRange:">
<label id="method**NSCharacterSet**+characterSetWithRange:" />+ <code>(NSCharacterSet*) </code>
          <b>characterSetWithRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="controlCharacterSet">
<label id="method**NSCharacterSet**+controlCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>controlCharacterSet </b>
          <br><em>Description forthcoming.</em>


        



<section name="decimalDigitCharacterSet">
<label id="method**NSCharacterSet**+decimalDigitCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>decimalDigitCharacterSet </b>
          <br>Returns a character set containing characters that
            represent the decimal digits 0 through 9.


        



<section name="decomposableCharacterSet">
<label id="method**NSCharacterSet**+decomposableCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>decomposableCharacterSet </b>
          <br>Returns a character set containing individual
            charactars that can be represented also by a
            composed character sequence.


        



<section name="illegalCharacterSet">
<label id="method**NSCharacterSet**+illegalCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>illegalCharacterSet </b>
          <br>Returns a character set containing unassigned
            (illegal) character values.


        



<section name="letterCharacterSet">
<label id="method**NSCharacterSet**+letterCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>letterCharacterSet </b>
          <br><em>Description forthcoming.</em>


        



<section name="lowercaseLetterCharacterSet">
<label id="method**NSCharacterSet**+lowercaseLetterCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>lowercaseLetterCharacterSet </b>
          <br>Returns a character set that contains the lowercase
            characters. This set does not include caseless
            characters, only those that have corresponding
            characters in uppercase and/or titlecase.


        



<section name="nonBaseCharacterSet">
<label id="method**NSCharacterSet**+nonBaseCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>nonBaseCharacterSet </b>
          <br><em>Description forthcoming.</em>


        



<section name="punctuationCharacterSet">
<label id="method**NSCharacterSet**+punctuationCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>punctuationCharacterSet </b>
          <br><em>Description forthcoming.</em>


        



<section name="symbolAndOperatorCharacterSet">
<label id="method**NSCharacterSet**+symbolAndOperatorCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>symbolAndOperatorCharacterSet </b>
          <br><em>Description forthcoming.</em>


        



<section name="uppercaseLetterCharacterSet">
<label id="method**NSCharacterSet**+uppercaseLetterCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>uppercaseLetterCharacterSet </b>
          <br>Returns a character set that contains the uppercase
            characters. This set does not include caseless
            characters, only those that have corresponding
            characters in lowercase and/or titlecase.


        



<section name="whitespaceAndNewlineCharacterSet">
<label id="method**NSCharacterSet**+whitespaceAndNewlineCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>whitespaceAndNewlineCharacterSet </b>
          <br>Returns a character set that contains the
            whitespace characters, plus the newline
            characters, values 0x000A and 0x000D.


        



<section name="whitespaceCharacterSet">
<label id="method**NSCharacterSet**+whitespaceCharacterSet" />+ <code>(NSCharacterSet*) </code>
          <b>whitespaceCharacterSet </b>
          <br>Returns a character set that contains the
            whitespace characters.


        



<section name="bitmapRepresentation">
<label id="method**NSCharacterSet**-bitmapRepresentation" />- <code>(NSData*) </code>
          <b>bitmapRepresentation </b>
          <br>Returns a bitmap representation of the receiver's
            character set suitable for archiving or writing
            to a file, in an NSData object.


        



<section name="characterIsMember:">
<label id="method**NSCharacterSet**-characterIsMember:" />- <code>(BOOL) </code>
          <b>characterIsMember: </b>
          <code>(unichar) </code><i>aCharacter </i>
          <br>Returns <code>YES</code> if the receiver contains
            <em><i>aCharacter</i></em>, <code>NO</code> if it
            does not.


        



<section name="invertedSet">
<label id="method**NSCharacterSet**-invertedSet" />- <code>(NSCharacterSet*) </code>
          <b>invertedSet </b>
          <br>Returns a character set containing only characters
            that the receiver does not contain.


        


</section>


</chapter>


<chapter name="NSTask">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSTask">NSTask</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>GCFinalization
<br><b>Declared in: </b>NSTask.h
</section>

<section name="Description">
<br>The NSTask class provides a mechanism to run separate
          tasks under (limited) control of your program.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="launchedTaskWithLaunchPath:arguments:">
<label id="method**NSTask**+launchedTaskWithLaunchPath:arguments:" />+ <code>(NSTask*) </code>
          <b>launchedTaskWithLaunchPath: </b>
          <code>(NSString*) </code><i>path </i>
          <b>arguments: </b>
          <code>(NSArray*) </code><i>args </i>
          <br>Creates and launches a task, returning an
            autoreleased task object. Supplies the
            <i>path</i> to the executable and an array of
            argument. The task inherits the parents
            environment and I/O.


        



<section name="arguments">
<label id="method**NSTask**-arguments" />- <code>(NSArray*) </code>
          <b>arguments </b>
          <br>Returns the arguments set for the task.


        



<section name="currentDirectoryPath">
<label id="method**NSTask**-currentDirectoryPath" />- <code>(NSString*) </code>
          <b>currentDirectoryPath </b>
          <br>Returns the working directory set for the task.


        



<section name="environment">
<label id="method**NSTask**-environment" />- <code>(NSDictionary*) </code>
          <b>environment </b>
          <br>Returns the environment set for the task.


        



<section name="interrupt">
<label id="method**NSTask**-interrupt" />- <code>(void) </code>
          <b>interrupt </b>
          <br>Sends an interrupt signal to the receiver and any
            subtasks. 
<br>
 If the task has not been
            launched, raises an NSInvalidArgumentException.
            
<br>
 Has no effect on a task that has already
            terminated. 
<br>
 This is rather like the
            terminate method, but the child process may not
            choose to terminate in response to an interrupt.


        



<section name="isRunning">
<label id="method**NSTask**-isRunning" />- <code>(BOOL) </code>
          <b>isRunning </b>
          <br>Checks to see if the task is currently running.


        



<section name="launch">
<label id="method**NSTask**-launch" />- <code>(void) </code>
          <b>launch </b>
          <br>Launches the task. 
<br>
 Raises an
            NSInvalidArgumentException if
            the launch path is not set or if the subtask cannot be
            started for some reason (eg. the executable does
            not exist).


        



<section name="launchPath">
<label id="method**NSTask**-launchPath" />- <code>(NSString*) </code>
          <b>launchPath </b>
          <br>Returns the launch path set for the task.


        



<section name="processIdentifier">
<label id="method**NSTask**-processIdentifier" />- <code>(int) </code>
          <b>processIdentifier </b>
          <br>Returns the number identifying the child process on
            this system.


        



<section name="resume">
<label id="method**NSTask**-resume" />- <code>(BOOL) </code>
          <b>resume </b>
          <br>Sends a cont signal to the receiver and any subtasks.
            
<br>
 If the task has not been launched, raises an
            NSInvalidArgumentException.
            
<br>


        



<section name="setArguments:">
<label id="method**NSTask**-setArguments:" />- <code>(void) </code>
          <b>setArguments: </b>
          <code>(NSArray*) </code><i>args </i>
          <br>Sets an array of arguments to be supplied to the task
            when it is launched. The default is an empty array.
            This method cannot be used after a task is launched...
            it raises an NSInvalidArgumentException.


        



<section name="setCurrentDirectoryPath:">
<label id="method**NSTask**-setCurrentDirectoryPath:" />- <code>(void) </code>
          <b>setCurrentDirectoryPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Sets the home directory in which the task is to be
            run. The default is the parent processes directory.
            This method cannot be used after a task is launched...
            it raises an NSInvalidArgumentException.


        



<section name="setEnvironment:">
<label id="method**NSTask**-setEnvironment:" />- <code>(void) </code>
          <b>setEnvironment: </b>
          <code>(NSDictionary*) </code><i>env </i>
          <br>Sets the environment variables for the task to be run.
            The default is the parent processes environment. This
            method cannot be used after a task is launched... it
            raises an NSInvalidArgumentException.


        



<section name="setLaunchPath:">
<label id="method**NSTask**-setLaunchPath:" />- <code>(void) </code>
          <b>setLaunchPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Sets the <i>path</i> to the executable file to be
            run. There is no default for this - you must set the
            launch <i>path</i>. This method cannot be used
            after a task is launched... it raises an
            NSInvalidArgumentException.


        



<section name="setStandardError:">
<label id="method**NSTask**-setStandardError:" />- <code>(void) </code>
          <b>setStandardError: </b>
          <code>(id) </code><i>hdl </i>
          <br>Sets the standard error stream for the task. 
<br>

            This is normally a writable NSFileHandle object. If
            this is an NSPipe, the write end of the pipe is
            automatically closed on launching. 
<br>
 The
            default behavior is to inherit the parent processes
            stderr output. 
<br>
 This method cannot be used
            after a task is launched... it raises an
            NSInvalidArgumentException.


        



<section name="setStandardInput:">
<label id="method**NSTask**-setStandardInput:" />- <code>(void) </code>
          <b>setStandardInput: </b>
          <code>(id) </code><i>hdl </i>
          <br>Sets the standard input stream for the task. 
<br>

            This is normally a readable NSFileHandle object. If
            this is an NSPipe, the read end of the pipe is
            automatically closed on launching. 
<br>
 The
            default behavior is to inherit the parent processes
            stdin stream. 
<br>
 This method cannot be used after
            a task is launched... it raises an
            NSInvalidArgumentException.


        



<section name="setStandardOutput:">
<label id="method**NSTask**-setStandardOutput:" />- <code>(void) </code>
          <b>setStandardOutput: </b>
          <code>(id) </code><i>hdl </i>
          <br>Sets the standard output stream for the task. 
<br>

            This is normally a writable NSFileHandle object. If
            this is an NSPipe, the write end of the pipe is
            automatically closed on launching. 
<br>
 The
            default behavior is to inherit the parent processes
            stdout stream. 
<br>
 This method cannot be used
            after a task is launched... it raises an
            NSInvalidArgumentException.


        



<section name="standardError">
<label id="method**NSTask**-standardError" />- <code>(id) </code>
          <b>standardError </b>
          <br>Returns the standard error stream for the task - an
            NSFileHandle unless an NSPipe was passed to
            <ref id="method**NSTask**-setStandardError:">
              -setStandardError:
            </ref>


        



<section name="standardInput">
<label id="method**NSTask**-standardInput" />- <code>(id) </code>
          <b>standardInput </b>
          <br>Returns the standard input stream for the task - an
            NSFileHandle unless an NSPipe was passed to
            <ref id="method**NSTask**-setStandardInput:">
              -setStandardInput:
            </ref>


        



<section name="standardOutput">
<label id="method**NSTask**-standardOutput" />- <code>(id) </code>
          <b>standardOutput </b>
          <br>Returns the standard output stream for the task -
            an NSFileHandle unless an NSPipe was passed to
            <ref id="method**NSTask**-setStandardOutput:">
              -setStandardOutput:
            </ref>


        



<section name="suspend">
<label id="method**NSTask**-suspend" />- <code>(BOOL) </code>
          <b>suspend </b>
          <br>Sends a stop signal to the receiver and any subtasks.
            
<br>
 If the task has not been launched, raises an
            NSInvalidArgumentException.
            
<br>


        



<section name="terminate">
<label id="method**NSTask**-terminate" />- <code>(void) </code>
          <b>terminate </b>
          <br>Sends a terminate signal to the receiver and any
            subtasks. 
<br>
 If the task has not been
            launched, raises an NSInvalidArgumentException.
            
<br>
 Has no effect on a task that has already
            terminated. 
<br>
 When a task temrinates,
            either due to this method being called, or normal
            termination, an NSTaskDidTerminateNotification
            is posted.


        



<section name="terminationStatus">
<label id="method**NSTask**-terminationStatus" />- <code>(int) </code>
          <b>terminationStatus </b>
          <br>Returns the termination status of the task. 
<br>

            If the task has not completed running, raises an
            NSInvalidArgumentException.


        



<section name="usePseudoTerminal">
<label id="method**NSTask**-usePseudoTerminal" />- <code>(BOOL) </code>
          <b>usePseudoTerminal </b>
          <br>If the system supports it, this method sets the standard
            input, output, and error streams to a
            pseudo-terminal so that, when launched, the
            child task will act as if it was running
            interactively on a terminal. The file handles
            can then be used to communicate with the child. 
<br>

            This method cannot be used after a task is launched...
            it raises an NSInvalidArgumentException. 
<br>
 The
            standard input, output and error streams cannot be
            changed after calling this method. 
<br>
 The
            method returns <code>YES</code> on success,
            <code>NO</code> on failure.


        



<section name="validatedLaunchPath">
<label id="method**NSTask**-validatedLaunchPath" />- <code>(NSString*) </code>
          <b>validatedLaunchPath </b>
          <br>Returns a validated launch path or <code>nil</code>
            . 
<br>
 Allows for the GNUstep host/operating system,
            and library combination subdirectories in a path,
            appending them as necessary to try to locate the
            actual binary to be used. 
<br>
 Checks that the
            binary file exists and is executable. 
<br>
 Even
            tries searching the directories in the PATH
            environment variable to locate a binary if the
            original alunch path set was not absolute.


        



<section name="waitUntilExit">
<label id="method**NSTask**-waitUntilExit" />- <code>(void) </code>
          <b>waitUntilExit </b>
          <br>Suspends the current thread until the task
            terminates, by waiting in NSRunLoop
            (NSDefaultRunLoopMode) for the task
            termination. 
<br>
 Returns immediately if the
            task is not running.


        


</section>


</chapter>


<chapter name="NSFileHandle">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSFileHandle">NSFileHandle</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSFileHandle.h
</section>

<section name="Description">
<br>NSFileHandler is a Class that provides a
            wrapper for accessing system files and other
            connections. You can open connections to a
            file using class methods such as
            <ref id="method**NSFileHandle**+fileHandleForReadingAtPath:">
              +fileHandleForReadingAtPath:
            </ref>
            .
          GNUstep extends the use of this Class to allow you
            to create network connections (sockets), secure
            connections and also allows you to use
            compression with these files and connections
            (as long as GNUstep Base was compiled with the zlib
            library).


</section>

<section name="Methods">


<section name="fileHandleForReadingAtPath:">
<label id="method**NSFileHandle**+fileHandleForReadingAtPath:" />+ <code>(id) </code>
          <b>fileHandleForReadingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns an NSFileHandle object setup for reading
            from the file listed at <i>path</i>. If the file
            does not exist or cannot be opened for some other
            reason, <code>nil</code> is returned.


        



<section name="fileHandleForUpdatingAtPath:">
<label id="method**NSFileHandle**+fileHandleForUpdatingAtPath:" />+ <code>(id) </code>
          <b>fileHandleForUpdatingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns an NSFileHandle object setup for updating
            (reading and writing) from the file listed at
            <i>path</i>. If the file does not exist or cannot
            be opened for some other reason, <code>nil</code> is
            returned.


        



<section name="fileHandleForWritingAtPath:">
<label id="method**NSFileHandle**+fileHandleForWritingAtPath:" />+ <code>(id) </code>
          <b>fileHandleForWritingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Returns an NSFileHandle object setup for writing to
            the file listed at <i>path</i>. If the file does
            not exist or cannot be opened for some other reason,
            <code>nil</code> is returned.


        



<section name="fileHandleWithNullDevice">
<label id="method**NSFileHandle**+fileHandleWithNullDevice" />+ <code>(id) </code>
          <b>fileHandleWithNullDevice </b>
          <br>Returns a file handle object that is connected to
            the null device (i.e. a device that does nothing.) It
            is typically used in arrays and other collections of
            file handle objects as a place holder (null) object,
            so that all objects can respond to the same messages.


        



<section name="fileHandleWithStandardError">
<label id="method**NSFileHandle**+fileHandleWithStandardError" />+ <code>(id) </code>
          <b>fileHandleWithStandardError </b>
          <br>Returns an NSFileHandle object for the standard
            error descriptor. The returned object is a shared
            instance as there can only be one standard error
            per process.


        



<section name="fileHandleWithStandardInput">
<label id="method**NSFileHandle**+fileHandleWithStandardInput" />+ <code>(id) </code>
          <b>fileHandleWithStandardInput </b>
          <br>Returns an NSFileHandle object for the standard
            input descriptor. The returned object is a shared
            instance as there can only be one standard input
            per process.


        



<section name="fileHandleWithStandardOutput">
<label id="method**NSFileHandle**+fileHandleWithStandardOutput" />+ <code>(id) </code>
          <b>fileHandleWithStandardOutput </b>
          <br>Returns an NSFileHandle object for the standard
            output descriptor. The returned object is a shared
            instance as there can only be one standard output
            per process.


        



<section name="acceptConnectionInBackgroundAndNotify">
<label id="method**NSFileHandle**-acceptConnectionInBackgroundAndNotify" />- <code>(void) </code>
          <b>acceptConnectionInBackgroundAndNotify </b>
          <br><em>Description forthcoming.</em>


        



<section name="acceptConnectionInBackgroundAndNotifyForModes:">
<label id="method**NSFileHandle**-acceptConnectionInBackgroundAndNotifyForModes:" />- <code>(void) </code>
          <b>acceptConnectionInBackgroundAndNotifyForModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br><em>Description forthcoming.</em>


        



<section name="availableData">
<label id="method**NSFileHandle**-availableData" />- <code>(NSData*) </code>
          <b>availableData </b>
          <br><em>Description forthcoming.</em>


        



<section name="closeFile">
<label id="method**NSFileHandle**-closeFile" />- <code>(void) </code>
          <b>closeFile </b>
          <br><em>Description forthcoming.</em>


        



<section name="fileDescriptor">
<label id="method**NSFileHandle**-fileDescriptor" />- <code>(int) </code>
          <b>fileDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithFileDescriptor:">
<label id="method**NSFileHandle**-initWithFileDescriptor:" />- <code>(id) </code>
          <b>initWithFileDescriptor: </b>
          <code>(int) </code><i>desc </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithFileDescriptor:closeOnDealloc:">
<label id="method**NSFileHandle**-initWithFileDescriptor:closeOnDealloc:" />- <code>(id) </code>
          <b>initWithFileDescriptor: </b>
          <code>(int) </code><i>desc </i>
          <b>closeOnDealloc: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithNativeHandle:">
<label id="method**NSFileHandle**-initWithNativeHandle:" />- <code>(id) </code>
          <b>initWithNativeHandle: </b>
          <code>(void*) </code><i>hdl </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithNativeHandle:closeOnDealloc:">
<label id="method**NSFileHandle**-initWithNativeHandle:closeOnDealloc:" />- <code>(id) </code>
          <b>initWithNativeHandle: </b>
          <code>(void*) </code><i>hdl </i>
          <b>closeOnDealloc: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="nativeHandle">
<label id="method**NSFileHandle**-nativeHandle" />- <code>(void*) </code>
          <b>nativeHandle </b>
          <br><em>Description forthcoming.</em>


        



<section name="offsetInFile">
<label id="method**NSFileHandle**-offsetInFile" />- <code>(unsigned long long) </code>
          <b>offsetInFile </b>
          <br><em>Description forthcoming.</em>


        



<section name="readDataOfLength:">
<label id="method**NSFileHandle**-readDataOfLength:" />- <code>(NSData*) </code>
          <b>readDataOfLength: </b>
          <code>(unsigned int) </code><i>len </i>
          <br><em>Description forthcoming.</em>


        



<section name="readDataToEndOfFile">
<label id="method**NSFileHandle**-readDataToEndOfFile" />- <code>(NSData*) </code>
          <b>readDataToEndOfFile </b>
          <br><em>Description forthcoming.</em>


        



<section name="readInBackgroundAndNotify">
<label id="method**NSFileHandle**-readInBackgroundAndNotify" />- <code>(void) </code>
          <b>readInBackgroundAndNotify </b>
          <br>Call
            <ref id="method**NSFileHandle**-readInBackgroundAndNotifyForModes:">-readInBackgroundAndNotifyForModes:</ref> with <code>nil</code> modes.


        



<section name="readInBackgroundAndNotifyForModes:">
<label id="method**NSFileHandle**-readInBackgroundAndNotifyForModes:" />- <code>(void) </code>
          <b>readInBackgroundAndNotifyForModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br>Set up an asynchonous read operation which will cause a
            notification to be sent when any amount of
            data (or end of file) is read. Note that the file
            handle will not continuously send notifications when
            data is available. If you want to continue to receive
            notifications, you need to send this message
            again after receiving a notification.


        



<section name="readToEndOfFileInBackgroundAndNotify">
<label id="method**NSFileHandle**-readToEndOfFileInBackgroundAndNotify" />- <code>(void) </code>
          <b>readToEndOfFileInBackgroundAndNotify </b>
          <br>Call
            <ref id="method**NSFileHandle**-readToEndOfFileInBackgroundAndNotifyForModes:">-readToEndOfFileInBackgroundAndNotifyForModes:</ref> with <code>nil</code> modes.


        



<section name="readToEndOfFileInBackgroundAndNotifyForModes:">
<label id="method**NSFileHandle**-readToEndOfFileInBackgroundAndNotifyForModes:" />- <code>(void) </code>
          <b>readToEndOfFileInBackgroundAndNotifyForModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br>Set up an asynchonous read operation which will cause a
            notification to be sent when end of file is
            read.


        



<section name="seekToEndOfFile">
<label id="method**NSFileHandle**-seekToEndOfFile" />- <code>(unsigned long long) </code>
          <b>seekToEndOfFile </b>
          <br><em>Description forthcoming.</em>


        



<section name="seekToFileOffset:">
<label id="method**NSFileHandle**-seekToFileOffset:" />- <code>(void) </code>
          <b>seekToFileOffset: </b>
          <code>(unsigned long long) </code><i>pos </i>
          <br><em>Description forthcoming.</em>


        



<section name="synchronizeFile">
<label id="method**NSFileHandle**-synchronizeFile" />- <code>(void) </code>
          <b>synchronizeFile </b>
          <br><em>Description forthcoming.</em>


        



<section name="truncateFileAtOffset:">
<label id="method**NSFileHandle**-truncateFileAtOffset:" />- <code>(void) </code>
          <b>truncateFileAtOffset: </b>
          <code>(unsigned long long) </code><i>pos </i>
          <br><em>Description forthcoming.</em>


        



<section name="waitForDataInBackgroundAndNotify">
<label id="method**NSFileHandle**-waitForDataInBackgroundAndNotify" />- <code>(void) </code>
          <b>waitForDataInBackgroundAndNotify </b>
          <br>Call
            <ref id="method**NSFileHandle**-waitForDataInBackgroundAndNotifyForModes:">-waitForDataInBackgroundAndNotifyForModes:</ref> with <code>nil</code> modes.


        



<section name="waitForDataInBackgroundAndNotifyForModes:">
<label id="method**NSFileHandle**-waitForDataInBackgroundAndNotifyForModes:" />- <code>(void) </code>
          <b>waitForDataInBackgroundAndNotifyForModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br>Set up to provide a notification when data can be read
            from the handle.


        



<section name="writeData:">
<label id="method**NSFileHandle**-writeData:" />- <code>(void) </code>
          <b>writeData: </b>
          <code>(NSData*) </code><i>item </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="WindowsFileHandle">


<section name="Overview">
<b>Inherits From:  </b><ref id="WindowsFileHandle">WindowsFileHandle</ref>: <ref id="NSFileHandle">NSFileHandle</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>RunLoopEvents
<br><b>Declared in: </b>WindowsFileHandle.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="checkAccept">
<label id="method**WindowsFileHandle**-checkAccept" />- <code>(void) </code>
          <b>checkAccept </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkConnect">
<label id="method**WindowsFileHandle**-checkConnect" />- <code>(void) </code>
          <b>checkConnect </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkRead">
<label id="method**WindowsFileHandle**-checkRead" />- <code>(void) </code>
          <b>checkRead </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkWrite">
<label id="method**WindowsFileHandle**-checkWrite" />- <code>(void) </code>
          <b>checkWrite </b>
          <br><em>Description forthcoming.</em>


        



<section name="ignoreReadDescriptor">
<label id="method**WindowsFileHandle**-ignoreReadDescriptor" />- <code>(void) </code>
          <b>ignoreReadDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="ignoreWriteDescriptor">
<label id="method**WindowsFileHandle**-ignoreWriteDescriptor" />- <code>(void) </code>
          <b>ignoreWriteDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="initAsClientAtAddress:service:protocol:">
<label id="method**WindowsFileHandle**-initAsClientAtAddress:service:protocol:" />- <code>(id) </code>
          <b>initAsClientAtAddress: </b>
          <code>(id) </code><i>address </i>
          <b>service: </b>
          <code>(id) </code><i>service </i>
          <b>protocol: </b>
          <code>(id) </code><i>protocol </i>
          <br><em>Description forthcoming.</em>


        



<section name="initAsClientInBackgroundAtAddress:service:protocol:forModes:">
<label id="method**WindowsFileHandle**-initAsClientInBackgroundAtAddress:service:protocol:forModes:" />- <code>(id) </code>
          <b>initAsClientInBackgroundAtAddress: </b>
          <code>(id) </code><i>address </i>
          <b>service: </b>
          <code>(id) </code><i>service </i>
          <b>protocol: </b>
          <code>(id) </code><i>protocol </i>
          <b>forModes: </b>
          <code>(id) </code><i>modes </i>
          <br><em>Description forthcoming.</em>


        



<section name="initAsServerAtAddress:service:protocol:">
<label id="method**WindowsFileHandle**-initAsServerAtAddress:service:protocol:" />- <code>(id) </code>
          <b>initAsServerAtAddress: </b>
          <code>(id) </code><i>address </i>
          <b>service: </b>
          <code>(id) </code><i>service </i>
          <b>protocol: </b>
          <code>(id) </code><i>protocol </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForReadingAtPath:">
<label id="method**WindowsFileHandle**-initForReadingAtPath:" />- <code>(id) </code>
          <b>initForReadingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForUpdatingAtPath:">
<label id="method**WindowsFileHandle**-initForUpdatingAtPath:" />- <code>(id) </code>
          <b>initForUpdatingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForWritingAtPath:">
<label id="method**WindowsFileHandle**-initForWritingAtPath:" />- <code>(id) </code>
          <b>initForWritingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithNullDevice">
<label id="method**WindowsFileHandle**-initWithNullDevice" />- <code>(id) </code>
          <b>initWithNullDevice </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardError">
<label id="method**WindowsFileHandle**-initWithStandardError" />- <code>(id) </code>
          <b>initWithStandardError </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardInput">
<label id="method**WindowsFileHandle**-initWithStandardInput" />- <code>(id) </code>
          <b>initWithStandardInput </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardOutput">
<label id="method**WindowsFileHandle**-initWithStandardOutput" />- <code>(id) </code>
          <b>initWithStandardOutput </b>
          <br><em>Description forthcoming.</em>


        



<section name="postReadNotification">
<label id="method**WindowsFileHandle**-postReadNotification" />- <code>(void) </code>
          <b>postReadNotification </b>
          <br><em>Description forthcoming.</em>


        



<section name="postWriteNotification">
<label id="method**WindowsFileHandle**-postWriteNotification" />- <code>(void) </code>
          <b>postWriteNotification </b>
          <br><em>Description forthcoming.</em>


        



<section name="receivedEvent:type:extra:forMode:">
<label id="method**WindowsFileHandle**-receivedEvent:type:extra:forMode:" />- <code>(void) </code>
          <b>receivedEvent: </b>
          <code>(void*) </code><i>data </i>
          <b>type: </b>
          <code>(RunLoopEventType) </code><i>type </i>
          <b>extra: </b>
          <code>(void*) </code><i>extra </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br><em>Description forthcoming.</em>


        



<section name="setNonBlocking:">
<label id="method**WindowsFileHandle**-setNonBlocking:" />- <code>(void) </code>
          <b>setNonBlocking: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="timedOutEvent:type:forMode:">
<label id="method**WindowsFileHandle**-timedOutEvent:type:forMode:" />- <code>(NSDate*) </code>
          <b>timedOutEvent: </b>
          <code>(void*) </code><i>data </i>
          <b>type: </b>
          <code>(RunLoopEventType) </code><i>type </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br><em>Description forthcoming.</em>


        



<section name="watchReadDescriptorForModes:">
<label id="method**WindowsFileHandle**-watchReadDescriptorForModes:" />- <code>(void) </code>
          <b>watchReadDescriptorForModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br><em>Description forthcoming.</em>


        



<section name="watchWriteDescriptor">
<label id="method**WindowsFileHandle**-watchWriteDescriptor" />- <code>(void) </code>
          <b>watchWriteDescriptor </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSPortCoder">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSPortCoder">NSPortCoder</ref>: <ref id="NSCoder">NSCoder</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSPortCoder.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="portCoderWithReceivePort:sendPort:components:">
<label id="method**NSPortCoder**+portCoderWithReceivePort:sendPort:components:" />+ <code>(NSPortCoder*) </code>
          <b>portCoderWithReceivePort: </b>
          <code>(NSPort*) </code><i>recv </i>
          <b>sendPort: </b>
          <code>(NSPort*) </code><i>send </i>
          <b>components: </b>
          <code>(NSArray*) </code><i>comp </i>
          <br><em>Description forthcoming.</em>


        



<section name="connection">
<label id="method**NSPortCoder**-connection" />- <code>(NSConnection*) </code>
          <b>connection </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodePortObject">
<label id="method**NSPortCoder**-decodePortObject" />- <code>(NSPort*) </code>
          <b>decodePortObject </b>
          <br><em>Description forthcoming.</em>


        



<section name="dispatch">
<label id="method**NSPortCoder**-dispatch" />- <code>(void) </code>
          <b>dispatch </b>
          <br><em>Description forthcoming.</em>


        



<section name="encodePortObject:">
<label id="method**NSPortCoder**-encodePortObject:" />- <code>(void) </code>
          <b>encodePortObject: </b>
          <code>(NSPort*) </code><i>aPort </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithReceivePort:sendPort:components:">
<label id="method**NSPortCoder**-initWithReceivePort:sendPort:components:" />- <code>(id) </code>
          <b>initWithReceivePort: </b>
          <code>(NSPort*) </code><i>recv </i>
          <b>sendPort: </b>
          <code>(NSPort*) </code><i>send </i>
          <b>components: </b>
          <code>(NSArray*) </code><i>comp </i>
          <br><em>Description forthcoming.</em>


        



<section name="isBycopy">
<label id="method**NSPortCoder**-isBycopy" />- <code>(BOOL) </code>
          <b>isBycopy </b>
          <br><em>Description forthcoming.</em>


        



<section name="isByref">
<label id="method**NSPortCoder**-isByref" />- <code>(BOOL) </code>
          <b>isByref </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSShortNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSShortNumber">NSShortNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSTimeZone">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSTimeZone">NSTimeZone</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSTimeZone.h
</section>

<section name="Description">
<br>If the GNUstep time zone datafiles become too out of
            date, one can download an updated database from
            
            and compile it as specified in the README file in the
            NSTimeZones directory.
          Time zone names in NSDates should be GMT, MET etc. not
            Europe/Berlin, America/Washington etc.
          The problem with this is that various time zones may
            use the same abbreviation (e.g. Australia/Brisbane and
            America/New_York both use EST), and some
            time zones may have different rules for daylight
            saving time even if the abbreviation and offsets
            from UTC are the same.
          The problems with depending on the OS for providing
            time zone info are that some methods for the
            NSTimeZone classes might be difficult to
            implement, and also that time zone names may
            vary wildly between OSes (this could be a big problem
            when archiving is used between different systems).


</section>

<section name="Methods">


<section name="abbreviationDictionary">
<label id="method**NSTimeZone**+abbreviationDictionary" />+ <code>(NSDictionary*) </code>
          <b>abbreviationDictionary </b>
          <br><em>Description forthcoming.</em>


        



<section name="abbreviationMap">
<label id="method**NSTimeZone**+abbreviationMap" />+ <code>(NSDictionary*) </code>
          <b>abbreviationMap </b>
          <br><em>Description forthcoming.</em>


        



<section name="defaultTimeZone">
<label id="method**NSTimeZone**+defaultTimeZone" />+ <code>(NSTimeZone*) </code>
          <b>defaultTimeZone </b>
          <br>Return the default time zone for this process.


        



<section name="localTimeZone">
<label id="method**NSTimeZone**+localTimeZone" />+ <code>(NSTimeZone*) </code>
          <b>localTimeZone </b>
          <br>Return a proxy to the default time zone for this
            process.


        



<section name="resetSystemTimeZone">
<label id="method**NSTimeZone**+resetSystemTimeZone" />+ <code>(void) </code>
          <b>resetSystemTimeZone </b>
          <br>Destroy the system time zone so that it will be
            recreated next time it is used.


        



<section name="setDefaultTimeZone:">
<label id="method**NSTimeZone**+setDefaultTimeZone:" />+ <code>(void) </code>
          <b>setDefaultTimeZone: </b>
          <code>(NSTimeZone*) </code><i>aTimeZone </i>
          <br>Set the default time zone to be used for this process.


        



<section name="systemTimeZone">
<label id="method**NSTimeZone**+systemTimeZone" />+ <code>(NSTimeZone*) </code>
          <b>systemTimeZone </b>
          <br>Returns the current system time zone for the
            process.


        



<section name="timeZoneArray">
<label id="method**NSTimeZone**+timeZoneArray" />+ <code>(NSArray*) </code>
          <b>timeZoneArray </b>
          <br><em>Description forthcoming.</em>


        



<section name="timeZoneForSecondsFromGMT:">
<label id="method**NSTimeZone**+timeZoneForSecondsFromGMT:" />+ <code>(NSTimeZone*) </code>
          <b>timeZoneForSecondsFromGMT: </b>
          <code>(int) </code><i>seconds </i>
          <br>Return a timezone for the specified offset from GMT.
            
<br>
 The timezone returned does <em>not</em> use
            daylight savings time. The actual timezone
            returned has an offset rounded to the nearest
            minute. 
<br>
 Time zones with an offset of more
            than +/- 18 hours are disallowed, and <code>nil</code>
            is returned.


        



<section name="timeZoneWithAbbreviation:">
<label id="method**NSTimeZone**+timeZoneWithAbbreviation:" />+ <code>(NSTimeZone*) </code>
          <b>timeZoneWithAbbreviation: </b>
          <code>(NSString*) </code><i>abbreviation </i>
          <br>Returns a timezone for the specified abbrevition,


        



<section name="timeZoneWithName:">
<label id="method**NSTimeZone**+timeZoneWithName:" />+ <code>(NSTimeZone*) </code>
          <b>timeZoneWithName: </b>
          <code>(NSString*) </code><i>aTimeZoneName </i>
          <br>Returns a timezone for the specified name.


        



<section name="timeZoneWithName:data:">
<label id="method**NSTimeZone**+timeZoneWithName:data:" />+ <code>(NSTimeZone*) </code>
          <b>timeZoneWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>data: </b>
          <code>(NSData*) </code><i>data </i>
          <br>Returns a timezone for the specified
            <i>name</i>, created from the supplied
            <i>data</i>.


        



<section name="abbreviation">
<label id="method**NSTimeZone**-abbreviation" />- <code>(NSString*) </code>
          <b>abbreviation </b>
          <br>Returns the abbreviation for this timezone now.
            Invokes
            <ref id="method**NSTimeZone**-abbreviationForDate:">
              -abbreviationForDate:
            </ref>


        



<section name="abbreviationForDate:">
<label id="method**NSTimeZone**-abbreviationForDate:" />- <code>(NSString*) </code>
          <b>abbreviationForDate: </b>
          <code>(NSDate*) </code><i>aDate </i>
          <br>Returns the abbreviation for this timezone at
            <i>aDate</i>. This may differ depending on
            whether daylight savings time is in effect or not.


        



<section name="data">
<label id="method**NSTimeZone**-data" />- <code>(NSData*) </code>
          <b>data </b>
          <br>Returns the data with which the receiver was
            initialised.


        



<section name="initWithName:">
<label id="method**NSTimeZone**-initWithName:" />- <code>(id) </code>
          <b>initWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <br>Initialise a timezone with the supplied
            <i>name</i>. May return a cached timezone object
            rather than the newly created one.


        



<section name="initWithName:data:">
<label id="method**NSTimeZone**-initWithName:data:" />- <code>(id) </code>
          <b>initWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>data: </b>
          <code>(NSData*) </code><i>data </i>
          <br>Initialises a time zone object using the
            supplied <i>data</i> object. 
<br>
 This
            method is intended for internal use by the
            NSTimeZone class cluster. Don't use it... use
            <ref id="method**NSTimeZone**-initWithName:">
              -initWithName:
            </ref>
            instead.


        



<section name="isDaylightSavingTime">
<label id="method**NSTimeZone**-isDaylightSavingTime" />- <code>(BOOL) </code>
          <b>isDaylightSavingTime </b>
          <br>Returns a boolean indicating whether daylight
            savings time is in effect now. Invokes
            <ref id="method**NSTimeZone**-isDaylightSavingTimeForDate:">
              -isDaylightSavingTimeForDate:
            </ref>


        



<section name="isDaylightSavingTimeForDate:">
<label id="method**NSTimeZone**-isDaylightSavingTimeForDate:" />- <code>(BOOL) </code>
          <b>isDaylightSavingTimeForDate: </b>
          <code>(NSDate*) </code><i>aDate </i>
          <br>Returns a boolean indicating whether daylight
            savings time is in effect for this time zone at
            <i>aDate</i>.


        



<section name="isEqualToTimeZone:">
<label id="method**NSTimeZone**-isEqualToTimeZone:" />- <code>(BOOL) </code>
          <b>isEqualToTimeZone: </b>
          <code>(NSTimeZone*) </code><i>aTimeZone </i>
          <br><em>Description forthcoming.</em>


        



<section name="name">
<label id="method**NSTimeZone**-name" />- <code>(NSString*) </code>
          <b>name </b>
          <br><em>Description forthcoming.</em>


        



<section name="secondsFromGMT">
<label id="method**NSTimeZone**-secondsFromGMT" />- <code>(int) </code>
          <b>secondsFromGMT </b>
          <br>Returns the number of seconds by which the receiver
            differs from Greenwich Mean Time at the current
            date and time. 
<br>
 Invokes
            <ref id="method**NSTimeZone**-secondsFromGMTForDate:">
              -secondsFromGMTForDate:
            </ref>


        



<section name="secondsFromGMTForDate:">
<label id="method**NSTimeZone**-secondsFromGMTForDate:" />- <code>(int) </code>
          <b>secondsFromGMTForDate: </b>
          <code>(NSDate*) </code><i>aDate </i>
          <br>Returns the number of seconds by which the receiver
            differs from Greenwich Mean Time at the date
            <i>aDate</i>. 
<br>
 If the time zone uses
            dayl;ight savings time, the returned value will
            vary at different times of year.


        



<section name="timeZoneDetailArray">
<label id="method**NSTimeZone**-timeZoneDetailArray" />- <code>(NSArray*) </code>
          <b>timeZoneDetailArray </b>
          <br><em>Description forthcoming.</em>


        



<section name="timeZoneDetailForDate:">
<label id="method**NSTimeZone**-timeZoneDetailForDate:" />- <code>(NSTimeZoneDetail*) </code>
          <b>timeZoneDetailForDate: </b>
          <code>(NSDate*) </code><i>date </i>
          <br><em>Description forthcoming.</em>


        



<section name="timeZoneName">
<label id="method**NSTimeZone**-timeZoneName" />- <code>(NSString*) </code>
          <b>timeZoneName </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GCDictionary">


<section name="Overview">
<b>Inherits From:  </b><ref id="GCDictionary">GCDictionary</ref>: <ref id="NSDictionary">NSDictionary</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GCObject.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSScanner">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSScanner">NSScanner</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopying
<br><b>Declared in: </b>NSScanner.h
</section>

<section name="Description">
<br>The NSScanner class cluster (currently a single class
            in GNUstep) provides a mechanism to parse the contents
            of a string into number and string values by making a
            sequence of scan operations to step through the
            string retrieving successive items.
          You can tell the scanner whether its scanning is
            supposed to be case sensitive or not, and you can
            specify a set of characters to be skipped before
            each scanning operation (by default, whitespace and
            newlines).


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="localizedScannerWithString:">
<label id="method**NSScanner**+localizedScannerWithString:" />+ <code>(id) </code>
          <b>localizedScannerWithString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br>Returns an NSScanner instance set up to scan
            <i>aString</i> (using
            <ref id="method**NSScanner**-initWithString:">
              -initWithString:
            </ref>
            and with a locale set the default locale (using
            <ref id="method**NSScanner**-setLocale:">
              -setLocale:
            </ref>


        



<section name="scannerWithString:">
<label id="method**NSScanner**+scannerWithString:" />+ <code>(id) </code>
          <b>scannerWithString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="caseSensitive">
<label id="method**NSScanner**-caseSensitive" />- <code>(BOOL) </code>
          <b>caseSensitive </b>
          <br>If the scanner is set to be case-sensitive in its
            scanning of the string (other than characters to
            be skipped), this method returns <code>YES</code>,
            otherwise it returns <code>NO</code>. 
<br>
 The
            default is for a scanner to <em>not</em> be case
            sensitive.


        



<section name="charactersToBeSkipped">
<label id="method**NSScanner**-charactersToBeSkipped" />- <code>(NSCharacterSet*) </code>
          <b>charactersToBeSkipped </b>
          <br>Returns a set of characters containing those
            characters that the scanner ignores when
            starting any scan operation. Once a character not
            in this set has been encountered during an operation,
            skipping is finished, and any further characters
            from this set that are found are scanned normally.
            
<br>
 The default for this is the
            whitespaceAndNewlineCharacterSet.


        



<section name="initWithString:">
<label id="method**NSScanner**-initWithString:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br>Initialises the scanner to scan
            <i>aString</i>. The GNUstep implementation may
            make an internal copy of the original string - so it
            is not safe to assume that if you modify a mutable
            string that you initialised a scanner with, the
            changes will be visible to the scanner. 
<br>

            Returns the scanner object.


        



<section name="isAtEnd">
<label id="method**NSScanner**-isAtEnd" />- <code>(BOOL) </code>
          <b>isAtEnd </b>
          <br>Returns <code>YES</code> if no more characters
            remain to be scanned. 
<br>
 Returns
            <code>YES</code> if all characters remaining to be
            scanned are to be skipped. 
<br>
 Returns
            <code>NO</code> if there are characters left to
            scan.


        



<section name="locale">
<label id="method**NSScanner**-locale" />- <code>(NSDictionary*) </code>
          <b>locale </b>
          <br>Returns the locale set for the scanner, or
            <code>nil</code> if no locale has been set. A
            scanner uses it's locale to alter the way it
            handles scanning - it uses the NSDecimalSeparator
            value for scanning numbers.


        



<section name="scanCharactersFromSet:intoString:">
<label id="method**NSScanner**-scanCharactersFromSet:intoString:" />- <code>(BOOL) </code>
          <b>scanCharactersFromSet: </b>
          <code>(NSCharacterSet*) </code><i>aSet </i>
          <b>intoString: </b>
          <code>(NSString**) </code><i>value </i>
          <br>After initial skipping (if any), this method scans
            any characters from <i>aSet</i>, terminating when a
            character not in the set is found. 
<br>
 Returns
            <code>YES</code> if any character is scanned,
            <code>NO</code> otherwise. 
<br>
 If
            <i>value</i> is not null, any character scanned
            are stored in a string returned in this location.


        



<section name="scanDecimal:">
<label id="method**NSScanner**-scanDecimal:" />- <code>(BOOL) </code>
          <b>scanDecimal: </b>
          <code>(NSDecimal*) </code><i>value </i>
          <br>Not implemented.


        



<section name="scanDouble:">
<label id="method**NSScanner**-scanDouble:" />- <code>(BOOL) </code>
          <b>scanDouble: </b>
          <code>(double*) </code><i>value </i>
          <br>After initial skipping (if any), this method scans a
            double <i>value</i>, placing it in
            <em>doubleValue</em> if that is not null. Returns
            <code>YES</code> if anything is scanned,
            <code>NO</code> otherwise. 
<br>
 On overflow,
            HUGE_VAL or - HUGE_VAL is put into
            <em>doubleValue</em> 
<br>
 On underflow, 0.0 is put
            into <em>doubleValue</em> 
<br>
 Scans past any excess
            digits


        



<section name="scanFloat:">
<label id="method**NSScanner**-scanFloat:" />- <code>(BOOL) </code>
          <b>scanFloat: </b>
          <code>(float*) </code><i>value </i>
          <br>After initial skipping (if any), this method scans a
            float <i>value</i>, placing it in
            <em>floatValue</em> if that is not null. Returns
            <code>YES</code> if anything is scanned,
            <code>NO</code> otherwise. 
<br>
 On overflow,
            HUGE_VAL or - HUGE_VAL is put into
            <em>floatValue</em> 
<br>
 On underflow, 0.0 is put
            into <em>floatValue</em> 
<br>
 Scans past any excess
            digits


        



<section name="scanHexInt:">
<label id="method**NSScanner**-scanHexInt:" />- <code>(BOOL) </code>
          <b>scanHexInt: </b>
          <code>(unsigned int*) </code><i>value </i>
          <br>After initial skipping (if any), this method scans a
            hexadecimal integer <i>value</i>
            (optionally prefixed by "0x" or "0X"), placing
            it in <em>intValue</em> if that is not null. 
<br>

            Returns <code>YES</code> if anything is scanned,
            <code>NO</code> otherwise. 
<br>
 On overflow,
            INT_MAX or INT_MIN is put into <em>intValue</em>
            
<br>
 Scans past any excess digits


        



<section name="scanInt:">
<label id="method**NSScanner**-scanInt:" />- <code>(BOOL) </code>
          <b>scanInt: </b>
          <code>(int*) </code><i>value </i>
          <br>After initial skipping (if any), this method scans a
            integer <i>value</i>, placing it in
            <em>intValue</em> if that is not null. 
<br>
 Returns
            <code>YES</code> if anything is scanned,
            <code>NO</code> otherwise. 
<br>
 On overflow,
            INT_MAX or INT_MIN is put into <em>intValue</em>
            
<br>
 Scans past any excess digits


        



<section name="scanLocation">
<label id="method**NSScanner**-scanLocation" />- <code>(unsigned) </code>
          <b>scanLocation </b>
          <br>Returns the current position that the scanner has
            reached in scanning the string. This is the
            position at which the next scan operation will
            begin.


        



<section name="scanLongLong:">
<label id="method**NSScanner**-scanLongLong:" />- <code>(BOOL) </code>
          <b>scanLongLong: </b>
          <code>(long long*) </code><i>value </i>
          <br>After initial skipping (if any), this method scans a
            long decimal integer <i>value</i> placing it in
            <em>longLongValue</em> if that is not null. 
<br>

            Returns <code>YES</code> if anything is scanned,
            <code>NO</code> otherwise. 
<br>
 On overflow,
            LONG_LONG_MAX or LONG_LONG_MIN is put into
            <em>longLongValue</em> 
<br>
 Scans past any excess
            digits


        



<section name="scanRadixUnsignedInt:">
<label id="method**NSScanner**-scanRadixUnsignedInt:" />- <code>(BOOL) </code>
          <b>scanRadixUnsignedInt: </b>
          <code>(unsigned int*) </code><i>value </i>
          <br>After initial skipping (if any), this method scans an
            unsigned integer <i>value</i> placing it in
            <em>intValue</em> if that is not null. If the number
            begins with "0x" or "0X" it is treated as
            hexadecimal, otherwise if the number begins
            with "0" it is treated as octal, otherwise the number
            is treated as decimal. 
<br>
 Returns <code>YES</code>
            if anything is scanned, <code>NO</code> otherwise.
            
<br>
 On overflow, INT_MAX or INT_MIN is put into
            <em>intValue</em> 
<br>
 Scans past any excess digits


        



<section name="scanString:intoString:">
<label id="method**NSScanner**-scanString:intoString:" />- <code>(BOOL) </code>
          <b>scanString: </b>
          <code>(NSString*) </code><i>string </i>
          <b>intoString: </b>
          <code>(NSString**) </code><i>value </i>
          <br>After initial skipping (if any), this method scans
            for <em>aString</em> and places the <i>string</i>
            ound in <em>stringValue</em> if that is not null.
            
<br>
 Returns <code>YES</code> if anything is
            scanned, <code>NO</code> otherwise.


        



<section name="scanUpToCharactersFromSet:intoString:">
<label id="method**NSScanner**-scanUpToCharactersFromSet:intoString:" />- <code>(BOOL) </code>
          <b>scanUpToCharactersFromSet: </b>
          <code>(NSCharacterSet*) </code><i>aSet </i>
          <b>intoString: </b>
          <code>(NSString**) </code><i>value </i>
          <br>After initial skipping (if any), this method scans
            characters until it finds one in <em>set</em>.
            The scanned characters are placed in
            <em>stringValue</em> if that is not null. 
<br>

            Returns <code>YES</code> if anything is scanned,
            <code>NO</code> otherwise.


        



<section name="scanUpToString:intoString:">
<label id="method**NSScanner**-scanUpToString:intoString:" />- <code>(BOOL) </code>
          <b>scanUpToString: </b>
          <code>(NSString*) </code><i>string </i>
          <b>intoString: </b>
          <code>(NSString**) </code><i>value </i>
          <br>After initial skipping (if any), this method scans
            characters until it finds <em>aString</em>. The
            scanned characters are placed in
            <em>stringValue</em> if that is not null. If
            <em>aString</em> is not found, all the characters up
            to the end of the scanned <i>string</i> will be
            returned. 
<br>
 Returns <code>YES</code> if
            anything is scanned, <code>NO</code> otherwise.


        



<section name="setCaseSensitive:">
<label id="method**NSScanner**-setCaseSensitive:" />- <code>(void) </code>
          <b>setCaseSensitive: </b>
          <code>(BOOL) </code><i>flag </i>
          <br>Sets the case sensitivity of the scanner. 
<br>
 Case
            sensitivity governs matching of characters
            being scanned, but does not effect the characters in
            the set to be skipped. 
<br>
 The default is for a
            scanner to <em>not</em> be case sensitive.


        



<section name="setCharactersToBeSkipped:">
<label id="method**NSScanner**-setCharactersToBeSkipped:" />- <code>(void) </code>
          <b>setCharactersToBeSkipped: </b>
          <code>(NSCharacterSet*) </code><i>aSet </i>
          <br>Sets the set of characters that the scanner will skip
            over at the start of each scanning operation to be
            <em>skipSet</em>. Skipping is performed by literal
            character matchins - the case sensitivity of the
            scanner does not effect it. If this is set to
            <code>nil</code>, no skipping is done. 
<br>
 The
            default for this is the
            whitespaceAndNewlineCharacterSet.


        



<section name="setLocale:">
<label id="method**NSScanner**-setLocale:" />- <code>(void) </code>
          <b>setLocale: </b>
          <code>(NSDictionary*) </code><i>localeDictionary </i>
          <br>This method sets the locale used by the scanner to
            <em>aLocale</em>. The locale may be set to
            <code>nil</code>.


        



<section name="setScanLocation:">
<label id="method**NSScanner**-setScanLocation:" />- <code>(void) </code>
          <b>setScanLocation: </b>
          <code>(unsigned int) </code><i>anIndex </i>
          <br>This method sets the location in the scanned string at
            which the next scan operation begins. Raises an
            NSRangeException if index is beyond the
            end of the scanned string.


        



<section name="string">
<label id="method**NSScanner**-string" />- <code>(NSString*) </code>
          <b>string </b>
          <br>Returns the string being scanned.


        


</section>


</chapter>


<chapter name="NSCalendarDate">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSCalendarDate">NSCalendarDate</ref>: <ref id="NSDate">NSDate</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSCalendarDate.h
</section>

<section name="Description">
<br>An
          <ref id="class**NSCalendarDate**NSDate">NSDate</ref>
            subclass which understands about timezones and
            provides methods for dealing with date and time
            information by calendar and with hours minutes
            and seconds.


</section>

<section name="Methods">


<section name="calendarDate">
<label id="method**NSCalendarDate**+calendarDate" />+ <code>(id) </code>
          <b>calendarDate </b>
          <br>Return an NSCalendarDate for the current date and
            time using the default timezone.


        



<section name="dateWithString:calendarFormat:">
<label id="method**NSCalendarDate**+dateWithString:calendarFormat:" />+ <code>(id) </code>
          <b>dateWithString: </b>
          <code>(NSString*) </code><i>description </i>
          <b>calendarFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <br>Return an NSCalendarDate generated from the supplied
            <i>description</i> using the <i>format</i>
            specified for parsing that string. 
<br>
 Calls
            <ref id="method**NSCalendarDate**-initWithString:calendarFormat:">
              -initWithString:calendarFormat:
            </ref>
            to create the date.


        



<section name="dateWithString:calendarFormat:locale:">
<label id="method**NSCalendarDate**+dateWithString:calendarFormat:locale:" />+ <code>(id) </code>
          <b>dateWithString: </b>
          <code>(NSString*) </code><i>description </i>
          <b>calendarFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>dictionary </i>
          <br>Return an NSCalendarDate generated from the supplied
            <i>description</i> using the <i>format</i>
            specified for parsing that string and
            interpreting it according to the
            <i>dictionary</i> specified. 
<br>
 Calls
            <ref id="method**NSCalendarDate**-initWithString:calendarFormat:locale:">-initWithString:calendarFormat:locale:</ref> to create the date.


        



<section name="dateWithYear:month:day:hour:minute:second:timeZone:">
<label id="method**NSCalendarDate**+dateWithYear:month:day:hour:minute:second:timeZone:" />+ <code>(id) </code>
          <b>dateWithYear: </b>
          <code>(int) </code><i>year </i>
          <b>month: </b>
          <code>(unsigned int) </code><i>month </i>
          <b>day: </b>
          <code>(unsigned int) </code><i>day </i>
          <b>hour: </b>
          <code>(unsigned int) </code><i>hour </i>
          <b>minute: </b>
          <code>(unsigned int) </code><i>minute </i>
          <b>second: </b>
          <code>(unsigned int) </code><i>second </i>
          <b>timeZone: </b>
          <code>(NSTimeZone*) </code><i>aTimeZone </i>
          <br>Creates and returns an NSCalendarDate from the
            specified values by calling
            <ref id="method**NSCalendarDate**-initWithYear:month:day:hour:minute:second:timeZone:">-initWithYear:month:day:hour:minute:second:timeZone:</ref>


        



<section name="addYear:month:day:hour:minute:second:">
<label id="method**NSCalendarDate**-addYear:month:day:hour:minute:second:" />- <code>(NSCalendarDate*) </code>
          <b>addYear: </b>
          <code>(int) </code><i>year </i>
          <b>month: </b>
          <code>(int) </code><i>month </i>
          <b>day: </b>
          <code>(int) </code><i>day </i>
          <b>hour: </b>
          <code>(int) </code><i>hour </i>
          <b>minute: </b>
          <code>(int) </code><i>minute </i>
          <b>second: </b>
          <code>(int) </code><i>second </i>
          <br>This method exists solely for conformance to the
            OpenStep spec. Its use is deprecated... it simply
            calls
            <ref id="method**NSCalendarDate**-dateByAddingYears:months:days:hours:minutes:seconds:">-dateByAddingYears:months:days:hours:minutes:seconds:</ref>


        



<section name="calendarFormat">
<label id="method**NSCalendarDate**-calendarFormat" />- <code>(NSString*) </code>
          <b>calendarFormat </b>
          <br>Returns the format string associated with the
            receiver. 
<br>
 See
            <ref id="method**NSCalendarDate**-descriptionWithCalendarFormat:locale:">-descriptionWithCalendarFormat:locale:</ref> for details.


        



<section name="dayOfCommonEra">
<label id="method**NSCalendarDate**-dayOfCommonEra" />- <code>(int) </code>
          <b>dayOfCommonEra </b>
          <br>Return the day number (ie number of days since the
            start of) in the 'common' era of the receiving date.
            The era starts at 1 A.D.


        



<section name="dayOfMonth">
<label id="method**NSCalendarDate**-dayOfMonth" />- <code>(int) </code>
          <b>dayOfMonth </b>
          <br>Return the month (1 to 31) of the receiving date.


        



<section name="dayOfWeek">
<label id="method**NSCalendarDate**-dayOfWeek" />- <code>(int) </code>
          <b>dayOfWeek </b>
          <br>Return the day of the week (0 to 6) of the receiving
            date.


        



<section name="dayOfYear">
<label id="method**NSCalendarDate**-dayOfYear" />- <code>(int) </code>
          <b>dayOfYear </b>
          <br>Return the day of the year (1 to 366) of the
            receiving date.


        



<section name="description">
<label id="method**NSCalendarDate**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br>Calls
            <ref id="method**NSCalendarDate**-descriptionWithCalendarFormat:locale:">-descriptionWithCalendarFormat:locale:</ref> passing the receviers calendar format and a <code>nil</code> locale.


        



<section name="descriptionWithCalendarFormat:">
<label id="method**NSCalendarDate**-descriptionWithCalendarFormat:" />- <code>(NSString*) </code>
          <b>descriptionWithCalendarFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <br>Returns a string representation of the receiver
            using the specified <i>format</i> string. 
<br>

            Calls
            <ref id="method**NSCalendarDate**-descriptionWithCalendarFormat:locale:">-descriptionWithCalendarFormat:locale:</ref> with a <code>nil</code> locale.


        



<section name="descriptionWithCalendarFormat:locale:">
<label id="method**NSCalendarDate**-descriptionWithCalendarFormat:locale:" />- <code>(NSString*) </code>
          <b>descriptionWithCalendarFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br>Returns a string representation of the receiver
            using the specified <i>format</i> string and
            <i>locale</i> dictionary. 
<br>
 Format
            specifiers are -


        



<section name="descriptionWithLocale:">
<label id="method**NSCalendarDate**-descriptionWithLocale:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br>Returns a description of the receiver using its
            normal format but with the specified
            <i>locale</i> dictionary. 
<br>
 Calls
            <ref id="method**NSCalendarDate**-descriptionWithCalendarFormat:locale:">-descriptionWithCalendarFormat:locale:</ref> to do this.


        



<section name="hourOfDay">
<label id="method**NSCalendarDate**-hourOfDay" />- <code>(int) </code>
          <b>hourOfDay </b>
          <br>Return the hour of the day (0 to 23) of the
            receiving date.


        



<section name="initWithString:">
<label id="method**NSCalendarDate**-initWithString:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>description </i>
          <br>Initializes an NSCalendarDate using the
            specified <i>description</i> and the default
            calendar format and locale. 
<br>
 Calls
            <ref id="method**NSCalendarDate**-initWithString:calendarFormat:locale:">-initWithString:calendarFormat:locale:</ref>


        



<section name="initWithString:calendarFormat:">
<label id="method**NSCalendarDate**-initWithString:calendarFormat:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>description </i>
          <b>calendarFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <br>Initializes an NSCalendarDate using the
            specified <i>description</i> and
            <i>format</i> string interpreted in the default
            locale. 
<br>
 Calls
            <ref id="method**NSCalendarDate**-initWithString:calendarFormat:locale:">-initWithString:calendarFormat:locale:</ref>


        



<section name="initWithString:calendarFormat:locale:">
<label id="method**NSCalendarDate**-initWithString:calendarFormat:locale:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>description </i>
          <b>calendarFormat: </b>
          <code>(NSString*) </code><i>fmt </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br>Initializes an NSCalendarDate using the
            specified <i>description</i> and format
            string interpreted in the given <i>locale</i>.
            
<br>
 Format specifiers are -


        



<section name="initWithYear:month:day:hour:minute:second:timeZone:">
<label id="method**NSCalendarDate**-initWithYear:month:day:hour:minute:second:timeZone:" />- <code>(id) </code>
          <b>initWithYear: </b>
          <code>(int) </code><i>year </i>
          <b>month: </b>
          <code>(unsigned int) </code><i>month </i>
          <b>day: </b>
          <code>(unsigned int) </code><i>day </i>
          <b>hour: </b>
          <code>(unsigned int) </code><i>hour </i>
          <b>minute: </b>
          <code>(unsigned int) </code><i>minute </i>
          <b>second: </b>
          <code>(unsigned int) </code><i>second </i>
          <b>timeZone: </b>
          <code>(NSTimeZone*) </code><i>aTimeZone </i>
          <br>Returns an NSCalendarDate instance with the given
            <i>year</i>, <i>month</i>, <i>day</i>,
            <i>hour</i>, <i>minute</i>, and
            <i>second</i>, using <i>aTimeZone</i>. 
<br>

            The <i>year</i> includes the century (ie you can't
            just say '02' when you mean '2002'). 
<br>
 The
            <i>month</i> is in the range 1 to 12, 
<br>
 The
            <i>day</i> is in the range 1 to 31, 
<br>
 The
            <i>hour</i> is in the range 0 to 23, 
<br>
 The
            <i>minute</i> is in the range 0 to 59, 
<br>
 The
            <i>second</i> is in the range 0 to 59. 
<br>
 If
            <i>aTimeZone</i> is <code>nil</code>, the
            <ref id="method**NSTimeZone**+localTimeZone">
              [NSTimeZone% unknown entity: nbsp
+localTimeZone]
            </ref>
            value is used.
            GNUstep checks the validity of the method
              arguments, and unless the base library was
              built with 'warn=no' it generates a warning for bad
              values. It tries to use those bad values to
              generate a date anyway though, rather than
              failing (this also appears to be the behavior of
              MacOS-X).
            The algorithm GNUstep uses to create the date is this
            ... 
<br>


        



<section name="minuteOfHour">
<label id="method**NSCalendarDate**-minuteOfHour" />- <code>(int) </code>
          <b>minuteOfHour </b>
          <br>Return the minute of the hour (0 to 59) of the
            receiving date.


        



<section name="monthOfYear">
<label id="method**NSCalendarDate**-monthOfYear" />- <code>(int) </code>
          <b>monthOfYear </b>
          <br>Return the month of the year (1 to 12) of the
            receiving date.


        



<section name="secondOfMinute">
<label id="method**NSCalendarDate**-secondOfMinute" />- <code>(int) </code>
          <b>secondOfMinute </b>
          <br>Return the second of the minute (0 to 59) of the
            receiving date.


        



<section name="setCalendarFormat:">
<label id="method**NSCalendarDate**-setCalendarFormat:" />- <code>(void) </code>
          <b>setCalendarFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <br>Sets the <i>format</i> string associated with the
            receiver. 
<br>
 See
            <ref id="method**NSCalendarDate**-descriptionWithCalendarFormat:locale:">-descriptionWithCalendarFormat:locale:</ref> for details.


        



<section name="setTimeZone:">
<label id="method**NSCalendarDate**-setTimeZone:" />- <code>(void) </code>
          <b>setTimeZone: </b>
          <code>(NSTimeZone*) </code><i>aTimeZone </i>
          <br>Sets the time zone associated with the receiver.


        



<section name="timeZone">
<label id="method**NSCalendarDate**-timeZone" />- <code>(NSTimeZone*) </code>
          <b>timeZone </b>
          <br>Returns the time zone associated with the receiver.


        



<section name="timeZoneDetail">
<label id="method**NSCalendarDate**-timeZoneDetail" />- <code>(NSTimeZoneDetail*) </code>
          <b>timeZoneDetail </b>
          <br>Returns the time zone detail associated with the
            receiver.


        



<section name="yearOfCommonEra">
<label id="method**NSCalendarDate**-yearOfCommonEra" />- <code>(int) </code>
          <b>yearOfCommonEra </b>
          <br>Return the year of the 'common' era of the receiving
            date. The era starts at 1 A.D.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSLock">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSLock">NSLock</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSLockingGCFinalization
<br><b>Declared in: </b>NSLock.h
</section>

<section name="Description">
<br>An NSLock is used in multi-threaded applications to
          protect critical pieces of code. While one thread
          holds a lock within a piece of code, another thread
          cannot execute that code until the first thread has
          given up it's hold on the lock. The limitation of
          NSLock is that you can only lock an NSLock once and it
          must be unlocked before it can be aquired again. 
<br>

          Other lock classes, notably NSRecursiveLock, have
          different restrictions.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
      

<section name="lock">
<label id="method**NSLock**-lock" />- <code>(void) </code>
          <b>lock </b>
          <br>Attempts to aquire a lock, and waits until it can
            do so.


        



<section name="lockBeforeDate:">
<label id="method**NSLock**-lockBeforeDate:" />- <code>(BOOL) </code>
          <b>lockBeforeDate: </b>
          <code>(NSDate*) </code><i>limit </i>
          <br>Attempts to aquire a lock before the date
            <i>limit</i> passes. It returns <code>YES</code>
            if it can. It returns <code>NO</code> if it cannot, or
            if the current thread already has the lock (but it waits
            until the time <i>limit</i> is up before
            returning <code>NO</code>).


        



<section name="tryLock">
<label id="method**NSLock**-tryLock" />- <code>(BOOL) </code>
          <b>tryLock </b>
          <br>Attempts to aquire a lock, but returns immediately
            if the lock cannot be aquired. It returns
            <code>YES</code> if the lock is aquired. It returns
            <code>NO</code> if the lock cannot be aquired or if
            the current thread already has the lock.


        



<section name="unlock">
<label id="method**NSLock**-unlock" />- <code>(void) </code>
          <b>unlock </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSUserDefaults">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSUserDefaults">NSUserDefaults</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSUserDefaults.h
</section>

<section name="Description">
<br>NSUserDefaults provides an interface to the
            defaults system, which allows an application
            access to global and/or application specific
            defualts set by the user. A particular instance of
            NSUserDefaults, standardUserDefaults, is
            provided as a convenience. Most of the information
            described below pertains to the
            standardUserDefaults. It is unlikely
            that you would want to instantiate your own
            userDefaults object, since it would not be set
            up in the same way as the standardUserDefaults.
          Defaults are managed based on <em>domains</em>.
            Certain domains, such as
            <code>NSGlobalDomain</code>, are persistant. These
            domains have defaults that are stored externally.
            Other domains are volitale. The defaults in these
            domains remain in effect only during the existance
            of the application and may in fact be different for
            applications running at the same time. When
            asking for a default value from
            standardUserDefaults, NSUserDefaults
            looks through the various domains in a particular
            order.
          
          The <em>NSLanguages</em> default value is used to set
            up the constants for localization. GNUstep will also
            look for the <code>LANGUAGES</code> environment
            variable if it is not set in the defaults system.
            If it exists, it consists of an array of languages that
            the user prefers. At least one of the languages should
            have a corresponding localization file (typically
            located in the  directory of
            the GNUstep resources).
          As a special extension, on systems that support locales
            (e.g. GNU/Linux and Solaris), GNUstep will use
            information from the user specified locale, if
            the <em>NSLanguages</em> default value is not found.
            Typically the locale is specified in the
            environment with the <code>LANG</code>
            environment variable.
          The first change to a persistent domain after a
            <ref id="method**NSUserDefaults**-synchronize">
              -synchronize
            </ref>
            will cause an NSUserDefaultsDidChangeNotification to
            be posted (as will any change caused by reading new
            values from disk), so your application can keep
            track of changes made to the defaults by other
            software.
          NB. The GNUstep implementation differs from the Apple
            one in that it is thread-safe while Apples (as of
            MacOS-X 10.1) is not.


</section>

<section name="Methods">


<section name="resetStandardUserDefaults">
<label id="method**NSUserDefaults**+resetStandardUserDefaults" />+ <code>(void) </code>
          <b>resetStandardUserDefaults </b>
          <br>Resets the shared user defaults object to reflect
            the current user ID. Needed by setuid processes which
            change the user they are running as. 
<br>
 In
            GNUstep you should call
            <ref id="function**NSUserDefaults**GSSetUserName">
              GSSetUserName()
            </ref>
            when changing your effective user ID, and that class
            will call this function for you.


        



<section name="setUserLanguages:">
<label id="method**NSUserDefaults**+setUserLanguages:" />+ <code>(void) </code>
          <b>setUserLanguages: </b>
          <code>(NSArray*) </code><i>languages </i>
          <br>Sets the array of user <i>languages</i>
            preferences. Places the specified array in the
            <em>NSLanguages</em> user default.


        



<section name="standardUserDefaults">
<label id="method**NSUserDefaults**+standardUserDefaults" />+ <code>(NSUserDefaults*) </code>
          <b>standardUserDefaults </b>
          <br>Returns the shared defaults object. If it doesn't
            exist yet, it's created. The defaults are initialized
            for the current user. The search list is guaranteed to
            be standard only the first time this method is invoked.
            The shared instance is provided as a convenience; other
            instances may also be created.


        



<section name="userLanguages">
<label id="method**NSUserDefaults**+userLanguages" />+ <code>(NSArray*) </code>
          <b>userLanguages </b>
          <br>Returns the array of user languages preferences.
            Uses the <em>NSLanguages</em> user default if
            available, otherwise tries to infer setup from
            operating system information etc (in particular,
            uses the <em>LANGUAGES</em> environment variable).


        



<section name="arrayForKey:">
<label id="method**NSUserDefaults**-arrayForKey:" />- <code>(NSArray*) </code>
          <b>arrayForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using
            <ref id="method**NSUserDefaults**-objectForKey:">
              -objectForKey:
            </ref>
            and checks that it is an NSArray object. Returns
            <code>nil</code> if it is not.


        



<section name="boolForKey:">
<label id="method**NSUserDefaults**-boolForKey:" />- <code>(BOOL) </code>
          <b>boolForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using
            <ref id="method**NSUserDefaults**-objectForKey:">
              -objectForKey:
            </ref>
            and returns its boolean representation. 
<br>
 Returns
            <code>NO</code> if it is not a boolean. 
<br>
 The
            text 'yes' or 'true' or any non zero numeric value is
            considered to be a boolean <code>YES</code>.
            Other string values are <code>NO</code>. 
<br>
 NB.
            This differs slightly from the documented behavior for
            MacOS-X (August 2002) in that the GNUstep version
            accepts the string 'TRUE' as equivalent to 'YES'.


        



<section name="dataForKey:">
<label id="method**NSUserDefaults**-dataForKey:" />- <code>(NSData*) </code>
          <b>dataForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using
            <ref id="method**NSUserDefaults**-objectForKey:">
              -objectForKey:
            </ref>
            and checks that it is an NSData object. Returns
            <code>nil</code> if it is not.


        



<section name="dictionaryForKey:">
<label id="method**NSUserDefaults**-dictionaryForKey:" />- <code>(NSDictionary*) </code>
          <b>dictionaryForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using
            <ref id="method**NSUserDefaults**-objectForKey:">
              -objectForKey:
            </ref>
            and checks that it is an NSDictionary object. Returns
            <code>nil</code> if it is not.


        



<section name="dictionaryRepresentation">
<label id="method**NSUserDefaults**-dictionaryRepresentation" />- <code>(NSDictionary*) </code>
          <b>dictionaryRepresentation </b>
          <br>Returns a dictionary representing the current state
            of the defaults system... this is a merged version of
            all the domains in the search list.


        



<section name="floatForKey:">
<label id="method**NSUserDefaults**-floatForKey:" />- <code>(float) </code>
          <b>floatForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using
            <ref id="method**NSUserDefaults**-objectForKey:">
              -objectForKey:
            </ref>
            and checks that it is a float. Returns 0.0 if it is
            not.


        



<section name="init">
<label id="method**NSUserDefaults**-init" />- <code>(id) </code>
          <b>init </b>
          <br>Initializes defaults for current user calling
            initWithUser:


        



<section name="initWithContentsOfFile:">
<label id="method**NSUserDefaults**-initWithContentsOfFile:" />- <code>(id) </code>
          <b>initWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Initializes defaults for the specified
            <i>path</i>. Returns an object with an empty
            search list.


        



<section name="initWithUser:">
<label id="method**NSUserDefaults**-initWithUser:" />- <code>(id) </code>
          <b>initWithUser: </b>
          <code>(NSString*) </code><i>userName </i>
          <br>Initializes defaults for the specified user
            calling
            <ref id="method**NSUserDefaults**-initWithContentsOfFile:">
              -initWithContentsOfFile:
            </ref>


        



<section name="integerForKey:">
<label id="method**NSUserDefaults**-integerForKey:" />- <code>(int) </code>
          <b>integerForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using
            <ref id="method**NSUserDefaults**-objectForKey:">
              -objectForKey:
            </ref>
            and checks that it is an integer. Returns 0 if it is
            not.


        



<section name="objectForKey:">
<label id="method**NSUserDefaults**-objectForKey:" />- <code>(id) </code>
          <b>objectForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using. The
            lookup is performed by accessing the domains in the
            order given in the search list. 
<br>
 Returns
            <code>nil</code> if <i>defaultName</i> cannot be
            found.


        



<section name="persistentDomainForName:">
<label id="method**NSUserDefaults**-persistentDomainForName:" />- <code>(NSDictionary*) </code>
          <b>persistentDomainForName: </b>
          <code>(NSString*) </code><i>domainName </i>
          <br>Returns the persistent domain specified by
            <i>domainName</i>.


        



<section name="persistentDomainNames">
<label id="method**NSUserDefaults**-persistentDomainNames" />- <code>(NSArray*) </code>
          <b>persistentDomainNames </b>
          <br>Returns an array listing the name of all the
            persistent domains.


        



<section name="registerDefaults:">
<label id="method**NSUserDefaults**-registerDefaults:" />- <code>(void) </code>
          <b>registerDefaults: </b>
          <code>(NSDictionary*) </code><i>newVals </i>
          <br>Merges the contents of the dictionary
            <i>newVals</i> into the registration domain.
            Registration defaults may be added to or
            replaced using this method, but may never be
            removed. Thus, setting registration defaults at
            any point in your program guarantees that the defaults
            will be available thereafter.


        



<section name="removeObjectForKey:">
<label id="method**NSUserDefaults**-removeObjectForKey:" />- <code>(void) </code>
          <b>removeObjectForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Removes the default with the specified name from
            the application domain.


        



<section name="removePersistentDomainForName:">
<label id="method**NSUserDefaults**-removePersistentDomainForName:" />- <code>(void) </code>
          <b>removePersistentDomainForName: </b>
          <code>(NSString*) </code><i>domainName </i>
          <br>Removes the persistent domain specified by
            <i>domainName</i> from the user defaults. 
<br>

            Causes a NSUserDefaultsDidChangeNotification to be
            posted if this is the first change to a
            persistent-domain since the last
            <ref id="method**NSUserDefaults**-synchronize">
              -synchronize
            </ref>
            .


        



<section name="removeVolatileDomainForName:">
<label id="method**NSUserDefaults**-removeVolatileDomainForName:" />- <code>(void) </code>
          <b>removeVolatileDomainForName: </b>
          <code>(NSString*) </code><i>domainName </i>
          <br>Removes the volatile domain specified by
            <i>domainName</i> from the user defaults.


        



<section name="searchList">
<label id="method**NSUserDefaults**-searchList" />- <code>(NSMutableArray*) </code>
          <b>searchList </b>
          <br>Returns an array listing the domains searched in
            order to look up a value in the defaults system. The
            order of the names in the array is the order in which
            the domains are searched.


        



<section name="setBool:forKey:">
<label id="method**NSUserDefaults**-setBool:forKey:" />- <code>(void) </code>
          <b>setBool: </b>
          <code>(BOOL) </code><i>value </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Sets a boolean <i>value</i> for
            <i>defaultName</i> in the application domain.
            
<br>
 The boolean <i>value</i> is stored as a
            string - either <code>YES</code> or <code>NO</code>.
            Calls
            <ref id="method**NSUserDefaults**-setObject:forKey:">
              -setObject:forKey:
            </ref>
            to make the change.


        



<section name="setFloat:forKey:">
<label id="method**NSUserDefaults**-setFloat:forKey:" />- <code>(void) </code>
          <b>setFloat: </b>
          <code>(float) </code><i>value </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Sets a float <i>value</i> for
            <i>defaultName</i> in the application domain.
            
<br>
 Calls
            <ref id="method**NSUserDefaults**-setObject:forKey:">
              -setObject:forKey:
            </ref>
            to make the change.


        



<section name="setInteger:forKey:">
<label id="method**NSUserDefaults**-setInteger:forKey:" />- <code>(void) </code>
          <b>setInteger: </b>
          <code>(int) </code><i>value </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Sets an integer <i>value</i> for
            <i>defaultName</i> in the application domain.
            
<br>
 Calls
            <ref id="method**NSUserDefaults**-setObject:forKey:">
              -setObject:forKey:
            </ref>
            to make the change.


        



<section name="setObject:forKey:">
<label id="method**NSUserDefaults**-setObject:forKey:" />- <code>(void) </code>
          <b>setObject: </b>
          <code>(id) </code><i>value </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Sets an object <i>value</i> for
            <i>defaultName</i> in the application domain.
            
<br>
 The <i>defaultName</i> must be a
            non-empty string. 
<br>
 The <i>value</i>
            must be an instance of one of the
            <ref id="method**NSString**-propertyList">
              [NSString% unknown entity: nbsp
-propertyList]
            </ref>
            classes. 
<br>

            Causes a NSUserDefaultsDidChangeNotification to be
              posted if this is the first change to a
              persistent-domain since the last
              <ref id="method**NSUserDefaults**-synchronize">
                -synchronize
              </ref>
              .


        



<section name="setPersistentDomain:forName:">
<label id="method**NSUserDefaults**-setPersistentDomain:forName:" />- <code>(void) </code>
          <b>setPersistentDomain: </b>
          <code>(NSDictionary*) </code><i>domain </i>
          <b>forName: </b>
          <code>(NSString*) </code><i>domainName </i>
          <br>Replaces the persistent-domain specified by
            <i>domainName</i> with <i>domain</i>... a
            dictionary containing keys and defaults values.
            
<br>
 Raises an NSInvalidArgumentException if
            <i>domainName</i> already exists as a
            volatile-domain. 
<br>
 Causes a
            NSUserDefaultsDidChangeNotification
            to be posted if this is the first change to a
            persistent-domain since the last
            <ref id="method**NSUserDefaults**-synchronize">
              -synchronize
            </ref>
            .


        



<section name="setSearchList:">
<label id="method**NSUserDefaults**-setSearchList:" />- <code>(void) </code>
          <b>setSearchList: </b>
          <code>(NSArray*) </code><i>newList </i>
          <br>Sets the list of the domains searched in order to look
            up a value in the defaults system. The order of the
            names in the array is the order in which the domains
            are searched. 
<br>
 On lookup, the first match is
            used.


        



<section name="setVolatileDomain:forName:">
<label id="method**NSUserDefaults**-setVolatileDomain:forName:" />- <code>(void) </code>
          <b>setVolatileDomain: </b>
          <code>(NSDictionary*) </code><i>domain </i>
          <b>forName: </b>
          <code>(NSString*) </code><i>domainName </i>
          <br>Sets the volatile-domain specified by
            <i>domainName</i> to <i>domain</i>... a
            dictionary containing keys and defaults values.
            
<br>
 Raises an NSInvalidArgumentException if
            <i>domainName</i> already exists as either a
            volatile-domain or a persistent-domain.


        



<section name="stringArrayForKey:">
<label id="method**NSUserDefaults**-stringArrayForKey:" />- <code>(NSArray*) </code>
          <b>stringArrayForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Calls
            <ref id="method**NSUserDefaults**-arrayForKey:">
              -arrayForKey:
            </ref>
            to get an array value for <i>defaultName</i> and
            checks that the array contents are string objects...
            if not, returns <code>nil</code>.


        



<section name="stringForKey:">
<label id="method**NSUserDefaults**-stringForKey:" />- <code>(NSString*) </code>
          <b>stringForKey: </b>
          <code>(NSString*) </code><i>defaultName </i>
          <br>Looks up a value for a specified default using
            <ref id="method**NSUserDefaults**-objectForKey:">
              -objectForKey:
            </ref>
            and checks that it is an NSString. Returns
            <code>nil</code> if it is not.


        



<section name="synchronize">
<label id="method**NSUserDefaults**-synchronize" />- <code>(BOOL) </code>
          <b>synchronize </b>
          <br>Ensures that the in-memory and on-disk
            representations of the defaults are in
            sync. You may call this yourself, but probably don't
            need to since it is invoked at intervals whenever a
            runloop is running. 
<br>
 If any persistent domain
            is changed by reading new values from disk, an
            NSUserDefaultsDidChangeNotification
            is posted.


        



<section name="volatileDomainForName:">
<label id="method**NSUserDefaults**-volatileDomainForName:" />- <code>(NSDictionary*) </code>
          <b>volatileDomainForName: </b>
          <code>(NSString*) </code><i>domainName </i>
          <br>Returns the volatile domain specified by
            <i>domainName</i>.


        



<section name="volatileDomainNames">
<label id="method**NSUserDefaults**-volatileDomainNames" />- <code>(NSArray*) </code>
          <b>volatileDomainNames </b>
          <br>Returns an array listing the name of all the
            volatile domains.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSCountedSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSCountedSet">NSCountedSet</ref>: <ref id="NSMutableSet">NSMutableSet</ref>: <ref id="NSSet">NSSet</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSSet.h
</section>

<section name="Description">
<br>The NSCountedSet class is used to maintain a set of
            objects where the number of times each object has
            been added (wiithout a corresponding removal) is kept
            track of.
          In GNUstep, extra methods are provided to make use of a
            counted set for <em>uniquing</em> objects easier.


</section>

<section name="Methods">


<section name="countForObject:">
<label id="method**NSCountedSet**-countForObject:" />- <code>(unsigned int) </code>
          <b>countForObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Returns the number of times that an object that is
            equal to the specified object (as determined byt the
            <ref id="method**NSCountedSet**-isEqual:">
              [-isEqual:]
            </ref>
            method) has been added to the set and not removed
            from it.


        


        
        
        
      
</section>


</chapter>


<chapter name="NSPortNameServer">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSPortNameServer">NSPortNameServer</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSPortNameServer.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="systemDefaultPortNameServer">
<label id="method**NSPortNameServer**+systemDefaultPortNameServer" />+ <code>(id) </code>
          <b>systemDefaultPortNameServer </b>
          <br><em>Description forthcoming.</em>


        



<section name="portForName:">
<label id="method**NSPortNameServer**-portForName:" />- <code>(NSPort*) </code>
          <b>portForName: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="portForName:onHost:">
<label id="method**NSPortNameServer**-portForName:onHost:" />- <code>(NSPort*) </code>
          <b>portForName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>onHost: </b>
          <code>(NSString*) </code><i>host </i>
          <br><em>Description forthcoming.</em>


        



<section name="registerPort:forName:">
<label id="method**NSPortNameServer**-registerPort:forName:" />- <code>(BOOL) </code>
          <b>registerPort: </b>
          <code>(NSPort*) </code><i>port </i>
          <b>forName: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="removePortForName:">
<label id="method**NSPortNameServer**-removePortForName:" />- <code>(BOOL) </code>
          <b>removePortForName: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSCoder">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSCoder">NSCoder</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSCoder.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="decodeArrayOfObjCType:count:at:">
<label id="method**NSCoder**-decodeArrayOfObjCType:count:at:" />- <code>(void) </code>
          <b>decodeArrayOfObjCType: </b>
          <code>(const char*) </code><i>type </i>
          <b>count: </b>
          <code>(unsigned) </code><i>count </i>
          <b>at: </b>
          <code>(void*) </code><i>address </i>
          <br><em>Description forthcoming.</em>


        



<section name="decodeBytesWithReturnedLength:">
<label id="method**NSCoder**-decodeBytesWithReturnedLength:" />- <code>(void*) </code>
          <b>decodeBytesWithReturnedLength: </b>
          <code>(unsigned*) </code><i>l </i>
          <br><em>Description forthcoming.</em>


        



<section name="decodeDataObject">
<label id="method**NSCoder**-decodeDataObject" />- <code>(NSData*) </code>
          <b>decodeDataObject </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodeObject">
<label id="method**NSCoder**-decodeObject" />- <code>(id) </code>
          <b>decodeObject </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodePoint">
<label id="method**NSCoder**-decodePoint" />- <code>(NSPoint) </code>
          <b>decodePoint </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodePropertyList">
<label id="method**NSCoder**-decodePropertyList" />- <code>(id) </code>
          <b>decodePropertyList </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodeRect">
<label id="method**NSCoder**-decodeRect" />- <code>(NSRect) </code>
          <b>decodeRect </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodeSize">
<label id="method**NSCoder**-decodeSize" />- <code>(NSSize) </code>
          <b>decodeSize </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodeValueOfObjCType:at:">
<label id="method**NSCoder**-decodeValueOfObjCType:at:" />- <code>(void) </code>
          <b>decodeValueOfObjCType: </b>
          <code>(const char*) </code><i>type </i>
          <b>at: </b>
          <code>(void*) </code><i>address </i>
          <br><em>Description forthcoming.</em>


        



<section name="decodeValuesOfObjCTypes:">
<label id="method**NSCoder**-decodeValuesOfObjCTypes:" />- <code>(void) </code>
          <b>decodeValuesOfObjCTypes: </b>
          <code>(const char*) </code><i>types </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="encodeArrayOfObjCType:count:at:">
<label id="method**NSCoder**-encodeArrayOfObjCType:count:at:" />- <code>(void) </code>
          <b>encodeArrayOfObjCType: </b>
          <code>(const char*) </code><i>type </i>
          <b>count: </b>
          <code>(unsigned) </code><i>count </i>
          <b>at: </b>
          <code>(const void*) </code><i>array </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeBycopyObject:">
<label id="method**NSCoder**-encodeBycopyObject:" />- <code>(void) </code>
          <b>encodeBycopyObject: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeByrefObject:">
<label id="method**NSCoder**-encodeByrefObject:" />- <code>(void) </code>
          <b>encodeByrefObject: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeBytes:length:">
<label id="method**NSCoder**-encodeBytes:length:" />- <code>(void) </code>
          <b>encodeBytes: </b>
          <code>(void*) </code><i>d </i>
          <b>length: </b>
          <code>(unsigned) </code><i>l </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeConditionalObject:">
<label id="method**NSCoder**-encodeConditionalObject:" />- <code>(void) </code>
          <b>encodeConditionalObject: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeDataObject:">
<label id="method**NSCoder**-encodeDataObject:" />- <code>(void) </code>
          <b>encodeDataObject: </b>
          <code>(NSData*) </code><i>data </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeObject:">
<label id="method**NSCoder**-encodeObject:" />- <code>(void) </code>
          <b>encodeObject: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodePoint:">
<label id="method**NSCoder**-encodePoint:" />- <code>(void) </code>
          <b>encodePoint: </b>
          <code>(NSPoint) </code><i>point </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodePropertyList:">
<label id="method**NSCoder**-encodePropertyList:" />- <code>(void) </code>
          <b>encodePropertyList: </b>
          <code>(id) </code><i>plist </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeRect:">
<label id="method**NSCoder**-encodeRect:" />- <code>(void) </code>
          <b>encodeRect: </b>
          <code>(NSRect) </code><i>rect </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeRootObject:">
<label id="method**NSCoder**-encodeRootObject:" />- <code>(void) </code>
          <b>encodeRootObject: </b>
          <code>(id) </code><i>rootObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeSize:">
<label id="method**NSCoder**-encodeSize:" />- <code>(void) </code>
          <b>encodeSize: </b>
          <code>(NSSize) </code><i>size </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeValueOfObjCType:at:">
<label id="method**NSCoder**-encodeValueOfObjCType:at:" />- <code>(void) </code>
          <b>encodeValueOfObjCType: </b>
          <code>(const char*) </code><i>type </i>
          <b>at: </b>
          <code>(const void*) </code><i>address </i>
          <br><em>Description forthcoming.</em>


        



<section name="encodeValuesOfObjCTypes:">
<label id="method**NSCoder**-encodeValuesOfObjCTypes:" />- <code>(void) </code>
          <b>encodeValuesOfObjCTypes: </b>
          <code>(const char*) </code><i>types </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="objectZone">
<label id="method**NSCoder**-objectZone" />- <code>(NSZone*) </code>
          <b>objectZone </b>
          <br><em>Description forthcoming.</em>


        



<section name="setObjectZone:">
<label id="method**NSCoder**-setObjectZone:" />- <code>(void) </code>
          <b>setObjectZone: </b>
          <code>(NSZone*) </code><i>zone </i>
          <br><em>Description forthcoming.</em>


        



<section name="systemVersion">
<label id="method**NSCoder**-systemVersion" />- <code>(unsigned int) </code>
          <b>systemVersion </b>
          <br><em>Description forthcoming.</em>


        



<section name="versionForClassName:">
<label id="method**NSCoder**-versionForClassName:" />- <code>(unsigned int) </code>
          <b>versionForClassName: </b>
          <code>(NSString*) </code><i>className </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GSXMLNode">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXMLNode">GSXMLNode</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopying
<br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="descriptionFromType:">
<label id="method**GSXMLNode**+descriptionFromType:" />+ <code>(NSString*) </code>
          <b>descriptionFromType: </b>
          <code>(int) </code><i>type </i>
          <br><em>Description forthcoming.</em>


        



<section name="typeFromDescription:">
<label id="method**GSXMLNode**+typeFromDescription:" />+ <code>(int) </code>
          <b>typeFromDescription: </b>
          <code>(NSString*) </code><i>desc </i>
          <br><em>Description forthcoming.</em>


        



<section name="attributes">
<label id="method**GSXMLNode**-attributes" />- <code>(NSDictionary*) </code>
          <b>attributes </b>
          <br><em>Description forthcoming.</em>


        



<section name="content">
<label id="method**GSXMLNode**-content" />- <code>(NSString*) </code>
          <b>content </b>
          <br><em>Description forthcoming.</em>


        



<section name="document">
<label id="method**GSXMLNode**-document" />- <code>(GSXMLDocument*) </code>
          <b>document </b>
          <br><em>Description forthcoming.</em>


        



<section name="firstAttribute">
<label id="method**GSXMLNode**-firstAttribute" />- <code>(GSXMLAttribute*) </code>
          <b>firstAttribute </b>
          <br><em>Description forthcoming.</em>


        



<section name="firstChild">
<label id="method**GSXMLNode**-firstChild" />- <code>(GSXMLNode*) </code>
          <b>firstChild </b>
          <br><em>Description forthcoming.</em>


        



<section name="firstChildElement">
<label id="method**GSXMLNode**-firstChildElement" />- <code>(GSXMLNode*) </code>
          <b>firstChildElement </b>
          <br><em>Description forthcoming.</em>


        



<section name="lib">
<label id="method**GSXMLNode**-lib" />- <code>(void*) </code>
          <b>lib </b>
          <br><em>Description forthcoming.</em>


        



<section name="makeAttributeWithName:value:">
<label id="method**GSXMLNode**-makeAttributeWithName:value:" />- <code>(GSXMLAttribute*) </code>
          <b>makeAttributeWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>value: </b>
          <code>(NSString*) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeChildWithNamespace:name:content:">
<label id="method**GSXMLNode**-makeChildWithNamespace:name:content:" />- <code>(GSXMLNode*) </code>
          <b>makeChildWithNamespace: </b>
          <code>(GSXMLNamespace*) </code><i>ns </i>
          <b>name: </b>
          <code>(NSString*) </code><i>name </i>
          <b>content: </b>
          <code>(NSString*) </code><i>content </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeComment:">
<label id="method**GSXMLNode**-makeComment:" />- <code>(GSXMLNode*) </code>
          <b>makeComment: </b>
          <code>(NSString*) </code><i>content </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeNamespaceHref:prefix:">
<label id="method**GSXMLNode**-makeNamespaceHref:prefix:" />- <code>(GSXMLNamespace*) </code>
          <b>makeNamespaceHref: </b>
          <code>(NSString*) </code><i>href </i>
          <b>prefix: </b>
          <code>(NSString*) </code><i>prefix </i>
          <br><em>Description forthcoming.</em>


        



<section name="makePI:content:">
<label id="method**GSXMLNode**-makePI:content:" />- <code>(GSXMLNode*) </code>
          <b>makePI: </b>
          <code>(NSString*) </code><i>name </i>
          <b>content: </b>
          <code>(NSString*) </code><i>content </i>
          <br><em>Description forthcoming.</em>


        



<section name="makeText:">
<label id="method**GSXMLNode**-makeText:" />- <code>(GSXMLNode*) </code>
          <b>makeText: </b>
          <code>(NSString*) </code><i>content </i>
          <br><em>Description forthcoming.</em>


        



<section name="name">
<label id="method**GSXMLNode**-name" />- <code>(NSString*) </code>
          <b>name </b>
          <br><em>Description forthcoming.</em>


        



<section name="namespace">
<label id="method**GSXMLNode**-namespace" />- <code>(GSXMLNamespace*) </code>
          <b>namespace </b>
          <br><em>Description forthcoming.</em>


        



<section name="namespaceDefinitions">
<label id="method**GSXMLNode**-namespaceDefinitions" />- <code>(GSXMLNamespace*) </code>
          <b>namespaceDefinitions </b>
          <br><em>Description forthcoming.</em>


        



<section name="next">
<label id="method**GSXMLNode**-next" />- <code>(GSXMLNode*) </code>
          <b>next </b>
          <br><em>Description forthcoming.</em>


        



<section name="nextElement">
<label id="method**GSXMLNode**-nextElement" />- <code>(GSXMLNode*) </code>
          <b>nextElement </b>
          <br><em>Description forthcoming.</em>


        



<section name="objectForKey:">
<label id="method**GSXMLNode**-objectForKey:" />- <code>(NSString*) </code>
          <b>objectForKey: </b>
          <code>(NSString*) </code><i>key </i>
          <br><em>Description forthcoming.</em>


        



<section name="parent">
<label id="method**GSXMLNode**-parent" />- <code>(GSXMLNode*) </code>
          <b>parent </b>
          <br><em>Description forthcoming.</em>


        



<section name="previous">
<label id="method**GSXMLNode**-previous" />- <code>(GSXMLNode*) </code>
          <b>previous </b>
          <br><em>Description forthcoming.</em>


        



<section name="previousElement">
<label id="method**GSXMLNode**-previousElement" />- <code>(GSXMLNode*) </code>
          <b>previousElement </b>
          <br><em>Description forthcoming.</em>


        



<section name="propertiesAsDictionaryWithKeyTransformationSel:">
<label id="method**GSXMLNode**-propertiesAsDictionaryWithKeyTransformationSel:" />- <code>(NSMutableDictionary*) </code>
          <b>propertiesAsDictionaryWithKeyTransformationSel: </b>
          <code>(SEL) </code><i>keyTransformSel </i>
          <br><em>Description forthcoming.</em>


        



<section name="setNamespace:">
<label id="method**GSXMLNode**-setNamespace:" />- <code>(void) </code>
          <b>setNamespace: </b>
          <code>(GSXMLNamespace*) </code><i>space </i>
          <br><em>Description forthcoming.</em>


        



<section name="setObject:forKey:">
<label id="method**GSXMLNode**-setObject:forKey:" />- <code>(void) </code>
          <b>setObject: </b>
          <code>(NSString*) </code><i>value </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>key </i>
          <br><em>Description forthcoming.</em>


        



<section name="type">
<label id="method**GSXMLNode**-type" />- <code>(int) </code>
          <b>type </b>
          <br><em>Description forthcoming.</em>


        



<section name="typeDescription">
<label id="method**GSXMLNode**-typeDescription" />- <code>(NSString*) </code>
          <b>typeDescription </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSInvocation">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSInvocation">NSInvocation</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSInvocation.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="invocationWithMethodSignature:">
<label id="method**NSInvocation**+invocationWithMethodSignature:" />+ <code>(NSInvocation*) </code>
          <b>invocationWithMethodSignature: </b>
          <code>(NSMethodSignature*) </code><i>_signature </i>
          <br><em>Description forthcoming.</em>


        



<section name="argumentsRetained">
<label id="method**NSInvocation**-argumentsRetained" />- <code>(BOOL) </code>
          <b>argumentsRetained </b>
          <br><em>Description forthcoming.</em>


        



<section name="getArgument:atIndex:">
<label id="method**NSInvocation**-getArgument:atIndex:" />- <code>(void) </code>
          <b>getArgument: </b>
          <code>(void*) </code><i>buffer </i>
          <b>atIndex: </b>
          <code>(int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="getReturnValue:">
<label id="method**NSInvocation**-getReturnValue:" />- <code>(void) </code>
          <b>getReturnValue: </b>
          <code>(void*) </code><i>buffer </i>
          <br><em>Description forthcoming.</em>


        



<section name="invoke">
<label id="method**NSInvocation**-invoke" />- <code>(void) </code>
          <b>invoke </b>
          <br><em>Description forthcoming.</em>


        



<section name="invokeWithTarget:">
<label id="method**NSInvocation**-invokeWithTarget:" />- <code>(void) </code>
          <b>invokeWithTarget: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="methodSignature">
<label id="method**NSInvocation**-methodSignature" />- <code>(NSMethodSignature*) </code>
          <b>methodSignature </b>
          <br><em>Description forthcoming.</em>


        



<section name="retainArguments">
<label id="method**NSInvocation**-retainArguments" />- <code>(void) </code>
          <b>retainArguments </b>
          <br><em>Description forthcoming.</em>


        



<section name="selector">
<label id="method**NSInvocation**-selector" />- <code>(SEL) </code>
          <b>selector </b>
          <br><em>Description forthcoming.</em>


        



<section name="setArgument:atIndex:">
<label id="method**NSInvocation**-setArgument:atIndex:" />- <code>(void) </code>
          <b>setArgument: </b>
          <code>(void*) </code><i>buffer </i>
          <b>atIndex: </b>
          <code>(int) </code><i>index </i>
          <br><em>Description forthcoming.</em>


        



<section name="setReturnValue:">
<label id="method**NSInvocation**-setReturnValue:" />- <code>(void) </code>
          <b>setReturnValue: </b>
          <code>(void*) </code><i>buffer </i>
          <br><em>Description forthcoming.</em>


        



<section name="setSelector:">
<label id="method**NSInvocation**-setSelector:" />- <code>(void) </code>
          <b>setSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br><em>Description forthcoming.</em>


        



<section name="setTarget:">
<label id="method**NSInvocation**-setTarget:" />- <code>(void) </code>
          <b>setTarget: </b>
          <code>(id) </code><i>anObject </i>
          <br><em>Description forthcoming.</em>


        



<section name="target">
<label id="method**NSInvocation**-target" />- <code>(id) </code>
          <b>target </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSULongNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSULongNumber">NSULongNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSDistantObject">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDistantObject">NSDistantObject</ref>: <ref id="NSProxy">NSProxy</ref>
<br><b>Conforms to: </b>NSCoding
<br><b>Declared in: </b>NSDistantObject.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
      

<section name="proxyWithLocal:connection:">
<label id="method**NSDistantObject**+proxyWithLocal:connection:" />+ <code>(NSDistantObject*) </code>
          <b>proxyWithLocal: </b>
          <code>(id) </code><i>anObject </i>
          <b>connection: </b>
          <code>(NSConnection*) </code><i>aConnection </i>
          <br><em>Description forthcoming.</em>


        



<section name="proxyWithTarget:connection:">
<label id="method**NSDistantObject**+proxyWithTarget:connection:" />+ <code>(NSDistantObject*) </code>
          <b>proxyWithTarget: </b>
          <code>(unsigned) </code><i>anObject </i>
          <b>connection: </b>
          <code>(NSConnection*) </code><i>aConnection </i>
          <br><em>Description forthcoming.</em>


        



<section name="connectionForProxy">
<label id="method**NSDistantObject**-connectionForProxy" />- <code>(NSConnection*) </code>
          <b>connectionForProxy </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithLocal:connection:">
<label id="method**NSDistantObject**-initWithLocal:connection:" />- <code>(id) </code>
          <b>initWithLocal: </b>
          <code>(id) </code><i>anObject </i>
          <b>connection: </b>
          <code>(NSConnection*) </code><i>aConnection </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithTarget:connection:">
<label id="method**NSDistantObject**-initWithTarget:connection:" />- <code>(id) </code>
          <b>initWithTarget: </b>
          <code>(unsigned) </code><i>target </i>
          <b>connection: </b>
          <code>(NSConnection*) </code><i>aConnection </i>
          <br><em>Description forthcoming.</em>


        



<section name="setProtocolForProxy:">
<label id="method**NSDistantObject**-setProtocolForProxy:" />- <code>(void) </code>
          <b>setProtocolForProxy: </b>
          <code>(Protocol*) </code><i>aProtocol </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSAttributedString">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSAttributedString">NSAttributedString</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSMutableCopying
<br><b>Declared in: </b>NSAttributedString.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="attribute:atIndex:effectiveRange:">
<label id="method**NSAttributedString**-attribute:atIndex:effectiveRange:" />- <code>(id) </code>
          <b>attribute: </b>
          <code>(NSString*) </code><i>attributeName </i>
          <b>atIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <b>effectiveRange: </b>
          <code>(NSRange*) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="attribute:atIndex:longestEffectiveRange:inRange:">
<label id="method**NSAttributedString**-attribute:atIndex:longestEffectiveRange:inRange:" />- <code>(id) </code>
          <b>attribute: </b>
          <code>(NSString*) </code><i>attributeName </i>
          <b>atIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <b>longestEffectiveRange: </b>
          <code>(NSRange*) </code><i>aRange </i>
          <b>inRange: </b>
          <code>(NSRange) </code><i>rangeLimit </i>
          <br><em>Description forthcoming.</em>


        



<section name="attributedSubstringFromRange:">
<label id="method**NSAttributedString**-attributedSubstringFromRange:" />- <code>(NSAttributedString*) </code>
          <b>attributedSubstringFromRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="attributedSubstringWithRange:">
<label id="method**NSAttributedString**-attributedSubstringWithRange:" />- <code>(NSAttributedString*) </code>
          <b>attributedSubstringWithRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="attributesAtIndex:effectiveRange:">
<label id="method**NSAttributedString**-attributesAtIndex:effectiveRange:" />- <code>(NSDictionary*) </code>
          <b>attributesAtIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <b>effectiveRange: </b>
          <code>(NSRange*) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="attributesAtIndex:longestEffectiveRange:inRange:">
<label id="method**NSAttributedString**-attributesAtIndex:longestEffectiveRange:inRange:" />- <code>(NSDictionary*) </code>
          <b>attributesAtIndex: </b>
          <code>(unsigned int) </code><i>index </i>
          <b>longestEffectiveRange: </b>
          <code>(NSRange*) </code><i>aRange </i>
          <b>inRange: </b>
          <code>(NSRange) </code><i>rangeLimit </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithAttributedString:">
<label id="method**NSAttributedString**-initWithAttributedString:" />- <code>(id) </code>
          <b>initWithAttributedString: </b>
          <code>(NSAttributedString*) </code><i>attributedString </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithString:">
<label id="method**NSAttributedString**-initWithString:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithString:attributes:">
<label id="method**NSAttributedString**-initWithString:attributes:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>aString </i>
          <b>attributes: </b>
          <code>(NSDictionary*) </code><i>attributes </i>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToAttributedString:">
<label id="method**NSAttributedString**-isEqualToAttributedString:" />- <code>(BOOL) </code>
          <b>isEqualToAttributedString: </b>
          <code>(NSAttributedString*) </code><i>otherString </i>
          <br><em>Description forthcoming.</em>


        



<section name="length">
<label id="method**NSAttributedString**-length" />- <code>(unsigned int) </code>
          <b>length </b>
          <br><em>Description forthcoming.</em>


        



<section name="string">
<label id="method**NSAttributedString**-string" />- <code>(NSString*) </code>
          <b>string </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSDateFormatter">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDateFormatter">NSDateFormatter</ref>: <ref id="NSFormatter">NSFormatter</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopying
<br><b>Declared in: </b>NSDateFormatter.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
      

<section name="allowsNaturalLanguage">
<label id="method**NSDateFormatter**-allowsNaturalLanguage" />- <code>(BOOL) </code>
          <b>allowsNaturalLanguage </b>
          <br><em>Description forthcoming.</em>


        



<section name="dateFormat">
<label id="method**NSDateFormatter**-dateFormat" />- <code>(NSString*) </code>
          <b>dateFormat </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithDateFormat:allowNaturalLanguage:">
<label id="method**NSDateFormatter**-initWithDateFormat:allowNaturalLanguage:" />- <code>(id) </code>
          <b>initWithDateFormat: </b>
          <code>(NSString*) </code><i>format </i>
          <b>allowNaturalLanguage: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSConnection">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSConnection">NSConnection</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConnection.h
</section>

<section name="Description">
<br>NSConnection objects are used to manage
          communications between objects in different
          processes, in different machines, or in different
          threads.


</section>

<section name="Methods">


<section name="allConnections">
<label id="method**NSConnection**+allConnections" />+ <code>(NSArray*) </code>
          <b>allConnections </b>
          <br>Returns an array containing all the NSConnection
            objects known to the system. These connections will
            be valid at the time that the array was created, but may
            be invalidated by other threads before you get to
            examine the array.


        



<section name="connectionWithReceivePort:sendPort:">
<label id="method**NSConnection**+connectionWithReceivePort:sendPort:" />+ <code>(NSConnection*) </code>
          <b>connectionWithReceivePort: </b>
          <code>(NSPort*) </code><i>r </i>
          <b>sendPort: </b>
          <code>(NSPort*) </code><i>s </i>
          <br>Returns a connection initialised using
            <ref id="method**NSConnection**-initWithReceivePort:sendPort:">
              -initWithReceivePort:sendPort:
            </ref>


        



<section name="connectionWithRegisteredName:host:">
<label id="method**NSConnection**+connectionWithRegisteredName:host:" />+ <code>(NSConnection*) </code>
          <b>connectionWithRegisteredName: </b>
          <code>(NSString*) </code><i>n </i>
          <b>host: </b>
          <code>(NSString*) </code><i>h </i>
          <br>Returns an NSConnection object whose send port is
              that of the NSConnection registered under the name
              <i>n</i> on the host <i>h</i>
            This method calls
              <ref id="method**NSConnection**+connectionWithRegisteredName:host:usingNameServer:">+connectionWithRegisteredName:host:usingNameServer:</ref> using the default system name server.


        



<section name="connectionWithRegisteredName:host:usingNameServer:">
<label id="method**NSConnection**+connectionWithRegisteredName:host:usingNameServer:" />+ <code>(NSConnection*) </code>
          <b>connectionWithRegisteredName: </b>
          <code>(NSString*) </code><i>n </i>
          <b>host: </b>
          <code>(NSString*) </code><i>h </i>
          <b>usingNameServer: </b>
          <code>(NSPortNameServer*) </code><i>s </i>
          <br>Returns an NSConnection object whose send port is
              that of the NSConnection registered under
              <em>name</em> on <em>host</em>.
            The nameserver <em>server</em> is used to look up the
              send port to be used for the connection.
            If <em>host</em> is <code>nil</code> or an empty
              string, the host is taken to be the local
              machine. If it is an asterisk ('*') then the
              nameserver checks all hosts on the local
              subnet (unless the nameserver is one that only
              manages local ports). In the GNUstep
              implementation, the local host is
              searched before any other hosts.
            If no NSConnection can be found for <em>name</em> and
              <em>host</em> host, the method returns
              <code>nil</code>.
            The returned object has the default NSConnection of
              the current thread as its parent (it has the same
              receive port as the default connection).


        



<section name="currentConversation">
<label id="method**NSConnection**+currentConversation" />+ <code>(id) </code>
          <b>currentConversation </b>
          <br>Not used in GNUstep


        



<section name="defaultConnection">
<label id="method**NSConnection**+defaultConnection" />+ <code>(NSConnection*) </code>
          <b>defaultConnection </b>
          <br>Returns the default connection for a thread. 
<br>

            Creates a new instance if necessary. 
<br>
 The
            default connection has a single NSPort object used
            for both sending and receiving - this it can't be used
            to connect to a remote process, but can be used to vend
            objects. 
<br>
 Possible problem - if the
            connection is invalidated, it won't be cleaned
            up until this thread calls this method again. The
            connection and it's ports could hang around for
            a very long time.


        



<section name="rootProxyForConnectionWithRegisteredName:host:">
<label id="method**NSConnection**+rootProxyForConnectionWithRegisteredName:host:" />+ <code>(NSDistantObject*) </code>
          <b>rootProxyForConnectionWithRegisteredName: </b>
          <code>(NSString*) </code><i>n </i>
          <b>host: </b>
          <code>(NSString*) </code><i>h </i>
          <br>This method calls
            <ref id="method**NSConnection**+rootProxyForConnectionWithRegisteredName:host:usingNameServer:">+rootProxyForConnectionWithRegisteredName:host:usingNameServer:</ref> to return a proxy for a root object on the remote connection with the send port registered under name <i>n</i> on host <i>h</i>.


        



<section name="rootProxyForConnectionWithRegisteredName:host:usingNameServer:">
<label id="method**NSConnection**+rootProxyForConnectionWithRegisteredName:host:usingNameServer:" />+ <code>(NSDistantObject*) </code>
          <b>rootProxyForConnectionWithRegisteredName: </b>
          <code>(NSString*) </code><i>n </i>
          <b>host: </b>
          <code>(NSString*) </code><i>h </i>
          <b>usingNameServer: </b>
          <code>(NSPortNameServer*) </code><i>s </i>
          <br>This method calls
            <ref id="method**NSConnection**+connectionWithRegisteredName:host:usingNameServer:">+connectionWithRegisteredName:host:usingNameServer:</ref> to get a connection, then sends it a <ref id="method**NSConnection**-rootProxy">-rootProxy</ref> message to get a proxy for the root object being vended by the remote connection. Returns the proxy or <code>nil</code> if it couldn't find a connection or if the root object for the connection has not been set.


        



<section name="addRequestMode:">
<label id="method**NSConnection**-addRequestMode:" />- <code>(void) </code>
          <b>addRequestMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br>Adds <i>mode</i> to the run loop modes that the
            NSConnection will listen to for incoming
            messages.


        



<section name="addRunLoop:">
<label id="method**NSConnection**-addRunLoop:" />- <code>(void) </code>
          <b>addRunLoop: </b>
          <code>(NSRunLoop*) </code><i>loop </i>
          <br>Adds <i>loop</i> to the set of run loops that the
            NSConnection will listen to for incoming
            messages.


        



<section name="delegate">
<label id="method**NSConnection**-delegate" />- <code>(id) </code>
          <b>delegate </b>
          <br>Returns the delegate of the NSConnection.


        



<section name="enableMultipleThreads">
<label id="method**NSConnection**-enableMultipleThreads" />- <code>(void) </code>
          <b>enableMultipleThreads </b>
          <br>Sets the NSConnection configuration so that multiple
            threads may use the connection to send requests to
            the remote connection. 
<br>
 This option is inherited
            by child connections. 
<br>
 NB. A connection with
            multiple threads enabled will run slower than a
            normal connection.


        



<section name="independentConversationQueueing">
<label id="method**NSConnection**-independentConversationQueueing" />- <code>(BOOL) </code>
          <b>independentConversationQueueing </b>
          <br>Returns <code>YES</code> if the NSConnection is
            configured to handle remote messages atomically,
            <code>NO</code> otherwise. 
<br>
 This option is
            inherited by child connections.


        



<section name="initWithReceivePort:sendPort:">
<label id="method**NSConnection**-initWithReceivePort:sendPort:" />- <code>(id) </code>
          <b>initWithReceivePort: </b>
          <code>(NSPort*) </code><i>r </i>
          <b>sendPort: </b>
          <code>(NSPort*) </code><i>s </i>
          <br>Initialises an NSConnection with the receive
            port <i>r</i> and the send port <i>s</i>.
            
<br>
 Behavior varies with the port values as
            follows -
            
            If a connection exists whose send and receive ports
              are both the same as the new connections receive
              port, that existing connection is deemed to be the
              parent of the new connection. The new connection
              inherits configuration information from the
              parent, and the delegate of the parent has a
              chance to adjust ythe configuration of the new
              connection or veto its creation. 
<br>

              NSConnectionDidInitializeNotification
              is posted once a new connection is initialised.


        



<section name="invalidate">
<label id="method**NSConnection**-invalidate" />- <code>(void) </code>
          <b>invalidate </b>
          <br>Marks the receiving NSConnection as invalid. 
<br>

            Removes the NSConnections ports from any run loops.
            
<br>
 Posts an NSConnectionDidDieNotification.
            
<br>
 Invalidates all remote objects and local
            proxies.


        



<section name="isValid">
<label id="method**NSConnection**-isValid" />- <code>(BOOL) </code>
          <b>isValid </b>
          <br>Returns <code>YES</code> if the connection is
            valid, <code>NO</code> otherwise. A connection is
            valid until it has been sent an
            <ref id="method**NSConnection**-invalidate">
              -invalidate
            </ref>
            message.


        



<section name="localObjects">
<label id="method**NSConnection**-localObjects" />- <code>(NSArray*) </code>
          <b>localObjects </b>
          <br>Returns an array of all the local proxies to
            objects that are retained by the remote connection.


        



<section name="multipleThreadsEnabled">
<label id="method**NSConnection**-multipleThreadsEnabled" />- <code>(BOOL) </code>
          <b>multipleThreadsEnabled </b>
          <br>Returns <code>YES</code> if the connection permits
            multiple threads to use it to send requests,
            <code>NO</code> otherwise. 
<br>
 See the
            <ref id="method**NSConnection**-enableMultipleThreads">
              -enableMultipleThreads
            </ref>
            method.


        



<section name="receivePort">
<label id="method**NSConnection**-receivePort" />- <code>(NSPort*) </code>
          <b>receivePort </b>
          <br>Returns the NSPort object on which incoming
            messages are recieved.


        



<section name="registerName:">
<label id="method**NSConnection**-registerName:" />- <code>(BOOL) </code>
          <b>registerName: </b>
          <code>(NSString*) </code><i>name </i>
          <br>Simply invokes
            <ref id="method**NSConnection**-registerName:withNameServer:">
              -registerName:withNameServer:
            </ref>
            passing it the default system nameserver.


        



<section name="registerName:withNameServer:">
<label id="method**NSConnection**-registerName:withNameServer:" />- <code>(BOOL) </code>
          <b>registerName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>withNameServer: </b>
          <code>(NSPortNameServer*) </code><i>svr </i>
          <br>Registers the recieve port of the NSConnection as
            <i>name</i> and unregisters the previous value
            (if any). 
<br>
 Returns <code>YES</code> on success,
            <code>NO</code> on failure. 
<br>
 On failure, the
            connection remains registered under the previous
            <i>name</i>. 
<br>
 Supply <code>nil</code> as
            <i>name</i> to unregister the NSConnection.


        



<section name="remoteObjects">
<label id="method**NSConnection**-remoteObjects" />- <code>(NSArray*) </code>
          <b>remoteObjects </b>
          <br>Returns an array of proxies to all the remote
            objects known to the NSConnection.


        



<section name="removeRequestMode:">
<label id="method**NSConnection**-removeRequestMode:" />- <code>(void) </code>
          <b>removeRequestMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br>Removes <i>mode</i> from the run loop modes
            used to recieve incoming messages.


        



<section name="removeRunLoop:">
<label id="method**NSConnection**-removeRunLoop:" />- <code>(void) </code>
          <b>removeRunLoop: </b>
          <code>(NSRunLoop*) </code><i>loop </i>
          <br>Removes <i>loop</i> from the run loops used to
            recieve incoming messages.


        



<section name="replyTimeout">
<label id="method**NSConnection**-replyTimeout" />- <code>(NSTimeInterval) </code>
          <b>replyTimeout </b>
          <br>Returns the timeout interval used when waiting for
            a reply to a request sent on the NSConnection. This value
            is inherited from the parent connection or may be set
            using the
            <ref id="method**NSConnection**-setReplyTimeout:">
              -setReplyTimeout:
            </ref>
            method. 
<br>
 Under MacOS-X the default value is
            documented as the maximum delay (effectively
            infinite), but under GNUstep it is set to a more
            useful 300 seconds.


        



<section name="requestModes">
<label id="method**NSConnection**-requestModes" />- <code>(NSArray*) </code>
          <b>requestModes </b>
          <br>Returns an array of all the run loop modes that the
            NSConnection uses when waiting for an incoming
            request.


        



<section name="requestTimeout">
<label id="method**NSConnection**-requestTimeout" />- <code>(NSTimeInterval) </code>
          <b>requestTimeout </b>
          <br>Returns the timeout interval used when trying to
            send a request on the NSConnection. This value is
            inherited from the parent connection or may be
            set using the
            <ref id="method**NSConnection**-setRequestTimeout:">
              -setRequestTimeout:
            </ref>
            method. 
<br>
 Under MacOS-X the default value is
            documented as the maximum delay (effectively
            infinite), but under GNUstep it is set to a more
            useful 300 seconds.


        



<section name="rootObject">
<label id="method**NSConnection**-rootObject" />- <code>(id) </code>
          <b>rootObject </b>
          <br>Returns the object that is made available by this
            connection or by its parent (the object is
            associated with the receive port). 
<br>

            Returns <code>nil</code> if no root object has been
            set.


        



<section name="rootProxy">
<label id="method**NSConnection**-rootProxy" />- <code>(NSDistantObject*) </code>
          <b>rootProxy </b>
          <br>Returns the proxy for the root object of the remote
            NSConnection.


        



<section name="runInNewThread">
<label id="method**NSConnection**-runInNewThread" />- <code>(void) </code>
          <b>runInNewThread </b>
          <br>Removes the NSConnection from the current threads
            default run loop, then creates a new thread and
            runs the NSConnection in it.


        



<section name="sendPort">
<label id="method**NSConnection**-sendPort" />- <code>(NSPort*) </code>
          <b>sendPort </b>
          <br>Returns the port on which the NSConnection sends
            messages.


        



<section name="setDelegate:">
<label id="method**NSConnection**-setDelegate:" />- <code>(void) </code>
          <b>setDelegate: </b>
          <code>(id) </code><i>anObj </i>
          <br>Sets the NSConnection's delegate (without retaining
            it). 
<br>
 The delegate is able to control some of
            the NSConnection's behavior by implementing methods in
            an informal protocol.


        



<section name="setIndependentConversationQueueing:">
<label id="method**NSConnection**-setIndependentConversationQueueing:" />- <code>(void) </code>
          <b>setIndependentConversationQueueing: </b>
          <code>(BOOL) </code><i>flag </i>
          <br>Sets whether or not the NSConnection should handle
            requests arriving from the remote NSConnection
            atomically. 
<br>
 By default, this is set to
            <code>NO</code>... if set to <code>YES</code> then
            any messages arriving while one message is being dealt
            with, will be queued. 
<br>
 NB. careful - use of
            this option can cause deadlocks.


        



<section name="setReplyTimeout:">
<label id="method**NSConnection**-setReplyTimeout:" />- <code>(void) </code>
          <b>setReplyTimeout: </b>
          <code>(NSTimeInterval) </code><i>to </i>
          <br>Sets the time interval that the NSConnection will wait
            for a reply for one of its requests before raising an
            NSPortTimeoutException. 
<br>
 NB.
            In GNUstep you may also get such an exception if the
            connection becomes invalidated while waiting for
            a reply <i>to</i> a request.


        



<section name="setRequestMode:">
<label id="method**NSConnection**-setRequestMode:" />- <code>(void) </code>
          <b>setRequestMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br>Sets the runloop <i>mode</i> in which requests
            will be sent to the remote end of the connection.


        



<section name="setRequestTimeout:">
<label id="method**NSConnection**-setRequestTimeout:" />- <code>(void) </code>
          <b>setRequestTimeout: </b>
          <code>(NSTimeInterval) </code><i>to </i>
          <br>Sets the time interval that the NSConnection will wait
            <i>to</i> send one of its requests before raising
            an NSPortTimeoutException.


        



<section name="setRootObject:">
<label id="method**NSConnection**-setRootObject:" />- <code>(void) </code>
          <b>setRootObject: </b>
          <code>(id) </code><i>anObj </i>
          <br>Sets the root object that is vended by the connection.


        



<section name="statistics">
<label id="method**NSConnection**-statistics" />- <code>(NSDictionary*) </code>
          <b>statistics </b>
          <br>Returns an object containing various statistics for
            the NSConnection. 
<br>
 On GNUstep the dictionary
            contains -


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSThread">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSThread">NSThread</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSThread.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="currentThread">
<label id="method**NSThread**+currentThread" />+ <code>(NSThread*) </code>
          <b>currentThread </b>
          <br>Returns the NSThread object corresponding to the
              current thread.
            NB. In GNUstep the library internals use the
              <ref id="function**NSThread**GSCurrentThread">
                GSCurrentThread()
              </ref>
              function as a more efficient mechanism for doing
              this job - so you cannot use a category to override
              this method and expect the library internals to use
              your implementation.


        



<section name="detachNewThreadSelector:toTarget:withObject:">
<label id="method**NSThread**+detachNewThreadSelector:toTarget:withObject:" />+ <code>(void) </code>
          <b>detachNewThreadSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>toTarget: </b>
          <code>(id) </code><i>aTarget </i>
          <b>withObject: </b>
          <code>(id) </code><i>anArgument </i>
          <br>Create a new thread - use this method rather than
            alloc-init


        



<section name="exit">
<label id="method**NSThread**+exit" />+ <code>(void) </code>
          <b>exit </b>
          <br>Terminating a thread What happens if the thread
            doesn't call
            <ref id="method**NSThread**+exit">
              +exit
            </ref>
            - it doesn't terminate!


        



<section name="isMultiThreaded">
<label id="method**NSThread**+isMultiThreaded" />+ <code>(BOOL) </code>
          <b>isMultiThreaded </b>
          <br>Returns a flag to say whether the application is
            multi-threaded or not. An application is
            considered to be multi-threaded if any thread
            other than the main thread has been started,
            irrespective of whether that thread has since
            terminated.


        



<section name="setThreadPriority:">
<label id="method**NSThread**+setThreadPriority:" />+ <code>(void) </code>
          <b>setThreadPriority: </b>
          <code>(double) </code><i>pri </i>
          <br>Set the priority of the current thread. This is a value
            in the range 0.0 (lowest) to 1.0 (highest) which is
            mapped to the underlying system priorities. The
            current gnu objc runtime supports three priority
            levels which you can obtain using values of 0.0,
            0.5, and 1.0


        



<section name="sleepUntilDate:">
<label id="method**NSThread**+sleepUntilDate:" />+ <code>(void) </code>
          <b>sleepUntilDate: </b>
          <code>(NSDate*) </code><i>date </i>
          <br>Delaying a thread... pause until the specified
            <i>date</i>.


        



<section name="threadPriority">
<label id="method**NSThread**+threadPriority" />+ <code>(double) </code>
          <b>threadPriority </b>
          <br>Return the priority of the current thread.


        



<section name="threadDictionary">
<label id="method**NSThread**-threadDictionary" />- <code>(NSMutableDictionary*) </code>
          <b>threadDictionary </b>
          <br>Return the thread dictionary. This dictionary can be
            used to store arbitrary thread specific data. 
<br>

            NB. This cannot be autoreleased, since we cannot be
            sure that the autorelease pool for the thread will
            continue to exist for the entire life of the
            thread!


        


</section>


</chapter>


<chapter name="NSSocketPort">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSSocketPort">NSSocketPort</ref>: <ref id="NSPort">NSPort</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopying
<br><b>Declared in: </b>NSPort.h
</section>

<section name="Description">
<br><code>NSSocketPort</code> on MacOS X(tm) is a
            concrete subclass of NSPort which implements
            Distributed Objects communication between hosts
            on a network. However, the GNUstep distributed objects
            system's NSPort class uses TCP/IP for all of its
            communication. The GNUstep
            <code>NSSocketPort</code>, then, is useful as a
            convenient method to create and encapsulate BSD
            sockets:


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="address">
<label id="method**NSSocketPort**-address" />- <code>(NSData*) </code>
          <b>address </b>
          <br>Return the protocol family-specific socket address
            in an NSData object.


        



<section name="init">
<label id="method**NSSocketPort**-init" />- <code>(id) </code>
          <b>init </b>
          <br>Initialize the receiver with a local socket to
            accept TCP connections on a non-conflicting port
            number chosen by the system.


        



<section name="initRemoteWithProtocolFamily:socketType:protocol:address:">
<label id="method**NSSocketPort**-initRemoteWithProtocolFamily:socketType:protocol:address:" />- <code>(id) </code>
          <b>initRemoteWithProtocolFamily: </b>
          <code>(int) </code><i>family </i>
          <b>socketType: </b>
          <code>(int) </code><i>type </i>
          <b>protocol: </b>
          <code>(int) </code><i>protocol </i>
          <b>address: </b>
          <code>(NSData*) </code><i>addrData </i>
          <br>Initialize the receiver to connect to a remote
            socket of <em><i>type</i></em> with
            <em><i>protocol</i></em> from the
            <i>protocol</i> <i>family</i>
            <em><i>family</i></em>. The
            <em><i>addrData</i></em> should contain a copy of
            the <i>protocol</i> family-specific address data in
            an NSData object.


        



<section name="initRemoteWithTCPPort:host:">
<label id="method**NSSocketPort**-initRemoteWithTCPPort:host:" />- <code>(id) </code>
          <b>initRemoteWithTCPPort: </b>
          <code>(unsigned short) </code><i>portNumber </i>
          <b>host: </b>
          <code>(NSString*) </code><i>hostname </i>
          <br>Initialize the receiver to connect to a remote
            TCP socket on port <em><i>portNumber</i></em> of
            host <em><i>hostname</i></em>. The receiver delays
            initiation of the connection until it has data
            to send. 
<br>
 NOTE: This method currently does not
            support IPv6 connections.


        



<section name="initWithProtocolFamily:socketType:protocol:address:">
<label id="method**NSSocketPort**-initWithProtocolFamily:socketType:protocol:address:" />- <code>(id) </code>
          <b>initWithProtocolFamily: </b>
          <code>(int) </code><i>family </i>
          <b>socketType: </b>
          <code>(int) </code><i>type </i>
          <b>protocol: </b>
          <code>(int) </code><i>protocol </i>
          <b>address: </b>
          <code>(NSData*) </code><i>addrData </i>
          <br>Initialize the receiver as a local socket to
            accept connections on a socket of
            <em><i>type</i></em> with the
            <em><i>protocol</i></em> from the
            <i>protocol</i> <i>family</i>
            <em><i>family</i></em>. The
            <em><i>addrData</i></em> should contain a copy of
            the <i>protocol</i> family-specific address data in
            an NSData object.


        



<section name="initWithProtocolFamily:socketType:protocol:socket:">
<label id="method**NSSocketPort**-initWithProtocolFamily:socketType:protocol:socket:" />- <code>(id) </code>
          <b>initWithProtocolFamily: </b>
          <code>(int) </code><i>family </i>
          <b>socketType: </b>
          <code>(int) </code><i>type </i>
          <b>protocol: </b>
          <code>(int) </code><i>protocol </i>
          <b>socket: </b>
          <code>(NSSocketNativeHandle) </code><i>socket </i>
          <br>Initialize the receiver with
            <em><i>socket</i></em>, the platform-native handle
            to a previously initialized listen-mode
            <i>socket</i> of <i>type</i>
            <em><i>type</i></em> with the <i>protocol</i>
            <em><i>protocol</i></em> from the
            <i>protocol</i> <i>family</i>
            <em><i>family</i></em>. 
<br>
 The receiver will
            close the <i>socket</i> upon deallocation.


        



<section name="initWithTCPPort:">
<label id="method**NSSocketPort**-initWithTCPPort:" />- <code>(id) </code>
          <b>initWithTCPPort: </b>
          <code>(unsigned short) </code><i>portNumber </i>
          <br>Initialize the receiver as a local socket to
            accept connections on TCP port
            <em><i>portNumber</i></em>. If
            <em><i>portNumber</i></em> is zero, the system
            will chose a non-conflicting port number. 
<br>
 NOTE:
            This method currently does not support IPv6
            connections.


        



<section name="protocol">
<label id="method**NSSocketPort**-protocol" />- <code>(int) </code>
          <b>protocol </b>
          <br>Return the socket protocol.


        



<section name="protocolFamily">
<label id="method**NSSocketPort**-protocolFamily" />- <code>(int) </code>
          <b>protocolFamily </b>
          <br>Return the socket protocol family.


        



<section name="socket">
<label id="method**NSSocketPort**-socket" />- <code>(NSSocketNativeHandle) </code>
          <b>socket </b>
          <br>Return the platform-native socket handle.


        



<section name="socketType">
<label id="method**NSSocketPort**-socketType" />- <code>(int) </code>
          <b>socketType </b>
          <br>Return the socket type.


        


</section>


</chapter>


<chapter name="NSDecimalNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSDecimalNumber">NSDecimalNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSDecimalNumberBehaviors
<br><b>Declared in: </b>NSDecimalNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="decimalNumberWithDecimal:">
<label id="method**NSDecimalNumber**+decimalNumberWithDecimal:" />+ <code>(NSDecimalNumber*) </code>
          <b>decimalNumberWithDecimal: </b>
          <code>(NSDecimal) </code><i>decimal </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberWithMantissa:exponent:isNegative:">
<label id="method**NSDecimalNumber**+decimalNumberWithMantissa:exponent:isNegative:" />+ <code>(NSDecimalNumber*) </code>
          <b>decimalNumberWithMantissa: </b>
          <code>(unsigned long long) </code><i>mantissa </i>
          <b>exponent: </b>
          <code>(short) </code><i>exponent </i>
          <b>isNegative: </b>
          <code>(BOOL) </code><i>isNegative </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberWithString:">
<label id="method**NSDecimalNumber**+decimalNumberWithString:" />+ <code>(NSDecimalNumber*) </code>
          <b>decimalNumberWithString: </b>
          <code>(NSString*) </code><i>numericString </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberWithString:locale:">
<label id="method**NSDecimalNumber**+decimalNumberWithString:locale:" />+ <code>(NSDecimalNumber*) </code>
          <b>decimalNumberWithString: </b>
          <code>(NSString*) </code><i>numericString </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br><em>Description forthcoming.</em>


        



<section name="defaultBehavior">
<label id="method**NSDecimalNumber**+defaultBehavior" />+ <code>(id&#60;NSDecimalNumberBehaviors>) </code>
          <b>defaultBehavior </b>
          <br><em>Description forthcoming.</em>


        



<section name="maximumDecimalNumber">
<label id="method**NSDecimalNumber**+maximumDecimalNumber" />+ <code>(NSDecimalNumber*) </code>
          <b>maximumDecimalNumber </b>
          <br><em>Description forthcoming.</em>


        



<section name="minimumDecimalNumber">
<label id="method**NSDecimalNumber**+minimumDecimalNumber" />+ <code>(NSDecimalNumber*) </code>
          <b>minimumDecimalNumber </b>
          <br><em>Description forthcoming.</em>


        



<section name="notANumber">
<label id="method**NSDecimalNumber**+notANumber" />+ <code>(NSDecimalNumber*) </code>
          <b>notANumber </b>
          <br><em>Description forthcoming.</em>


        



<section name="one">
<label id="method**NSDecimalNumber**+one" />+ <code>(NSDecimalNumber*) </code>
          <b>one </b>
          <br><em>Description forthcoming.</em>


        



<section name="setDefaultBehavior:">
<label id="method**NSDecimalNumber**+setDefaultBehavior:" />+ <code>(void) </code>
          <b>setDefaultBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="zero">
<label id="method**NSDecimalNumber**+zero" />+ <code>(NSDecimalNumber*) </code>
          <b>zero </b>
          <br><em>Description forthcoming.</em>


        



<section name="compare:">
<label id="method**NSDecimalNumber**-compare:" />- <code>(NSComparisonResult) </code>
          <b>compare: </b>
          <code>(NSNumber*) </code><i>decimalNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByAdding:">
<label id="method**NSDecimalNumber**-decimalNumberByAdding:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByAdding: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByAdding:withBehavior:">
<label id="method**NSDecimalNumber**-decimalNumberByAdding:withBehavior:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByAdding: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <b>withBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByDividingBy:">
<label id="method**NSDecimalNumber**-decimalNumberByDividingBy:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByDividingBy: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByDividingBy:withBehavior:">
<label id="method**NSDecimalNumber**-decimalNumberByDividingBy:withBehavior:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByDividingBy: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <b>withBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByMultiplyingBy:">
<label id="method**NSDecimalNumber**-decimalNumberByMultiplyingBy:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByMultiplyingBy: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByMultiplyingBy:withBehavior:">
<label id="method**NSDecimalNumber**-decimalNumberByMultiplyingBy:withBehavior:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByMultiplyingBy: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <b>withBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByMultiplyingByPowerOf10:">
<label id="method**NSDecimalNumber**-decimalNumberByMultiplyingByPowerOf10:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByMultiplyingByPowerOf10: </b>
          <code>(short) </code><i>power </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByMultiplyingByPowerOf10:withBehavior:">
<label id="method**NSDecimalNumber**-decimalNumberByMultiplyingByPowerOf10:withBehavior:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByMultiplyingByPowerOf10: </b>
          <code>(short) </code><i>power </i>
          <b>withBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByRaisingToPower:">
<label id="method**NSDecimalNumber**-decimalNumberByRaisingToPower:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByRaisingToPower: </b>
          <code>(unsigned) </code><i>power </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByRaisingToPower:withBehavior:">
<label id="method**NSDecimalNumber**-decimalNumberByRaisingToPower:withBehavior:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByRaisingToPower: </b>
          <code>(unsigned) </code><i>power </i>
          <b>withBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberByRoundingAccordingToBehavior:">
<label id="method**NSDecimalNumber**-decimalNumberByRoundingAccordingToBehavior:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberByRoundingAccordingToBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberBySubtracting:">
<label id="method**NSDecimalNumber**-decimalNumberBySubtracting:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberBySubtracting: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalNumberBySubtracting:withBehavior:">
<label id="method**NSDecimalNumber**-decimalNumberBySubtracting:withBehavior:" />- <code>(NSDecimalNumber*) </code>
          <b>decimalNumberBySubtracting: </b>
          <code>(NSDecimalNumber*) </code><i>decimalNumber </i>
          <b>withBehavior: </b>
          <code>(id&#60;NSDecimalNumberBehaviors>) </code><i>behavior </i>
          <br><em>Description forthcoming.</em>


        



<section name="decimalValue">
<label id="method**NSDecimalNumber**-decimalValue" />- <code>(NSDecimal) </code>
          <b>decimalValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="descriptionWithLocale:">
<label id="method**NSDecimalNumber**-descriptionWithLocale:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br><em>Description forthcoming.</em>


        



<section name="doubleValue">
<label id="method**NSDecimalNumber**-doubleValue" />- <code>(double) </code>
          <b>doubleValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithDecimal:">
<label id="method**NSDecimalNumber**-initWithDecimal:" />- <code>(id) </code>
          <b>initWithDecimal: </b>
          <code>(NSDecimal) </code><i>decimal </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithMantissa:exponent:isNegative:">
<label id="method**NSDecimalNumber**-initWithMantissa:exponent:isNegative:" />- <code>(id) </code>
          <b>initWithMantissa: </b>
          <code>(unsigned long long) </code><i>mantissa </i>
          <b>exponent: </b>
          <code>(short) </code><i>exponent </i>
          <b>isNegative: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithString:">
<label id="method**NSDecimalNumber**-initWithString:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>numberValue </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithString:locale:">
<label id="method**NSDecimalNumber**-initWithString:locale:" />- <code>(id) </code>
          <b>initWithString: </b>
          <code>(NSString*) </code><i>numberValue </i>
          <b>locale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br><em>Description forthcoming.</em>


        



<section name="objCType">
<label id="method**NSDecimalNumber**-objCType" />- <code>(const char*) </code>
          <b>objCType </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSMutableSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableSet">NSMutableSet</ref>: <ref id="NSSet">NSSet</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSSet.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="setWithCapacity:">
<label id="method**NSMutableSet**+setWithCapacity:" />+ <code>(id) </code>
          <b>setWithCapacity: </b>
          <code>(unsigned) </code><i>numItems </i>
          <br><em>Description forthcoming.</em>


        



<section name="addObject:">
<label id="method**NSMutableSet**-addObject:" />- <code>(void) </code>
          <b>addObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Adds <i>anObject</i> to the set. 
<br>
 The object
            is retained by the set.


        



<section name="addObjectsFromArray:">
<label id="method**NSMutableSet**-addObjectsFromArray:" />- <code>(void) </code>
          <b>addObjectsFromArray: </b>
          <code>(NSArray*) </code><i>array </i>
          <br>Adds all the objects in the <i>array</i> to the
            receiver.


        



<section name="initWithCapacity:">
<label id="method**NSMutableSet**-initWithCapacity:" />- <code>(id) </code>
          <b>initWithCapacity: </b>
          <code>(unsigned) </code><i>numItems </i>
          <br>Initialises a newly allocated set to contain no
            objects but to have space available to hold the
            specified number of items. 
<br>
 Additions of
            items to a set initialised with an appropriate
            capacity will be more efficient than addition of
            items otherwise.


        



<section name="intersectSet:">
<label id="method**NSMutableSet**-intersectSet:" />- <code>(void) </code>
          <b>intersectSet: </b>
          <code>(NSSet*) </code><i>other </i>
          <br>Removes from the receiver all the objects it
            contains which are not also in <i>other</i>.


        



<section name="minusSet:">
<label id="method**NSMutableSet**-minusSet:" />- <code>(void) </code>
          <b>minusSet: </b>
          <code>(NSSet*) </code><i>other </i>
          <br>Removes from the receiver all the objects that are
            in <i>other</i>.


        



<section name="removeAllObjects">
<label id="method**NSMutableSet**-removeAllObjects" />- <code>(void) </code>
          <b>removeAllObjects </b>
          <br>Removes all objects from the receiver.


        



<section name="removeObject:">
<label id="method**NSMutableSet**-removeObject:" />- <code>(void) </code>
          <b>removeObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Removes the <i>anObject</i> from the receiver.


        



<section name="setSet:">
<label id="method**NSMutableSet**-setSet:" />- <code>(void) </code>
          <b>setSet: </b>
          <code>(NSSet*) </code><i>other </i>
          <br>Removes all objects from the receiver then adds the
            objects from <i>other</i>. If the receiver
            <em>is</em> <i>other</i>, the method has no
            effect.


        



<section name="unionSet:">
<label id="method**NSMutableSet**-unionSet:" />- <code>(void) </code>
          <b>unionSet: </b>
          <code>(NSSet*) </code><i>other </i>
          <br>Adds all the objects from <i>other</i> to the
            receiver.


        


        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCopyingNSCoding
<br><b>Declared in: </b>NSValue.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="numberWithBool:">
<label id="method**NSNumber**+numberWithBool:" />+ <code>(NSNumber*) </code>
          <b>numberWithBool: </b>
          <code>(BOOL) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithChar:">
<label id="method**NSNumber**+numberWithChar:" />+ <code>(NSNumber*) </code>
          <b>numberWithChar: </b>
          <code>(signed char) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithDouble:">
<label id="method**NSNumber**+numberWithDouble:" />+ <code>(NSNumber*) </code>
          <b>numberWithDouble: </b>
          <code>(double) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithFloat:">
<label id="method**NSNumber**+numberWithFloat:" />+ <code>(NSNumber*) </code>
          <b>numberWithFloat: </b>
          <code>(float) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithInt:">
<label id="method**NSNumber**+numberWithInt:" />+ <code>(NSNumber*) </code>
          <b>numberWithInt: </b>
          <code>(signed int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithLong:">
<label id="method**NSNumber**+numberWithLong:" />+ <code>(NSNumber*) </code>
          <b>numberWithLong: </b>
          <code>(signed long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithLongLong:">
<label id="method**NSNumber**+numberWithLongLong:" />+ <code>(NSNumber*) </code>
          <b>numberWithLongLong: </b>
          <code>(signed long long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithShort:">
<label id="method**NSNumber**+numberWithShort:" />+ <code>(NSNumber*) </code>
          <b>numberWithShort: </b>
          <code>(signed short) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithUnsignedChar:">
<label id="method**NSNumber**+numberWithUnsignedChar:" />+ <code>(NSNumber*) </code>
          <b>numberWithUnsignedChar: </b>
          <code>(unsigned char) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithUnsignedInt:">
<label id="method**NSNumber**+numberWithUnsignedInt:" />+ <code>(NSNumber*) </code>
          <b>numberWithUnsignedInt: </b>
          <code>(unsigned int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithUnsignedLong:">
<label id="method**NSNumber**+numberWithUnsignedLong:" />+ <code>(NSNumber*) </code>
          <b>numberWithUnsignedLong: </b>
          <code>(unsigned long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithUnsignedLongLong:">
<label id="method**NSNumber**+numberWithUnsignedLongLong:" />+ <code>(NSNumber*) </code>
          <b>numberWithUnsignedLongLong: </b>
          <code>(unsigned long long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="numberWithUnsignedShort:">
<label id="method**NSNumber**+numberWithUnsignedShort:" />+ <code>(NSNumber*) </code>
          <b>numberWithUnsignedShort: </b>
          <code>(unsigned short) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="boolValue">
<label id="method**NSNumber**-boolValue" />- <code>(BOOL) </code>
          <b>boolValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="charValue">
<label id="method**NSNumber**-charValue" />- <code>(signed char) </code>
          <b>charValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="compare:">
<label id="method**NSNumber**-compare:" />- <code>(NSComparisonResult) </code>
          <b>compare: </b>
          <code>(NSNumber*) </code><i>otherNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="description">
<label id="method**NSNumber**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br><em>Description forthcoming.</em>


        



<section name="descriptionWithLocale:">
<label id="method**NSNumber**-descriptionWithLocale:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br><em>Description forthcoming.</em>


        



<section name="doubleValue">
<label id="method**NSNumber**-doubleValue" />- <code>(double) </code>
          <b>doubleValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="floatValue">
<label id="method**NSNumber**-floatValue" />- <code>(float) </code>
          <b>floatValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithBool:">
<label id="method**NSNumber**-initWithBool:" />- <code>(id) </code>
          <b>initWithBool: </b>
          <code>(BOOL) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithChar:">
<label id="method**NSNumber**-initWithChar:" />- <code>(id) </code>
          <b>initWithChar: </b>
          <code>(signed char) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithDouble:">
<label id="method**NSNumber**-initWithDouble:" />- <code>(id) </code>
          <b>initWithDouble: </b>
          <code>(double) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithFloat:">
<label id="method**NSNumber**-initWithFloat:" />- <code>(id) </code>
          <b>initWithFloat: </b>
          <code>(float) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithInt:">
<label id="method**NSNumber**-initWithInt:" />- <code>(id) </code>
          <b>initWithInt: </b>
          <code>(signed int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithLong:">
<label id="method**NSNumber**-initWithLong:" />- <code>(id) </code>
          <b>initWithLong: </b>
          <code>(signed long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithLongLong:">
<label id="method**NSNumber**-initWithLongLong:" />- <code>(id) </code>
          <b>initWithLongLong: </b>
          <code>(signed long long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithShort:">
<label id="method**NSNumber**-initWithShort:" />- <code>(id) </code>
          <b>initWithShort: </b>
          <code>(signed short) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithUnsignedChar:">
<label id="method**NSNumber**-initWithUnsignedChar:" />- <code>(id) </code>
          <b>initWithUnsignedChar: </b>
          <code>(unsigned char) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithUnsignedInt:">
<label id="method**NSNumber**-initWithUnsignedInt:" />- <code>(id) </code>
          <b>initWithUnsignedInt: </b>
          <code>(unsigned int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithUnsignedLong:">
<label id="method**NSNumber**-initWithUnsignedLong:" />- <code>(id) </code>
          <b>initWithUnsignedLong: </b>
          <code>(unsigned long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithUnsignedLongLong:">
<label id="method**NSNumber**-initWithUnsignedLongLong:" />- <code>(id) </code>
          <b>initWithUnsignedLongLong: </b>
          <code>(unsigned long long) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithUnsignedShort:">
<label id="method**NSNumber**-initWithUnsignedShort:" />- <code>(id) </code>
          <b>initWithUnsignedShort: </b>
          <code>(unsigned short) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="intValue">
<label id="method**NSNumber**-intValue" />- <code>(signed int) </code>
          <b>intValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="isEqualToNumber:">
<label id="method**NSNumber**-isEqualToNumber:" />- <code>(BOOL) </code>
          <b>isEqualToNumber: </b>
          <code>(NSNumber*) </code><i>otherNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="longLongValue">
<label id="method**NSNumber**-longLongValue" />- <code>(signed long long) </code>
          <b>longLongValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="longValue">
<label id="method**NSNumber**-longValue" />- <code>(signed long) </code>
          <b>longValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="shortValue">
<label id="method**NSNumber**-shortValue" />- <code>(signed short) </code>
          <b>shortValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="stringValue">
<label id="method**NSNumber**-stringValue" />- <code>(NSString*) </code>
          <b>stringValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="unsignedCharValue">
<label id="method**NSNumber**-unsignedCharValue" />- <code>(unsigned char) </code>
          <b>unsignedCharValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="unsignedIntValue">
<label id="method**NSNumber**-unsignedIntValue" />- <code>(unsigned int) </code>
          <b>unsignedIntValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="unsignedLongLongValue">
<label id="method**NSNumber**-unsignedLongLongValue" />- <code>(unsigned long long) </code>
          <b>unsignedLongLongValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="unsignedLongValue">
<label id="method**NSNumber**-unsignedLongValue" />- <code>(unsigned long) </code>
          <b>unsignedLongValue </b>
          <br><em>Description forthcoming.</em>


        



<section name="unsignedShortValue">
<label id="method**NSNumber**-unsignedShortValue" />- <code>(unsigned short) </code>
          <b>unsignedShortValue </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="GSMimeParser">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSMimeParser">GSMimeParser</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSMime.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="documentFromData:">
<label id="method**GSMimeParser**+documentFromData:" />+ <code>(GSMimeDocument*) </code>
          <b>documentFromData: </b>
          <code>(NSData*) </code><i>mimeData </i>
          <br><em>Description forthcoming.</em>


        



<section name="mimeParser">
<label id="method**GSMimeParser**+mimeParser" />+ <code>(GSMimeParser*) </code>
          <b>mimeParser </b>
          <br><em>Description forthcoming.</em>


        



<section name="contextFor:">
<label id="method**GSMimeParser**-contextFor:" />- <code>(GSMimeCodingContext*) </code>
          <b>contextFor: </b>
          <code>(GSMimeHeader*) </code><i>info </i>
          <br><em>Description forthcoming.</em>


        



<section name="data">
<label id="method**GSMimeParser**-data" />- <code>(NSData*) </code>
          <b>data </b>
          <br><em>Description forthcoming.</em>


        



<section name="decodeData:fromRange:intoData:withContext:">
<label id="method**GSMimeParser**-decodeData:fromRange:intoData:withContext:" />- <code>(BOOL) </code>
          <b>decodeData: </b>
          <code>(NSData*) </code><i>sData </i>
          <b>fromRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>intoData: </b>
          <code>(NSMutableData*) </code><i>dData </i>
          <b>withContext: </b>
          <code>(GSMimeCodingContext*) </code><i>con </i>
          <br><em>Description forthcoming.</em>


        



<section name="expectNoHeaders">
<label id="method**GSMimeParser**-expectNoHeaders" />- <code>(void) </code>
          <b>expectNoHeaders </b>
          <br><em>Description forthcoming.</em>


        



<section name="isComplete">
<label id="method**GSMimeParser**-isComplete" />- <code>(BOOL) </code>
          <b>isComplete </b>
          <br><em>Description forthcoming.</em>


        



<section name="isHttp">
<label id="method**GSMimeParser**-isHttp" />- <code>(BOOL) </code>
          <b>isHttp </b>
          <br><em>Description forthcoming.</em>


        



<section name="isInBody">
<label id="method**GSMimeParser**-isInBody" />- <code>(BOOL) </code>
          <b>isInBody </b>
          <br><em>Description forthcoming.</em>


        



<section name="isInHeaders">
<label id="method**GSMimeParser**-isInHeaders" />- <code>(BOOL) </code>
          <b>isInHeaders </b>
          <br><em>Description forthcoming.</em>


        



<section name="mimeDocument">
<label id="method**GSMimeParser**-mimeDocument" />- <code>(GSMimeDocument*) </code>
          <b>mimeDocument </b>
          <br><em>Description forthcoming.</em>


        



<section name="parse:">
<label id="method**GSMimeParser**-parse:" />- <code>(BOOL) </code>
          <b>parse: </b>
          <code>(NSData*) </code><i>d </i>
          <br><em>Description forthcoming.</em>


        



<section name="parseHeader:">
<label id="method**GSMimeParser**-parseHeader:" />- <code>(BOOL) </code>
          <b>parseHeader: </b>
          <code>(NSString*) </code><i>aHeader </i>
          <br><em>Description forthcoming.</em>


        



<section name="scanHeaderBody:into:">
<label id="method**GSMimeParser**-scanHeaderBody:into:" />- <code>(BOOL) </code>
          <b>scanHeaderBody: </b>
          <code>(NSScanner*) </code><i>scanner </i>
          <b>into: </b>
          <code>(GSMimeHeader*) </code><i>info </i>
          <br><em>Description forthcoming.</em>


        



<section name="scanName:">
<label id="method**GSMimeParser**-scanName:" />- <code>(NSString*) </code>
          <b>scanName: </b>
          <code>(NSScanner*) </code><i>scanner </i>
          <br><em>Description forthcoming.</em>


        



<section name="scanPastSpace:">
<label id="method**GSMimeParser**-scanPastSpace:" />- <code>(BOOL) </code>
          <b>scanPastSpace: </b>
          <code>(NSScanner*) </code><i>scanner </i>
          <br><em>Description forthcoming.</em>


        



<section name="scanSpecial:">
<label id="method**GSMimeParser**-scanSpecial:" />- <code>(NSString*) </code>
          <b>scanSpecial: </b>
          <code>(NSScanner*) </code><i>scanner </i>
          <br><em>Description forthcoming.</em>


        



<section name="scanToken:">
<label id="method**GSMimeParser**-scanToken:" />- <code>(NSString*) </code>
          <b>scanToken: </b>
          <code>(NSScanner*) </code><i>scanner </i>
          <br><em>Description forthcoming.</em>


        



<section name="setBuggyQuotes:">
<label id="method**GSMimeParser**-setBuggyQuotes:" />- <code>(void) </code>
          <b>setBuggyQuotes: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="setIsHttp">
<label id="method**GSMimeParser**-setIsHttp" />- <code>(void) </code>
          <b>setIsHttp </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSMutableCharacterSet">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableCharacterSet">NSMutableCharacterSet</ref>: <ref id="NSCharacterSet">NSCharacterSet</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSCharacterSet.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="addCharactersInRange:">
<label id="method**NSMutableCharacterSet**-addCharactersInRange:" />- <code>(void) </code>
          <b>addCharactersInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="addCharactersInString:">
<label id="method**NSMutableCharacterSet**-addCharactersInString:" />- <code>(void) </code>
          <b>addCharactersInString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="formIntersectionWithCharacterSet:">
<label id="method**NSMutableCharacterSet**-formIntersectionWithCharacterSet:" />- <code>(void) </code>
          <b>formIntersectionWithCharacterSet: </b>
          <code>(NSCharacterSet*) </code><i>otherSet </i>
          <br><em>Description forthcoming.</em>


        



<section name="formUnionWithCharacterSet:">
<label id="method**NSMutableCharacterSet**-formUnionWithCharacterSet:" />- <code>(void) </code>
          <b>formUnionWithCharacterSet: </b>
          <code>(NSCharacterSet*) </code><i>otherSet </i>
          <br><em>Description forthcoming.</em>


        



<section name="invert">
<label id="method**NSMutableCharacterSet**-invert" />- <code>(void) </code>
          <b>invert </b>
          <br><em>Description forthcoming.</em>


        



<section name="removeCharactersInRange:">
<label id="method**NSMutableCharacterSet**-removeCharactersInRange:" />- <code>(void) </code>
          <b>removeCharactersInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br><em>Description forthcoming.</em>


        



<section name="removeCharactersInString:">
<label id="method**NSMutableCharacterSet**-removeCharactersInString:" />- <code>(void) </code>
          <b>removeCharactersInString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GCMutableArray">


<section name="Overview">
<b>Inherits From:  </b><ref id="GCMutableArray">GCMutableArray</ref>: <ref id="NSMutableArray">NSMutableArray</ref>: <ref id="NSArray">NSArray</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GCObject.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="GSXPathObject">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXPathObject">GSXPathObject</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br>XPath queries return a GSXPathObject. GSXPathObject in
          itself is an abstract class; there are four types of
          completely different GSXPathObject types, listed
          below. I'm afraid you need to check the returned type
          of each GSXPath query to make sure it's what you meant it
          to be.


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="GSXPathNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXPathNumber">GSXPathNumber</ref>: <ref id="GSXPathObject">GSXPathObject</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br>For XPath queries returning a number.


</section>

<section name="Methods">


<section name="doubleValue">
<label id="method**GSXPathNumber**-doubleValue" />- <code>(double) </code>
          <b>doubleValue </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
      
</section>


</chapter>


<chapter name="NSAssertionHandler">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSAssertionHandler">NSAssertionHandler</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSException.h
</section>

<section name="Description">
<br>NSAssertionHandler objects are used to
            raise exceptions on behalf of macros implementing
            assertions. 
<br>
 Each thread has its own
            assertion handler instance. 
<br>
          The macros work together with the assertion handler
            object to produce meaningful exception messages
            containing the name of the source file, the
            position within that file, and the name of the
            ObjC method or C function in which the assertion
            failed.
          The assertion macros are:
          <ref id="function**NSAssertionHandler**NSAssert">
            NSAssert()
          </ref>
          , <ref id="function**NSAssertionHandler**NSCAssert">NSCAssert()</ref>,
          <ref id="function**NSAssertionHandler**NSAssert1">
            NSAssert1()
          </ref>
          , <ref id="function**NSAssertionHandler**NSCAssert1">NSCAssert1()</ref>,
          <ref id="function**NSAssertionHandler**NSAssert2">
            NSAssert2()
          </ref>
          , <ref id="function**NSAssertionHandler**NSCAssert2">NSCAssert2()</ref>,
          <ref id="function**NSAssertionHandler**NSAssert3">
            NSAssert3()
          </ref>
          , <ref id="function**NSAssertionHandler**NSCAssert3">NSCAssert3()</ref>,
          <ref id="function**NSAssertionHandler**NSAssert4">
            NSAssert4()
          </ref>
          , <ref id="function**NSAssertionHandler**NSCAssert4">NSCAssert4()</ref>,
          <ref id="function**NSAssertionHandler**NSAssert5">
            NSAssert5()
          </ref>
          , <ref id="function**NSAssertionHandler**NSCAssert5">NSCAssert5()</ref>,
          <ref id="function**NSAssertionHandler**NSParameterAssert">
            NSParameterAssert()
          </ref>
          ,
          <ref id="function**NSAssertionHandler**NSCParameterAssert">
            NSCParameterAssert()
          </ref>


</section>

<section name="Methods">


<section name="currentHandler">
<label id="method**NSAssertionHandler**+currentHandler" />+ <code>(NSAssertionHandler*) </code>
          <b>currentHandler </b>
          <br>Returns the assertion handler object for the
            current thread. 
<br>
 If none exists, creates one
            and returns it.


        



<section name="handleFailureInFunction:file:lineNumber:description:">
<label id="method**NSAssertionHandler**-handleFailureInFunction:file:lineNumber:description:" />- <code>(void) </code>
          <b>handleFailureInFunction: </b>
          <code>(NSString*) </code><i>functionName </i>
          <b>file: </b>
          <code>(NSString*) </code><i>fileName </i>
          <b>lineNumber: </b>
          <code>(int) </code><i>line </i>
          <b>description: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br>Handles an assertion failure by using
            <ref id="function**NSAssertionHandler**NSLogv">
              NSLogv()
            </ref>
            to print an error message built from the supplied
            arguments, and then raising an
            NSInternalInconsistencyException


        



<section name="handleFailureInMethod:object:file:lineNumber:description:">
<label id="method**NSAssertionHandler**-handleFailureInMethod:object:file:lineNumber:description:" />- <code>(void) </code>
          <b>handleFailureInMethod: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>object: </b>
          <code>(id) </code><i>object </i>
          <b>file: </b>
          <code>(NSString*) </code><i>fileName </i>
          <b>lineNumber: </b>
          <code>(int) </code><i>line </i>
          <b>description: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br>Handles an assertion failure by using
            <ref id="function**NSAssertionHandler**NSLogv">
              NSLogv()
            </ref>
            to print an error message built from the supplied
            arguments, and then raising an
            NSInternalInconsistencyException


        


        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSCharNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSCharNumber">NSCharNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSConditionLock">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSConditionLock">NSConditionLock</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSLockingGCFinalization
<br><b>Declared in: </b>NSLock.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="condition">
<label id="method**NSConditionLock**-condition" />- <code>(int) </code>
          <b>condition </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCondition:">
<label id="method**NSConditionLock**-initWithCondition:" />- <code>(id) </code>
          <b>initWithCondition: </b>
          <code>(int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="lock">
<label id="method**NSConditionLock**-lock" />- <code>(void) </code>
          <b>lock </b>
          <br><em>Description forthcoming.</em>


        



<section name="lockBeforeDate:">
<label id="method**NSConditionLock**-lockBeforeDate:" />- <code>(BOOL) </code>
          <b>lockBeforeDate: </b>
          <code>(NSDate*) </code><i>limit </i>
          <br><em>Description forthcoming.</em>


        



<section name="lockWhenCondition:">
<label id="method**NSConditionLock**-lockWhenCondition:" />- <code>(void) </code>
          <b>lockWhenCondition: </b>
          <code>(int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="lockWhenCondition:beforeDate:">
<label id="method**NSConditionLock**-lockWhenCondition:beforeDate:" />- <code>(BOOL) </code>
          <b>lockWhenCondition: </b>
          <code>(int) </code><i>condition_to_meet </i>
          <b>beforeDate: </b>
          <code>(NSDate*) </code><i>limitDate </i>
          <br><em>Description forthcoming.</em>


        



<section name="tryLock">
<label id="method**NSConditionLock**-tryLock" />- <code>(BOOL) </code>
          <b>tryLock </b>
          <br><em>Description forthcoming.</em>


        



<section name="tryLockWhenCondition:">
<label id="method**NSConditionLock**-tryLockWhenCondition:" />- <code>(BOOL) </code>
          <b>tryLockWhenCondition: </b>
          <code>(int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="unlock">
<label id="method**NSConditionLock**-unlock" />- <code>(void) </code>
          <b>unlock </b>
          <br><em>Description forthcoming.</em>


        



<section name="unlockWithCondition:">
<label id="method**NSConditionLock**-unlockWithCondition:" />- <code>(void) </code>
          <b>unlockWithCondition: </b>
          <code>(int) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSProcessInfo">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSProcessInfo">NSProcessInfo</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSProcessInfo.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="processInfo">
<label id="method**NSProcessInfo**+processInfo" />+ <code>(NSProcessInfo*) </code>
          <b>processInfo </b>
          <br>Returns the shared NSProcessInfo object for the
            current process.


        



<section name="arguments">
<label id="method**NSProcessInfo**-arguments" />- <code>(NSArray*) </code>
          <b>arguments </b>
          <br>Returns an array containing the arguments supplied
            to start this process. NB. In GNUstep, any arguments of
            the form --GNU-Debug=... are <em>not</em> included in
            this array... they are part of the debug mechanism,
            and are hidden so that setting debug variables will not
            effect the normal operation of the program.


        



<section name="environment">
<label id="method**NSProcessInfo**-environment" />- <code>(NSDictionary*) </code>
          <b>environment </b>
          <br>Returns a dictionary giving the environment
            variables which were provided for the process to
            use.


        



<section name="globallyUniqueString">
<label id="method**NSProcessInfo**-globallyUniqueString" />- <code>(NSString*) </code>
          <b>globallyUniqueString </b>
          <br>Returns a string which may be used as a globally
            unique identifier. 
<br>
 The string contains the
            host name, the process ID, a timestamp and a counter.
            
<br>
 The first three values identify the process
            in which the string is generated, while the fourth
            ensures that multiple strings generated within the
            same process are unique.


        



<section name="hostName">
<label id="method**NSProcessInfo**-hostName" />- <code>(NSString*) </code>
          <b>hostName </b>
          <br>Returns the name of the machine on which this
            process is running.


        



<section name="operatingSystem">
<label id="method**NSProcessInfo**-operatingSystem" />- <code>(unsigned int) </code>
          <b>operatingSystem </b>
          <br>Return a number representing the operating system
            type. 
<br>
 The known types are listed in the header
            file, but not all of the listed types are actually
            implemented... some are present for MacOS-X
            compatibility only. 
<br>


        



<section name="operatingSystemName">
<label id="method**NSProcessInfo**-operatingSystemName" />- <code>(NSString*) </code>
          <b>operatingSystemName </b>
          <br>Returns the name of the operating system in use.


        



<section name="processIdentifier">
<label id="method**NSProcessInfo**-processIdentifier" />- <code>(int) </code>
          <b>processIdentifier </b>
          <br>Returns the process identifier number which
            identifies this process on this machine.


        



<section name="processName">
<label id="method**NSProcessInfo**-processName" />- <code>(NSString*) </code>
          <b>processName </b>
          <br>Returns the process name for this process. This may
            have been set using the
            <ref id="method**NSProcessInfo**-setProcessName:">
              -setProcessName:
            </ref>
            method, or may be the default process name (the
            file name of the binary being executed).


        



<section name="setProcessName:">
<label id="method**NSProcessInfo**-setProcessName:" />- <code>(void) </code>
          <b>setProcessName: </b>
          <code>(NSString*) </code><i>newName </i>
          <br>Change the name of the current process to
            <i>newName</i>.


        


        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSRunLoop">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSRunLoop">NSRunLoop</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>GCFinalization
<br><b>Declared in: </b>NSRunLoop.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
      

<section name="currentRunLoop">
<label id="method**NSRunLoop**+currentRunLoop" />+ <code>(NSRunLoop*) </code>
          <b>currentRunLoop </b>
          <br><em>Description forthcoming.</em>


        



<section name="acceptInputForMode:beforeDate:">
<label id="method**NSRunLoop**-acceptInputForMode:beforeDate:" />- <code>(void) </code>
          <b>acceptInputForMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <b>beforeDate: </b>
          <code>(NSDate*) </code><i>limit_date </i>
          <br>Listen to input sources. 
<br>
 If
            <i>limit_date</i> is <code>nil</code> or in the
            past, then don't wait; just poll inputs and return,
            otherwise block until input is available or until
            the earliest limit date has passed (whichever comes
            first). 
<br>
 If the supplied <i>mode</i> is
            <code>nil</code>, uses NSDefaultRunLoopMode.


        



<section name="addTimer:forMode:">
<label id="method**NSRunLoop**-addTimer:forMode:" />- <code>(void) </code>
          <b>addTimer: </b>
          <code>(NSTimer*) </code><i>timer </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br>Adds a <i>timer</i> to the loop in the specified
            <i>mode</i>. 
<br>
 Timers are removed
            automatically when they are invalid. 
<br>


        



<section name="currentMode">
<label id="method**NSRunLoop**-currentMode" />- <code>(NSString*) </code>
          <b>currentMode </b>
          <br>Returns the current mode of this runloop. If the
            runloop is not running then this method returns
            <code>nil</code>.


        



<section name="limitDateForMode:">
<label id="method**NSRunLoop**-limitDateForMode:" />- <code>(NSDate*) </code>
          <b>limitDateForMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br>Fire appropriate timers and determine the earliest
            time that anything watched for becomes useless.


        



<section name="run">
<label id="method**NSRunLoop**-run" />- <code>(void) </code>
          <b>run </b>
          <br><em>Description forthcoming.</em>


        



<section name="runMode:beforeDate:">
<label id="method**NSRunLoop**-runMode:beforeDate:" />- <code>(BOOL) </code>
          <b>runMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <b>beforeDate: </b>
          <code>(NSDate*) </code><i>date </i>
          <br>Calls
            <ref id="method**NSRunLoop**-acceptInputForMode:beforeDate:">
              -acceptInputForMode:beforeDate:
            </ref>
            to run the loop once. 
<br>
 The specified
            <i>date</i> may be <code>nil</code>... in which
            case the loop runs until the first input or timeout.
            
<br>
 If the limit dates for all of mode's input
            sources have passed, returns <code>NO</code>
            without running the loop, otherwise returns
            <code>YES</code>.


        



<section name="runUntilDate:">
<label id="method**NSRunLoop**-runUntilDate:" />- <code>(void) </code>
          <b>runUntilDate: </b>
          <code>(NSDate*) </code><i>date </i>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSProtocolChecker">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSProtocolChecker">NSProtocolChecker</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSProtocolChecker.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="protocolCheckerWithTarget:protocol:">
<label id="method**NSProtocolChecker**+protocolCheckerWithTarget:protocol:" />+ <code>(id) </code>
          <b>protocolCheckerWithTarget: </b>
          <code>(NSObject*) </code><i>anObject </i>
          <b>protocol: </b>
          <code>(Protocol*) </code><i>aProtocol </i>
          <br><em>Description forthcoming.</em>


        



<section name="forwardInvocation:">
<label id="method**NSProtocolChecker**-forwardInvocation:" />- <code>(void) </code>
          <b>forwardInvocation: </b>
          <code>(NSInvocation*) </code><i>anInvocation </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithTarget:protocol:">
<label id="method**NSProtocolChecker**-initWithTarget:protocol:" />- <code>(id) </code>
          <b>initWithTarget: </b>
          <code>(NSObject*) </code><i>anObject </i>
          <b>protocol: </b>
          <code>(Protocol*) </code><i>aProtocol </i>
          <br><em>Description forthcoming.</em>


        



<section name="methodDescriptionForSelector:">
<label id="method**NSProtocolChecker**-methodDescriptionForSelector:" />- <code>(struct objc_method_description*) </code>
          <b>methodDescriptionForSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br><em>Description forthcoming.</em>


        



<section name="protocol">
<label id="method**NSProtocolChecker**-protocol" />- <code>(Protocol*) </code>
          <b>protocol </b>
          <br><em>Description forthcoming.</em>


        



<section name="target">
<label id="method**NSProtocolChecker**-target" />- <code>(NSObject*) </code>
          <b>target </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSTimeZoneDetail">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSTimeZoneDetail">NSTimeZoneDetail</ref>: <ref id="NSTimeZone">NSTimeZone</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSTimeZone.h
</section>

<section name="Description">
<br>This class serves no useful purpose in GNUstep, and is
          provided solely for backward compatibility with the
          OpenStep spec. It is missing entirely from MacOS-X.


</section>

<section name="Methods">


<section name="isDaylightSavingTimeZone">
<label id="method**NSTimeZoneDetail**-isDaylightSavingTimeZone" />- <code>(BOOL) </code>
          <b>isDaylightSavingTimeZone </b>
          <br><em>Description forthcoming.</em>


        



<section name="timeZoneAbbreviation">
<label id="method**NSTimeZoneDetail**-timeZoneAbbreviation" />- <code>(NSString*) </code>
          <b>timeZoneAbbreviation </b>
          <br><em>Description forthcoming.</em>


        



<section name="timeZoneSecondsFromGMT">
<label id="method**NSTimeZoneDetail**-timeZoneSecondsFromGMT" />- <code>(int) </code>
          <b>timeZoneSecondsFromGMT </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
      
</section>


</chapter>


<chapter name="UnixFileHandle">


<section name="Overview">
<b>Inherits From:  </b><ref id="UnixFileHandle">UnixFileHandle</ref>: <ref id="NSFileHandle">NSFileHandle</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>RunLoopEventsGCFinalization
<br><b>Declared in: </b>UnixFileHandle.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="checkAccept">
<label id="method**UnixFileHandle**-checkAccept" />- <code>(void) </code>
          <b>checkAccept </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkConnect">
<label id="method**UnixFileHandle**-checkConnect" />- <code>(void) </code>
          <b>checkConnect </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkRead">
<label id="method**UnixFileHandle**-checkRead" />- <code>(void) </code>
          <b>checkRead </b>
          <br><em>Description forthcoming.</em>


        



<section name="checkWrite">
<label id="method**UnixFileHandle**-checkWrite" />- <code>(void) </code>
          <b>checkWrite </b>
          <br><em>Description forthcoming.</em>


        



<section name="ignoreReadDescriptor">
<label id="method**UnixFileHandle**-ignoreReadDescriptor" />- <code>(void) </code>
          <b>ignoreReadDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="ignoreWriteDescriptor">
<label id="method**UnixFileHandle**-ignoreWriteDescriptor" />- <code>(void) </code>
          <b>ignoreWriteDescriptor </b>
          <br><em>Description forthcoming.</em>


        



<section name="initAsClientAtAddress:service:protocol:">
<label id="method**UnixFileHandle**-initAsClientAtAddress:service:protocol:" />- <code>(id) </code>
          <b>initAsClientAtAddress: </b>
          <code>(NSString*) </code><i>a </i>
          <b>service: </b>
          <code>(NSString*) </code><i>s </i>
          <b>protocol: </b>
          <code>(NSString*) </code><i>p </i>
          <br>Initialise as <i>a</i> client socket
            connection... do this by using
            <ref id="method**UnixFileHandle**-initAsClientInBackgroundAtAddress:service:protocol:forModes:">[-initAsClientInBackgroundAtAddress:service:protocol:forModes:]</ref> and running the current run loop in NSDefaultRunLoopMode until the connection attempt succeeds, fails, or times out.


        



<section name="initAsClientInBackgroundAtAddress:service:protocol:forModes:">
<label id="method**UnixFileHandle**-initAsClientInBackgroundAtAddress:service:protocol:forModes:" />- <code>(id) </code>
          <b>initAsClientInBackgroundAtAddress: </b>
          <code>(NSString*) </code><i>a </i>
          <b>service: </b>
          <code>(NSString*) </code><i>s </i>
          <b>protocol: </b>
          <code>(NSString*) </code><i>p </i>
          <b>forModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br>A protocol fo the form 'socks-...' controls socks
            operation, overriding defaults and environment
            variables. 
<br>
 If it is just 'socks-' it
            turns off socks for this fiel handle. 
<br>

            Otherwise, the following text must be the name
            of the socks server (optionally followed by :port).


        



<section name="initAsServerAtAddress:service:protocol:">
<label id="method**UnixFileHandle**-initAsServerAtAddress:service:protocol:" />- <code>(id) </code>
          <b>initAsServerAtAddress: </b>
          <code>(NSString*) </code><i>a </i>
          <b>service: </b>
          <code>(NSString*) </code><i>s </i>
          <b>protocol: </b>
          <code>(NSString*) </code><i>p </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForReadingAtPath:">
<label id="method**UnixFileHandle**-initForReadingAtPath:" />- <code>(id) </code>
          <b>initForReadingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForUpdatingAtPath:">
<label id="method**UnixFileHandle**-initForUpdatingAtPath:" />- <code>(id) </code>
          <b>initForUpdatingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initForWritingAtPath:">
<label id="method**UnixFileHandle**-initForWritingAtPath:" />- <code>(id) </code>
          <b>initForWritingAtPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithNullDevice">
<label id="method**UnixFileHandle**-initWithNullDevice" />- <code>(id) </code>
          <b>initWithNullDevice </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardError">
<label id="method**UnixFileHandle**-initWithStandardError" />- <code>(id) </code>
          <b>initWithStandardError </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardInput">
<label id="method**UnixFileHandle**-initWithStandardInput" />- <code>(id) </code>
          <b>initWithStandardInput </b>
          <br><em>Description forthcoming.</em>


        



<section name="initWithStandardOutput">
<label id="method**UnixFileHandle**-initWithStandardOutput" />- <code>(id) </code>
          <b>initWithStandardOutput </b>
          <br><em>Description forthcoming.</em>


        



<section name="postReadNotification">
<label id="method**UnixFileHandle**-postReadNotification" />- <code>(void) </code>
          <b>postReadNotification </b>
          <br><em>Description forthcoming.</em>


        



<section name="postWriteNotification">
<label id="method**UnixFileHandle**-postWriteNotification" />- <code>(void) </code>
          <b>postWriteNotification </b>
          <br><em>Description forthcoming.</em>


        



<section name="receivedEvent:type:extra:forMode:">
<label id="method**UnixFileHandle**-receivedEvent:type:extra:forMode:" />- <code>(void) </code>
          <b>receivedEvent: </b>
          <code>(void*) </code><i>data </i>
          <b>type: </b>
          <code>(RunLoopEventType) </code><i>type </i>
          <b>extra: </b>
          <code>(void*) </code><i>extra </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br><em>Description forthcoming.</em>


        



<section name="setAddr:">
<label id="method**UnixFileHandle**-setAddr:" />- <code>(void) </code>
          <b>setAddr: </b>
          <code>(struct sockaddr_in*) </code><i>sin </i>
          <br><em>Description forthcoming.</em>


        



<section name="setNonBlocking:">
<label id="method**UnixFileHandle**-setNonBlocking:" />- <code>(void) </code>
          <b>setNonBlocking: </b>
          <code>(BOOL) </code><i>flag </i>
          <br><em>Description forthcoming.</em>


        



<section name="timedOutEvent:type:forMode:">
<label id="method**UnixFileHandle**-timedOutEvent:type:forMode:" />- <code>(NSDate*) </code>
          <b>timedOutEvent: </b>
          <code>(void*) </code><i>data </i>
          <b>type: </b>
          <code>(RunLoopEventType) </code><i>type </i>
          <b>forMode: </b>
          <code>(NSString*) </code><i>mode </i>
          <br><em>Description forthcoming.</em>


        



<section name="useCompression">
<label id="method**UnixFileHandle**-useCompression" />- <code>(BOOL) </code>
          <b>useCompression </b>
          <br><em>Description forthcoming.</em>


        



<section name="watchReadDescriptorForModes:">
<label id="method**UnixFileHandle**-watchReadDescriptorForModes:" />- <code>(void) </code>
          <b>watchReadDescriptorForModes: </b>
          <code>(NSArray*) </code><i>modes </i>
          <br><em>Description forthcoming.</em>


        



<section name="watchWriteDescriptor">
<label id="method**UnixFileHandle**-watchWriteDescriptor" />- <code>(void) </code>
          <b>watchWriteDescriptor </b>
          <br><em>Description forthcoming.</em>


        


</section>


</chapter>


<chapter name="NSNull">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSNull">NSNull</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopying
<br><b>Declared in: </b>NSNull.h
</section>

<section name="Description">
<br>An object to use as a placeholder - in collections for
          instance.


</section>

<section name="Methods">

        
        
        
        
        
      

<section name="null">
<label id="method**NSNull**+null" />+ <code>(NSNull*) </code>
          <b>null </b>
          <br>Return an object that can be used as a placeholder
            in a collection. This method always returns the same
            object.


        


</section>


</chapter>


<chapter name="GSSAXHandler">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSSAXHandler">GSSAXHandler</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="handler">
<label id="method**GSSAXHandler**+handler" />+ <code>(GSSAXHandler*) </code>
          <b>handler </b>
          <br><em>Description forthcoming.</em>


        



<section name="attribute:value:">
<label id="method**GSSAXHandler**-attribute:value:" />- <code>(void) </code>
          <b>attribute: </b>
          <code>(NSString*) </code><i>name </i>
          <b>value: </b>
          <code>(NSString*) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="attributeDecl:name:type:typeDefValue:defaultValue:">
<label id="method**GSSAXHandler**-attributeDecl:name:type:typeDefValue:defaultValue:" />- <code>(void) </code>
          <b>attributeDecl: </b>
          <code>(NSString*) </code><i>nameElement </i>
          <b>name: </b>
          <code>(NSString*) </code><i>name </i>
          <b>type: </b>
          <code>(int) </code><i>type </i>
          <b>typeDefValue: </b>
          <code>(int) </code><i>defType </i>
          <b>defaultValue: </b>
          <code>(NSString*) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="cdataBlock:">
<label id="method**GSSAXHandler**-cdataBlock:" />- <code>(void) </code>
          <b>cdataBlock: </b>
          <code>(NSString*) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="characters:">
<label id="method**GSSAXHandler**-characters:" />- <code>(void) </code>
          <b>characters: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="comment:">
<label id="method**GSSAXHandler**-comment:" />- <code>(void) </code>
          <b>comment: </b>
          <code>(NSString*) </code><i>value </i>
          <br><em>Description forthcoming.</em>


        



<section name="elementDecl:type:">
<label id="method**GSSAXHandler**-elementDecl:type:" />- <code>(void) </code>
          <b>elementDecl: </b>
          <code>(NSString*) </code><i>name </i>
          <b>type: </b>
          <code>(int) </code><i>type </i>
          <br><em>Description forthcoming.</em>


        



<section name="endDocument">
<label id="method**GSSAXHandler**-endDocument" />- <code>(void) </code>
          <b>endDocument </b>
          <br><em>Description forthcoming.</em>


        



<section name="endElement:">
<label id="method**GSSAXHandler**-endElement:" />- <code>(void) </code>
          <b>endElement: </b>
          <code>(NSString*) </code><i>elementName </i>
          <br><em>Description forthcoming.</em>


        



<section name="entityDecl:type:public:system:content:">
<label id="method**GSSAXHandler**-entityDecl:type:public:system:content:" />- <code>(void) </code>
          <b>entityDecl: </b>
          <code>(NSString*) </code><i>name </i>
          <b>type: </b>
          <code>(int) </code><i>type </i>
          <b>public: </b>
          <code>(NSString*) </code><i>publicId </i>
          <b>system: </b>
          <code>(NSString*) </code><i>systemId </i>
          <b>content: </b>
          <code>(NSString*) </code><i>content </i>
          <br><em>Description forthcoming.</em>


        



<section name="error:">
<label id="method**GSSAXHandler**-error:" />- <code>(void) </code>
          <b>error: </b>
          <code>(NSString*) </code><i>e </i>
          <br><em>Description forthcoming.</em>


        



<section name="error:colNumber:lineNumber:">
<label id="method**GSSAXHandler**-error:colNumber:lineNumber:" />- <code>(void) </code>
          <b>error: </b>
          <code>(NSString*) </code><i>e </i>
          <b>colNumber: </b>
          <code>(int) </code><i>colNumber </i>
          <b>lineNumber: </b>
          <code>(int) </code><i>lineNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="externalSubset:externalID:systemID:">
<label id="method**GSSAXHandler**-externalSubset:externalID:systemID:" />- <code>(BOOL) </code>
          <b>externalSubset: </b>
          <code>(NSString*) </code><i>name </i>
          <b>externalID: </b>
          <code>(NSString*) </code><i>externalID </i>
          <b>systemID: </b>
          <code>(NSString*) </code><i>systemID </i>
          <br><em>Description forthcoming.</em>


        



<section name="fatalError:">
<label id="method**GSSAXHandler**-fatalError:" />- <code>(void) </code>
          <b>fatalError: </b>
          <code>(NSString*) </code><i>e </i>
          <br><em>Description forthcoming.</em>


        



<section name="fatalError:colNumber:lineNumber:">
<label id="method**GSSAXHandler**-fatalError:colNumber:lineNumber:" />- <code>(void) </code>
          <b>fatalError: </b>
          <code>(NSString*) </code><i>e </i>
          <b>colNumber: </b>
          <code>(int) </code><i>colNumber </i>
          <b>lineNumber: </b>
          <code>(int) </code><i>lineNumber </i>
          <br><em>Description forthcoming.</em>


        



<section name="getEntity:">
<label id="method**GSSAXHandler**-getEntity:" />- <code>(void*) </code>
          <b>getEntity: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="getParameterEntity:">
<label id="method**GSSAXHandler**-getParameterEntity:" />- <code>(void*) </code>
          <b>getParameterEntity: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="globalNamespace:href:prefix:">
<label id="method**GSSAXHandler**-globalNamespace:href:prefix:" />- <code>(void) </code>
          <b>globalNamespace: </b>
          <code>(NSString*) </code><i>name </i>
          <b>href: </b>
          <code>(NSString*) </code><i>href </i>
          <b>prefix: </b>
          <code>(NSString*) </code><i>prefix </i>
          <br><em>Description forthcoming.</em>


        



<section name="hasExternalSubset">
<label id="method**GSSAXHandler**-hasExternalSubset" />- <code>(int) </code>
          <b>hasExternalSubset </b>
          <br><em>Description forthcoming.</em>


        



<section name="hasInternalSubset">
<label id="method**GSSAXHandler**-hasInternalSubset" />- <code>(int) </code>
          <b>hasInternalSubset </b>
          <br><em>Description forthcoming.</em>


        



<section name="ignoreWhitespace:">
<label id="method**GSSAXHandler**-ignoreWhitespace:" />- <code>(void) </code>
          <b>ignoreWhitespace: </b>
          <code>(NSString*) </code><i>ch </i>
          <br><em>Description forthcoming.</em>


        



<section name="internalSubset:externalID:systemID:">
<label id="method**GSSAXHandler**-internalSubset:externalID:systemID:" />- <code>(BOOL) </code>
          <b>internalSubset: </b>
          <code>(NSString*) </code><i>name </i>
          <b>externalID: </b>
          <code>(NSString*) </code><i>externalID </i>
          <b>systemID: </b>
          <code>(NSString*) </code><i>systemID </i>
          <br><em>Description forthcoming.</em>


        



<section name="isStandalone">
<label id="method**GSSAXHandler**-isStandalone" />- <code>(int) </code>
          <b>isStandalone </b>
          <br><em>Description forthcoming.</em>


        



<section name="lib">
<label id="method**GSSAXHandler**-lib" />- <code>(void*) </code>
          <b>lib </b>
          <br><em>Description forthcoming.</em>


        



<section name="loadEntity:at:">
<label id="method**GSSAXHandler**-loadEntity:at:" />- <code>(NSString*) </code>
          <b>loadEntity: </b>
          <code>(NSString*) </code><i>publicId </i>
          <b>at: </b>
          <code>(NSString*) </code><i>location </i>
          <br><em>Description forthcoming.</em>


        



<section name="namespaceDecl:href:prefix:">
<label id="method**GSSAXHandler**-namespaceDecl:href:prefix:" />- <code>(void) </code>
          <b>namespaceDecl: </b>
          <code>(NSString*) </code><i>name </i>
          <b>href: </b>
          <code>(NSString*) </code><i>href </i>
          <b>prefix: </b>
          <code>(NSString*) </code><i>prefix </i>
          <br><em>Description forthcoming.</em>


        



<section name="notationDecl:public:system:">
<label id="method**GSSAXHandler**-notationDecl:public:system:" />- <code>(void) </code>
          <b>notationDecl: </b>
          <code>(NSString*) </code><i>name </i>
          <b>public: </b>
          <code>(NSString*) </code><i>publicId </i>
          <b>system: </b>
          <code>(NSString*) </code><i>systemId </i>
          <br><em>Description forthcoming.</em>


        



<section name="parser">
<label id="method**GSSAXHandler**-parser" />- <code>(GSXMLParser*) </code>
          <b>parser </b>
          <br><em>Description forthcoming.</em>


        



<section name="processInstruction:data:">
<label id="method**GSSAXHandler**-processInstruction:data:" />- <code>(void) </code>
          <b>processInstruction: </b>
          <code>(NSString*) </code><i>targetName </i>
          <b>data: </b>
          <code>(NSString*) </code><i>PIdata </i>
          <br><em>Description forthcoming.</em>


        



<section name="reference:">
<label id="method**GSSAXHandler**-reference:" />- <code>(void) </code>
          <b>reference: </b>
          <code>(NSString*) </code><i>name </i>
          <br><em>Description forthcoming.</em>


        



<section name="startDocument">
<label id="method**GSSAXHandler**-startDocument" />- <code>(void) </code>
          <b>startDocument </b>
          <br><em>Description forthcoming.</em>


        



<section name="startElement:attributes:">
<label id="method**GSSAXHandler**-startElement:attributes:" />- <code>(void) </code>
          <b>startElement: </b>
          <code>(NSString*) </code><i>elementName </i>
          <b>attributes: </b>
          <code>(NSMutableDictionary*) </code><i>elementAttributes </i>
          <br><em>Description forthcoming.</em>


        



<section name="unparsedEntityDecl:public:system:notationName:">
<label id="method**GSSAXHandler**-unparsedEntityDecl:public:system:notationName:" />- <code>(void) </code>
          <b>unparsedEntityDecl: </b>
          <code>(NSString*) </code><i>name </i>
          <b>public: </b>
          <code>(NSString*) </code><i>publicId </i>
          <b>system: </b>
          <code>(NSString*) </code><i>systemId </i>
          <b>notationName: </b>
          <code>(NSString*) </code><i>notation </i>
          <br><em>Description forthcoming.</em>


        



<section name="warning:">
<label id="method**GSSAXHandler**-warning:" />- <code>(void) </code>
          <b>warning: </b>
          <code>(NSString*) </code><i>e </i>
          <br><em>Description forthcoming.</em>


        



<section name="warning:colNumber:lineNumber:">
<label id="method**GSSAXHandler**-warning:colNumber:lineNumber:" />- <code>(void) </code>
          <b>warning: </b>
          <code>(NSString*) </code><i>e </i>
          <b>colNumber: </b>
          <code>(int) </code><i>colNumber </i>
          <b>lineNumber: </b>
          <code>(int) </code><i>lineNumber </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GSXMLAttribute">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXMLAttribute">GSXMLAttribute</ref>: <ref id="GSXMLNode">GSXMLNode</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="value">
<label id="method**GSXMLAttribute**-value" />- <code>(NSString*) </code>
          <b>value </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
      
</section>


</chapter>


<chapter name="NSException">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSException">NSException</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopying
<br><b>Declared in: </b>NSException.h
</section>

<section name="Description">
<br>The NSException class helps manage errors in a program.
            It provides a mechanism for lower-level methods to
            provide information about problems to higher-level
            methods, which more often than not, have a better
            ability to decide what to do about the problems.
          Exceptions are typically handled by enclosing a
            sensitive section of code inside the macros
            NS_DURING and NS_HANDLER, and then handling any
            problems after this, up to the NS_ENDHANDLER
            macro:

          The local variable localException is the name of the
            exception object you can use in the NS_HANDLER
            section. The easiest way to cause an exeption is
            using the
            <ref id="method**NSException**+raise:format:,...">
              +raise:format:,...
            </ref>
            method.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="exceptionWithName:reason:userInfo:">
<label id="method**NSException**+exceptionWithName:reason:userInfo:" />+ <code>(NSException*) </code>
          <b>exceptionWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>reason: </b>
          <code>(NSString*) </code><i>reason </i>
          <b>userInfo: </b>
          <code>(NSDictionary*) </code><i>userInfo </i>
          <br>Create an an exception object with a <i>name</i>
            , <i>reason</i> and a dictionary <i>userInfo</i>
            which can be used to provide additional information
            or access to objects needed to handle the exception.
            After the exception is created you must
            <ref id="method**NSException**-raise">
              -raise
            </ref>
            it.


        



<section name="raise:format:">
<label id="method**NSException**+raise:format:" />+ <code>(void) </code>
          <b>raise: </b>
          <code>(NSString*) </code><i>name </i>
          <b>format: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br>Creates an exception with a <i>name</i> and a
            reason using the <i>format</i> string and any
            additional arguments. The exception is then
            raised.


        



<section name="raise:format:arguments:">
<label id="method**NSException**+raise:format:arguments:" />+ <code>(void) </code>
          <b>raise: </b>
          <code>(NSString*) </code><i>name </i>
          <b>format: </b>
          <code>(NSString*) </code><i>format </i>
          <b>arguments: </b>
          <code>(va_list) </code><i>argList </i>
          <br>Creates an exception with a <i>name</i> and a
            reason string using the <i>format</i> string and
            additional arguments specified as a variable
            argument list <i>argList</i>. The exception is
            then raised.


        



<section name="initWithName:reason:userInfo:">
<label id="method**NSException**-initWithName:reason:userInfo:" />- <code>(id) </code>
          <b>initWithName: </b>
          <code>(NSString*) </code><i>name </i>
          <b>reason: </b>
          <code>(NSString*) </code><i>reason </i>
          <b>userInfo: </b>
          <code>(NSDictionary*) </code><i>userInfo </i>
          <br>Initializes a newly allocated NSException
            object with a <i>name</i>, <i>reason</i> and
            a dictionary <i>userInfo</i>.


        



<section name="name">
<label id="method**NSException**-name" />- <code>(NSString*) </code>
          <b>name </b>
          <br>Returns the name of the exception


        



<section name="raise">
<label id="method**NSException**-raise" />- <code>(void) </code>
          <b>raise </b>
          <br>Raises the exception. All code following the raise
            will not be executed and program control will be
            transfered to the closest calling method which
            encapsulates the exception code in an
            NS_DURING macro, or to the uncaught exception
            handler if there is no other handling code.


        



<section name="reason">
<label id="method**NSException**-reason" />- <code>(NSString*) </code>
          <b>reason </b>
          <br>Returns the exception reason


        



<section name="userInfo">
<label id="method**NSException**-userInfo" />- <code>(NSDictionary*) </code>
          <b>userInfo </b>
          <br>Returns the exception userInfo dictionary


        


</section>


</chapter>


<chapter name="NSArray">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSArray">NSArray</ref>: <ref id="NSObject">NSObject</ref>
<br><b>Conforms to: </b>NSCodingNSCopyingNSMutableCopying
<br><b>Declared in: </b>NSArray.h
</section>

<section name="Description">
<br>A simple, low overhead, ordered container for objects.


</section>

<section name="Methods">

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      

<section name="array">
<label id="method**NSArray**+array" />+ <code>(id) </code>
          <b>array </b>
          <br>Returns an empty autoreleased array.


        



<section name="arrayWithArray:">
<label id="method**NSArray**+arrayWithArray:" />+ <code>(id) </code>
          <b>arrayWithArray: </b>
          <code>(NSArray*) </code><i>array </i>
          <br>Returns a new autoreleased NSArray instance
            containing all the objects from <i>array</i>
            , in the same order as the original.


        



<section name="arrayWithContentsOfFile:">
<label id="method**NSArray**+arrayWithContentsOfFile:" />+ <code>(id) </code>
          <b>arrayWithContentsOfFile: </b>
          <code>(NSString*) </code><i>file </i>
          <br>Returns an autoreleased array based upon the
            <i>file</i>. The new array is created using
            <ref id="method**NSArray**+allocWithZone:">
              +allocWithZone:
            </ref>
            and initialised using the
            <ref id="method**NSArray**-initWithContentsOfFile:">
              -initWithContentsOfFile:
            </ref>
            method. See the documentation for those methods for
            more detail.


        



<section name="arrayWithObject:">
<label id="method**NSArray**+arrayWithObject:" />+ <code>(id) </code>
          <b>arrayWithObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Returns an autoreleased array containing
            <i>anObject</i>.


        



<section name="arrayWithObjects:">
<label id="method**NSArray**+arrayWithObjects:" />+ <code>(id) </code>
          <b>arrayWithObjects: </b>
          <code>(id) </code><i>firstObject </i>
          
          <br>Returns an autoreleased array containing the list
            of objects, preserving order.


        



<section name="arrayWithObjects:count:">
<label id="method**NSArray**+arrayWithObjects:count:" />+ <code>(id) </code>
          <b>arrayWithObjects: </b>
          <code>(id*) </code><i>objects </i>
          <b>count: </b>
          <code>(unsigned) </code><i>count </i>
          <br>Returns an autoreleased array containing the
            specified <i>objects</i>, preserving order.


        



<section name="arrayByAddingObject:">
<label id="method**NSArray**-arrayByAddingObject:" />- <code>(NSArray*) </code>
          <b>arrayByAddingObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Returns an autoreleased array formed from the
            contents of the receiver and adding
            <i>anObject</i> as the last item.


        



<section name="arrayByAddingObjectsFromArray:">
<label id="method**NSArray**-arrayByAddingObjectsFromArray:" />- <code>(NSArray*) </code>
          <b>arrayByAddingObjectsFromArray: </b>
          <code>(NSArray*) </code><i>anotherArray </i>
          <br>Returns a new array which is the concatenation of
            self and otherArray (in this precise order).


        



<section name="componentsJoinedByString:">
<label id="method**NSArray**-componentsJoinedByString:" />- <code>(NSString*) </code>
          <b>componentsJoinedByString: </b>
          <code>(NSString*) </code><i>separator </i>
          <br>Returns a string formed by concatenating the
            objects in the receiver, with the specified
            <i>separator</i> string inserted between each
            part.


        



<section name="containsObject:">
<label id="method**NSArray**-containsObject:" />- <code>(BOOL) </code>
          <b>containsObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Returns <code>YES</code> if <i>anObject</i>
            belongs to self. No otherwise. 
<br>
 The
            <ref id="method**NSArray**-isEqual:">
              -isEqual:
            </ref>
            method of <i>anObject</i> is used to test for
            equality.


        



<section name="count">
<label id="method**NSArray**-count" />- <code>(unsigned) </code>
          <b>count </b>
          <br>Returns the number of elements contained in the
            receiver.


        



<section name="description">
<label id="method**NSArray**-description" />- <code>(NSString*) </code>
          <b>description </b>
          <br>Returns the result of invoking
            <ref id="method**NSArray**-descriptionWithLocale:indent:">
              -descriptionWithLocale:indent:
            </ref>
            with a <code>nil</code> locale and zero indent.


        



<section name="descriptionWithLocale:">
<label id="method**NSArray**-descriptionWithLocale:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <br>Returns the result of invoking
            <ref id="method**NSArray**-descriptionWithLocale:indent:">
              -descriptionWithLocale:indent:
            </ref>
            with a zero indent.


        



<section name="descriptionWithLocale:indent:">
<label id="method**NSArray**-descriptionWithLocale:indent:" />- <code>(NSString*) </code>
          <b>descriptionWithLocale: </b>
          <code>(NSDictionary*) </code><i>locale </i>
          <b>indent: </b>
          <code>(unsigned int) </code><i>level </i>
          <br>Returns the receiver as a text property list in the
            traditional format. 
<br>
 See
            <ref id="method**NSString**-propertyList">
              [NSString% unknown entity: nbsp
-propertyList]
            </ref>
            for details. 
<br>
 If <i>locale</i> is
            <code>nil</code>, no formatting is done, otherwise
            entries are formatted according to the
            <i>locale</i>, and indented according to
            <i>level</i>. 
<br>
 Unless <i>locale</i> is
            <code>nil</code>, a <i>level</i> of zero indents
            items by four spaces, while a <i>level</i> of one
            indents them by a tab. 
<br>
 The items in the
            property list string appear in the same order as
            they appear in the receiver.


        



<section name="firstObjectCommonWithArray:">
<label id="method**NSArray**-firstObjectCommonWithArray:" />- <code>(id) </code>
          <b>firstObjectCommonWithArray: </b>
          <code>(NSArray*) </code><i>otherArray </i>
          <br>Returns the first object found in the receiver
            (starting at index 0) which is present in the
            <i>otherArray</i> as determined by using the
            <ref id="method**NSArray**-containsObject:">
              -containsObject:
            </ref>
            method.


        



<section name="getObjects:">
<label id="method**NSArray**-getObjects:" />- <code>(void) </code>
          <b>getObjects: </b>
          <code>(id*) </code><i>aBuffer </i>
          <br>Copies the objects from the receiver to
            <i>aBuffer</i>, which must be an area of memory
            large enough to hold them.


        



<section name="getObjects:range:">
<label id="method**NSArray**-getObjects:range:" />- <code>(void) </code>
          <b>getObjects: </b>
          <code>(id*) </code><i>aBuffer </i>
          <b>range: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Copies the objects from the range <i>aRange</i>
            of the receiver to <i>aBuffer</i>, which must be an
            area of memory large enough to hold them.


        



<section name="indexOfObject:">
<label id="method**NSArray**-indexOfObject:" />- <code>(unsigned) </code>
          <b>indexOfObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Returns the index of the first object found in the
            receiver which is equal to <i>anObject</i>
            (using anObject's
            <ref id="method**NSArray**-isEqual:">
              -isEqual:
            </ref>
            method). Returns NSNotFound on failure.


        



<section name="indexOfObject:inRange:">
<label id="method**NSArray**-indexOfObject:inRange:" />- <code>(unsigned) </code>
          <b>indexOfObject: </b>
          <code>(id) </code><i>anObject </i>
          <b>inRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Returns the index of the first object found in
            <i>aRange</i> of receiver which is equal to
            <i>anObject</i> (using anObject's
            <ref id="method**NSArray**-isEqual:">
              -isEqual:
            </ref>
            method). Returns NSNotFound on failure.


        



<section name="indexOfObjectIdenticalTo:">
<label id="method**NSArray**-indexOfObjectIdenticalTo:" />- <code>(unsigned) </code>
          <b>indexOfObjectIdenticalTo: </b>
          <code>(id) </code><i>anObject </i>
          <br>Returns the index of the specified object in the
            receiver, or NSNotFound if the object is not
            present.


        



<section name="indexOfObjectIdenticalTo:inRange:">
<label id="method**NSArray**-indexOfObjectIdenticalTo:inRange:" />- <code>(unsigned) </code>
          <b>indexOfObjectIdenticalTo: </b>
          <code>(id) </code><i>anObject </i>
          <b>inRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Returns the index of the specified object in the
            range of the receiver, or NSNotFound if the object is
            not present.


        



<section name="initWithArray:">
<label id="method**NSArray**-initWithArray:" />- <code>(id) </code>
          <b>initWithArray: </b>
          <code>(NSArray*) </code><i>array </i>
          <br>Initialize the receiver with the contents of
            <i>array</i>. The order of <i>array</i> is
            preserved. 
<br>
 Invokes
            <ref id="method**NSArray**-initWithObjects:count:">
              -initWithObjects:count:
            </ref>


        



<section name="initWithArray:copyItems:">
<label id="method**NSArray**-initWithArray:copyItems:" />- <code>(id) </code>
          <b>initWithArray: </b>
          <code>(NSArray*) </code><i>array </i>
          <b>copyItems: </b>
          <code>(BOOL) </code><i>shouldCopy </i>
          <br>Initialize the receiver with the contents of
            <i>array</i>. The order of <i>array</i> is
            preserved. 
<br>
 If <i>shouldCopy</i> is
            <code>YES</code> then the objects are copied rather
            than simply retained. 
<br>
 Invokes
            <ref id="method**NSArray**-initWithObjects:count:">
              -initWithObjects:count:
            </ref>


        



<section name="initWithContentsOfFile:">
<label id="method**NSArray**-initWithContentsOfFile:" />- <code>(id) </code>
          <b>initWithContentsOfFile: </b>
          <code>(NSString*) </code><i>file </i>
          <br>Initialises the array with the contents of
              the specified <i>file</i>, which must contain an
              array in property-list format.
            In GNUstep, the property-list format may be either the
              OpenStep format (ASCII data), or the MacOS-X
              format (URF8 XML data)... this method will
              recognise which it is.
            If there is a failure to load the <i>file</i> for
              any reason, the receiver will be released, the method
              will return <code>nil</code>, and a warning may be
              logged.
            Works by invoking
              <ref id="method**NSString**-initWithContentsOfFile:">[NSString% unknown entity: nbsp
-initWithContentsOfFile:]</ref> and <ref id="method**NSString**-propertyList">[NSString% unknown entity: nbsp
-propertyList]</ref> then checking that the result is an array.


        



<section name="initWithObjects:">
<label id="method**NSArray**-initWithObjects:" />- <code>(id) </code>
          <b>initWithObjects: </b>
          <code>(id) </code><i>firstObject </i>
          
          <br>Initialize the array the list of objects. 
<br>

            May change the value of self before returning it.


        



<section name="initWithObjects:count:">
<label id="method**NSArray**-initWithObjects:count:" />- <code>(id) </code>
          <b>initWithObjects: </b>
          <code>(id*) </code><i>objects </i>
          <b>count: </b>
          <code>(unsigned) </code><i>count </i>
          <br>Initialize the array with <i>count</i>
            <i>objects</i>. 
<br>
 Retains each object placed
            in the array. 
<br>
 Like all initializers, may change
            the value of self before returning it.


        



<section name="isEqualToArray:">
<label id="method**NSArray**-isEqualToArray:" />- <code>(BOOL) </code>
          <b>isEqualToArray: </b>
          <code>(NSArray*) </code><i>otherArray </i>
          <br>Returns <code>YES</code> if the receiver is equal
            to <i>otherArray</i>, <code>NO</code> otherwise.


        



<section name="lastObject">
<label id="method**NSArray**-lastObject" />- <code>(id) </code>
          <b>lastObject </b>
          <br>Returns the last object in the receiver, or
            <code>nil</code> if the receiver is empty.


        



<section name="makeObjectsPerform:">
<label id="method**NSArray**-makeObjectsPerform:" />- <code>(void) </code>
          <b>makeObjectsPerform: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Obsolete version of
            <ref id="method**NSArray**-makeObjectsPerformSelector:">
              -makeObjectsPerformSelector:
            </ref>


        



<section name="makeObjectsPerform:withObject:">
<label id="method**NSArray**-makeObjectsPerform:withObject:" />- <code>(void) </code>
          <b>makeObjectsPerform: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>withObject: </b>
          <code>(id) </code><i>argument </i>
          <br>Obsolete version of
            <ref id="method**NSArray**-makeObjectsPerformSelector:withObject:">-makeObjectsPerformSelector:withObject:</ref>


        



<section name="makeObjectsPerformSelector:">
<label id="method**NSArray**-makeObjectsPerformSelector:" />- <code>(void) </code>
          <b>makeObjectsPerformSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <br>Makes each object in the array perform
            <i>aSelector</i>. 
<br>
 This is done
            sequentially from the last to the first
            object.


        



<section name="makeObjectsPerformSelector:withObject:">
<label id="method**NSArray**-makeObjectsPerformSelector:withObject:" />- <code>(void) </code>
          <b>makeObjectsPerformSelector: </b>
          <code>(SEL) </code><i>aSelector </i>
          <b>withObject: </b>
          <code>(id) </code><i>arg </i>
          <br>Makes each object in the array perform
            <i>aSelector</i> with <i>arg</i>. 
<br>
 This
            is done sequentially from the last to the first object.


        



<section name="objectAtIndex:">
<label id="method**NSArray**-objectAtIndex:" />- <code>(id) </code>
          <b>objectAtIndex: </b>
          <code>(unsigned) </code><i>index </i>
          <br>Returns the object at the specified
            <i>index</i>. Raises an exception of the
            <i>index</i> is beyond the array.


        



<section name="objectEnumerator">
<label id="method**NSArray**-objectEnumerator" />- <code>(NSEnumerator*) </code>
          <b>objectEnumerator </b>
          <br>Returns an enumerator describing the array
            sequentially from the first to the last
            element. 
<br>
 If you use a mutable subclass of
            NSArray, you should not modify the array during
            enumeration.


        



<section name="pathsMatchingExtensions:">
<label id="method**NSArray**-pathsMatchingExtensions:" />- <code>(NSArray*) </code>
          <b>pathsMatchingExtensions: </b>
          <code>(NSArray*) </code><i>extensions </i>
          <br>Assumes that the receiver is an array of paths, and
            returns an array formed by selecting the subset of
            those patch matching the specified array of
            <i>extensions</i>.


        



<section name="reverseObjectEnumerator">
<label id="method**NSArray**-reverseObjectEnumerator" />- <code>(NSEnumerator*) </code>
          <b>reverseObjectEnumerator </b>
          <br>Returns an enumerator describing the array
            sequentially from the last to the first
            element. 
<br>
 If you use a mutable subclass of
            NSArray, you should not modify the array during
            enumeration.


        



<section name="sortedArrayHint">
<label id="method**NSArray**-sortedArrayHint" />- <code>(NSData*) </code>
          <b>sortedArrayHint </b>
          <br>Subclasses may provide a hint for sorting... The
            default GNUstep implementation just returns
            <code>nil</code>.


        



<section name="sortedArrayUsingFunction:context:">
<label id="method**NSArray**-sortedArrayUsingFunction:context:" />- <code>(NSArray*) </code>
          <b>sortedArrayUsingFunction: </b>
          <code>(int(*)(id,id,void*)) </code><i>comparator </i>
          <b>context: </b>
          <code>(void*) </code><i>context </i>
          <br>Returns an autoreleased array in which the objects
            are ordered according to a sort with
            <i>comparator</i>. This invokes
            <ref id="method**NSArray**-sortedArrayUsingFunction:context:hint:">-sortedArrayUsingFunction:context:hint:</ref> with a <code>nil</code> hint.


        



<section name="sortedArrayUsingFunction:context:hint:">
<label id="method**NSArray**-sortedArrayUsingFunction:context:hint:" />- <code>(NSArray*) </code>
          <b>sortedArrayUsingFunction: </b>
          <code>(int(*)(id,id,void*)) </code><i>comparator </i>
          <b>context: </b>
          <code>(void*) </code><i>context </i>
          <b>hint: </b>
          <code>(NSData*) </code><i>hint </i>
          <br>Returns an autoreleased array in which the objects
            are ordered according to a sort with
            <i>comparator</i>, where the
            <i>comparator</i> function is passed two objects
            to compare, and the copntext as the third argument.


        



<section name="sortedArrayUsingSelector:">
<label id="method**NSArray**-sortedArrayUsingSelector:" />- <code>(NSArray*) </code>
          <b>sortedArrayUsingSelector: </b>
          <code>(SEL) </code><i>comparator </i>
          <br>Returns an autoreleased array in which the objects
            are ordered according to a sort with
            <i>comparator</i>.


        



<section name="subarrayWithRange:">
<label id="method**NSArray**-subarrayWithRange:" />- <code>(NSArray*) </code>
          <b>subarrayWithRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Returns a subarray of the receiver containing the
            objects found in the specified range
            <i>aRange</i>.


        



<section name="writeToFile:atomically:">
<label id="method**NSArray**-writeToFile:atomically:" />- <code>(BOOL) </code>
          <b>writeToFile: </b>
          <code>(NSString*) </code><i>path </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxiliaryFile </i>
          <br>Writes the contents of the array to the file
              specified by <i>path</i>. The file contents
              will be in property-list format... under GNUstep
              this is either OpenStep style (ASCII characters
              using \U hexadecimal escape sequences for unicode),
              or MacOS-X style (XML in the UTF8 character set).
            If the <i>useAuxiliaryFile</i> flag is
              <code>YES</code>, the file write operation is
              atomic... the data is written to a temporary file,
              which is then renamed to the actual file name.
            If the conversion of data into the correct
              property-list format fails or the write
              operation fails, the method returns
              <code>NO</code>, otherwise it returns
              <code>YES</code>.
            NB. The fact that the file is in property-list format
              does not necessarily mean that it can be used to
              reconstruct the array using the
              <ref id="method**NSArray**-initWithContentsOfFile:">
                -initWithContentsOfFile:
              </ref>
              method. If the original array contains
              non-property-list objects, the
              descriptions of those objects will have been
              written, and reading in the file as a
              property-list will result in a new array
              containing the string descriptions.


        



<section name="writeToURL:atomically:">
<label id="method**NSArray**-writeToURL:atomically:" />- <code>(BOOL) </code>
          <b>writeToURL: </b>
          <code>(NSURL*) </code><i>url </i>
          <b>atomically: </b>
          <code>(BOOL) </code><i>useAuxiliaryFile </i>
          <br>Writes the contents of the array to the specified
              <i>url</i>. This functions just like
              <ref id="method**NSArray**-writeToFile:atomically:">
                -writeToFile:atomically:
              </ref>
              except that the output may be written to any URL,
              not just a local file.


        


</section>


</chapter>


<chapter name="NSBundle">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSBundle">NSBundle</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSBundle.h
</section>

<section name="Description">
<br>NSBundle provides methods for locating and
            handling application (and tool) resources at
            runtime. Resources includes any time of file that
            the application might need, such as images, nib (gorm
            or gmodel) files, localization files, and any other type
            of file that an application might need to use to
            function. Resources also include executable code,
            which can be dynamically linked into the application
            at runtime. These files and executable code are commonly
            put together into a directory called a bundle.
          NSBundle knows how these bundles are organized and
            can search for files inside a bundle. NSBundle also
            handles locating the executable code, linking this
            in and initializing any classes that are located in the
            code. NSBundle also handles Frameworks, which are
            basically a bundle that contains a library
            archive. The organization of a framework is a
            little difference, but in most respects there is no
            difference between a bundle and a framework.
          There is one special bundle, called the mainBundle,
            which is basically the application itself. The
            mainBundle is always loaded (of course), but you
            can still perform other operations on the mainBundle,
            such as searching for files, just as with any other
            bundle.


</section>

<section name="Methods">


<section name="allBundles">
<label id="method**NSBundle**+allBundles" />+ <code>(NSArray*) </code>
          <b>allBundles </b>
          <br>Return an array enumerating all the bundles in the
            application. This does not include frameworks.


        



<section name="allFrameworks">
<label id="method**NSBundle**+allFrameworks" />+ <code>(NSArray*) </code>
          <b>allFrameworks </b>
          <br>Return an array enumerating all the frameworks in
            the application. This does not include normal bundles.


        



<section name="bundleForClass:">
<label id="method**NSBundle**+bundleForClass:" />+ <code>(NSBundle*) </code>
          <b>bundleForClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Return the bundle to which <i>aClass</i>
              belongs. If <i>aClass</i> was loaded from a
              bundle, return the bundle; if it belongs to a
              framework (either a framework linked into the
              application, or loaded dynamically), return
              the framework; in all other cases, return the main
              bundle.
            Please note that GNUstep supports plain shared
              libraries, while the openstep standard, and
              other openstep-like systems, do not; the behaviour
              when <i>aClass</i> belongs to a plain shared
              library is at the moment still under
              investigation -- you should consider it
              undefined since it might be changed. :-)


        



<section name="bundleWithPath:">
<label id="method**NSBundle**+bundleWithPath:" />+ <code>(NSBundle*) </code>
          <b>bundleWithPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Return a bundle for the <i>path</i> at
            <i>path</i>. If <i>path</i> doesn't exist or
            is not readable, return <code>nil</code>. If you want
            the main bundle of an application or a tool, it's
            better if you use
            <ref id="method**NSBundle**+mainBundle">
              +mainBundle
            </ref>
            .


        



<section name="mainBundle">
<label id="method**NSBundle**+mainBundle" />+ <code>(NSBundle*) </code>
          <b>mainBundle </b>
          <br>Return the bundle containing the resources for the
              executable. If the executable is an
              application, this is the main application
              bundle (the xxx.app directory); if the executable
              is a tool, this is a bundle 'naturally' associated
              with the tool: if the tool executable is
              xxx/Tools/ix86/linux-gnu/gnu-gnu-gnu/Control
              then the tool's main bundle directory is
              xxx/Tools/Resources/Control.
            NB: traditionally tools didn't have a main bundle --
              this is a recent GNUstep extension, but it's quite
              nice and it's here to stay.
            The main bundle is where the application should put
              all of its resources, such as support files (images,
              html, rtf, txt,...), localization tables,.gorm
              (.nib) files, etc. gnustep-make (/ProjectCenter)
              allows you to easily specify the resource files to
              put in the main bundle when you create an application
              or a tool.


        



<section name="pathForResource:ofType:inDirectory:">
<label id="method**NSBundle**+pathForResource:ofType:inDirectory:" />+ <code>(NSString*) </code>
          <b>pathForResource: </b>
          <code>(NSString*) </code><i>name </i>
          <b>ofType: </b>
          <code>(NSString*) </code><i>ext </i>
          <b>inDirectory: </b>
          <code>(NSString*) </code><i>bundlePath </i>
          <br>Returns an absolute path for a resource
            <i>name</i> with the extension <i>ext</i> in
            the specified <i>bundlePath</i>. See also
            <ref id="method**NSBundle**-pathForResource:ofType:inDirectory:">-pathForResource:ofType:inDirectory:</ref> for more information on searching a bundle.


        



<section name="pathForResource:ofType:inDirectory:withVersion:">
<label id="method**NSBundle**+pathForResource:ofType:inDirectory:withVersion:" />+ <code>(NSString*) </code>
          <b>pathForResource: </b>
          <code>(NSString*) </code><i>name </i>
          <b>ofType: </b>
          <code>(NSString*) </code><i>ext </i>
          <b>inDirectory: </b>
          <code>(NSString*) </code><i>bundlePath </i>
          <b>withVersion: </b>
          <code>(int) </code><i>version </i>
          <br>This method has been depreciated. Version numbers were
            never implemented so this method behaves exactly like
            <ref id="method**NSBundle**+pathForResource:ofType:inDirectory:">+pathForResource:ofType:inDirectory:</ref>.


        



<section name="pathsForResourcesOfType:inDirectory:">
<label id="method**NSBundle**+pathsForResourcesOfType:inDirectory:" />+ <code>(NSArray*) </code>
          <b>pathsForResourcesOfType: </b>
          <code>(NSString*) </code><i>extension </i>
          <b>inDirectory: </b>
          <code>(NSString*) </code><i>bundlePath </i>
          <br><em>Description forthcoming.</em>


        



<section name="preferredLocalizationsFromArray:">
<label id="method**NSBundle**+preferredLocalizationsFromArray:" />+ <code>(NSArray*) </code>
          <b>preferredLocalizationsFromArray: </b>
          <code>(NSArray*) </code><i>localizationsArray </i>
          <br><em>Description forthcoming.</em>


        



<section name="preferredLocalizationsFromArray:forPreferences:">
<label id="method**NSBundle**+preferredLocalizationsFromArray:forPreferences:" />+ <code>(NSArray*) </code>
          <b>preferredLocalizationsFromArray: </b>
          <code>(NSArray*) </code><i>localizationsArray </i>
          <b>forPreferences: </b>
          <code>(NSArray*) </code><i>preferencesArray </i>
          <br><em>Description forthcoming.</em>


        



<section name="bundlePath">
<label id="method**NSBundle**-bundlePath" />- <code>(NSString*) </code>
          <b>bundlePath </b>
          <br>Return the path to the bundle - an absolute path.


        



<section name="bundleVersion">
<label id="method**NSBundle**-bundleVersion" />- <code>(unsigned) </code>
          <b>bundleVersion </b>
          <br>Returns the bundle version.


        



<section name="classNamed:">
<label id="method**NSBundle**-classNamed:" />- <code>(Class) </code>
          <b>classNamed: </b>
          <code>(NSString*) </code><i>className </i>
          <br>Returns the class in the bundle with the given
            name. If no class of this name exists in the bundle,
            then Nil is returned.


        



<section name="executablePath">
<label id="method**NSBundle**-executablePath" />- <code>(NSString*) </code>
          <b>executablePath </b>
          <br>Returns the path to the executable code in the
            bundle


        



<section name="infoDictionary">
<label id="method**NSBundle**-infoDictionary" />- <code>(NSDictionary*) </code>
          <b>infoDictionary </b>
          <br>Returns the info property list associated with the
            bundle.


        



<section name="initWithPath:">
<label id="method**NSBundle**-initWithPath:" />- <code>(id) </code>
          <b>initWithPath: </b>
          <code>(NSString*) </code><i>path </i>
          <br>Init the bundle for reading resources from
            <i>path</i>. <i>path</i> must be an absolute
            <i>path</i> to a directory on disk. If
            <i>path</i> is <code>nil</code> or doesn't exist,
            initWithPath: returns <code>nil</code>. If a
            bundle for that <i>path</i> already existed, it
            is returned in place of the receiver (and the receiver
            is deallocated).


        



<section name="isLoaded">
<label id="method**NSBundle**-isLoaded" />- <code>(BOOL) </code>
          <b>isLoaded </b>
          <br>Returns <code>YES</code> if the receiver's code is
            loaded, otherwise, returns <code>NO</code>.


        



<section name="load">
<label id="method**NSBundle**-load" />- <code>(BOOL) </code>
          <b>load </b>
          <br>Loads any executable code contained in the bundle
            into the application. Load will be called implicitly
            if any information about the bundle classes is
            requested, such as
            <ref id="method**NSBundle**-principalClass">
              -principalClass
            </ref>
            or
            <ref id="method**NSBundle**-classNamed:">
              -classNamed:
            </ref>
            .


        



<section name="localizations">
<label id="method**NSBundle**-localizations" />- <code>(NSArray*) </code>
          <b>localizations </b>
          <br>Returns all the localizations in the bundle.


        



<section name="localizedInfoDictionary">
<label id="method**NSBundle**-localizedInfoDictionary" />- <code>(NSDictionary*) </code>
          <b>localizedInfoDictionary </b>
          <br>Returns a localized info property list based on the
            preferred localization or the most appropriate
            localization if the preferred one cannot be
            found.


        



<section name="localizedStringForKey:value:table:">
<label id="method**NSBundle**-localizedStringForKey:value:table:" />- <code>(NSString*) </code>
          <b>localizedStringForKey: </b>
          <code>(NSString*) </code><i>key </i>
          <b>value: </b>
          <code>(NSString*) </code><i>value </i>
          <b>table: </b>
          <code>(NSString*) </code><i>tableName </i>
          <br>Returns the <i>value</i> for the <i>key</i>
            found in the strings file <i>tableName</i>, or
            Localizable.strings if
            <i>tableName</i> is <code>nil</code>.


        



<section name="pathForResource:ofType:">
<label id="method**NSBundle**-pathForResource:ofType:" />- <code>(NSString*) </code>
          <b>pathForResource: </b>
          <code>(NSString*) </code><i>name </i>
          <b>ofType: </b>
          <code>(NSString*) </code><i>ext </i>
          <br>Returns an absolute path for a resource
            <i>name</i> with the extension <i>ext</i> in
            the receivers bundle path. See
            <ref id="method**NSBundle**-pathForResource:ofType:inDirectory:">-pathForResource:ofType:inDirectory:</ref>.


        



<section name="pathForResource:ofType:inDirectory:">
<label id="method**NSBundle**-pathForResource:ofType:inDirectory:" />- <code>(NSString*) </code>
          <b>pathForResource: </b>
          <code>(NSString*) </code><i>name </i>
          <b>ofType: </b>
          <code>(NSString*) </code><i>ext </i>
          <b>inDirectory: </b>
          <code>(NSString*) </code><i>bundlePath </i>
          <br>Returns an absolute path for a resource
              <i>name</i> with the extension <i>ext</i>
              in the specified <i>bundlePath</i>. Directories in
              the bundle are searched in the following order:

            where lanuage.lproj can be any localized language
              directory inside the bundle.
            If <i>ext</i> is <code>nil</code> or empty, then
              the first file with <i>name</i> and any extension
              is returned.


        



<section name="pathForResource:ofType:inDirectory:forLocalization:">
<label id="method**NSBundle**-pathForResource:ofType:inDirectory:forLocalization:" />- <code>(NSString*) </code>
          <b>pathForResource: </b>
          <code>(NSString*) </code><i>name </i>
          <b>ofType: </b>
          <code>(NSString*) </code><i>ext </i>
          <b>inDirectory: </b>
          <code>(NSString*) </code><i>bundlePath </i>
          <b>forLocalization: </b>
          <code>(NSString*) </code><i>localizationName </i>
          <br><em>Description forthcoming.</em>


        



<section name="pathsForResourcesOfType:inDirectory:">
<label id="method**NSBundle**-pathsForResourcesOfType:inDirectory:" />- <code>(NSArray*) </code>
          <b>pathsForResourcesOfType: </b>
          <code>(NSString*) </code><i>extension </i>
          <b>inDirectory: </b>
          <code>(NSString*) </code><i>bundlePath </i>
          <br>Returns an array of paths for all resources with
              the specified <i>extension</i> and residing in
              the <i>bundlePath</i> directory. If
              <i>extension</i> is <code>nil</code> or empty,
              all bundle resources are returned.


        



<section name="pathsForResourcesOfType:inDirectory:forLocalization:">
<label id="method**NSBundle**-pathsForResourcesOfType:inDirectory:forLocalization:" />- <code>(NSArray*) </code>
          <b>pathsForResourcesOfType: </b>
          <code>(NSString*) </code><i>extension </i>
          <b>inDirectory: </b>
          <code>(NSString*) </code><i>bundlePath </i>
          <b>forLocalization: </b>
          <code>(NSString*) </code><i>localizationName </i>
          <br><em>Description forthcoming.</em>


        



<section name="preferredLocalizations">
<label id="method**NSBundle**-preferredLocalizations" />- <code>(NSArray*) </code>
          <b>preferredLocalizations </b>
          <br>Returns the list of localizations that the bundle
            uses to search for information. This is based on the
            user's preferences.


        



<section name="principalClass">
<label id="method**NSBundle**-principalClass" />- <code>(Class) </code>
          <b>principalClass </b>
          <br>Returns the principal class of the bundle. This is
            the class specified by the NSPrincipalClass key in the
            Info-gnustep property list contained in the
            bundle. If this key is not found, the class
            returned is arbitrary, although it is typically
            the first class compiled into the archive.


        



<section name="resourcePath">
<label id="method**NSBundle**-resourcePath" />- <code>(NSString*) </code>
          <b>resourcePath </b>
          <br>Returns the absolute path to the resources
            directory of the bundle.


        



<section name="setBundleVersion:">
<label id="method**NSBundle**-setBundleVersion:" />- <code>(void) </code>
          <b>setBundleVersion: </b>
          <code>(unsigned) </code><i>version </i>
          <br>Set the bundle <i>version</i>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSMutableArray">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableArray">NSMutableArray</ref>: <ref id="NSArray">NSArray</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSArray.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="arrayWithCapacity:">
<label id="method**NSMutableArray**+arrayWithCapacity:" />+ <code>(id) </code>
          <b>arrayWithCapacity: </b>
          <code>(unsigned) </code><i>numItems </i>
          <br>Creates an autoreleased mutable array anble to
            store at least <i>numItems</i>. See the
            <ref id="method**NSMutableArray**-initWithCapacity:">
              -initWithCapacity:
            </ref>
            method.


        



<section name="addObject:">
<label id="method**NSMutableArray**-addObject:" />- <code>(void) </code>
          <b>addObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Adds <i>anObject</i> at the end of the array, thus
            increasing the size of the array. The object is
            retained upon addition.


        



<section name="addObjectsFromArray:">
<label id="method**NSMutableArray**-addObjectsFromArray:" />- <code>(void) </code>
          <b>addObjectsFromArray: </b>
          <code>(NSArray*) </code><i>otherArray </i>
          <br>Adds each object from <i>otherArray</i> to the
            receiver, in first to last order.


        



<section name="exchangeObjectAtIndex:withObjectAtIndex:">
<label id="method**NSMutableArray**-exchangeObjectAtIndex:withObjectAtIndex:" />- <code>(void) </code>
          <b>exchangeObjectAtIndex: </b>
          <code>(unsigned int) </code><i>i1 </i>
          <b>withObjectAtIndex: </b>
          <code>(unsigned int) </code><i>i2 </i>
          <br>Swaps the positions of two objects in the array.
            Raises an exception if either array index is out of
            bounds.


        



<section name="initWithCapacity:">
<label id="method**NSMutableArray**-initWithCapacity:" />- <code>(id) </code>
          <b>initWithCapacity: </b>
          <code>(unsigned) </code><i>numItems </i>
          <br>Initialise the array with the specified capacity
            ... this should ensure that the array can have
            <i>numItems</i> added efficiently.


        



<section name="insertObject:atIndex:">
<label id="method**NSMutableArray**-insertObject:atIndex:" />- <code>(void) </code>
          <b>insertObject: </b>
          <code>(id) </code><i>anObject </i>
          <b>atIndex: </b>
          <code>(unsigned) </code><i>index </i>
          <br>Inserts an object into the receiver at the
            specified location. 
<br>
 Raises an exception if
            given an array <i>index</i> which is too large.
            
<br>
 The size of the array increases by one.
            
<br>
 The object is retained by the array.


        



<section name="removeAllObjects">
<label id="method**NSMutableArray**-removeAllObjects" />- <code>(void) </code>
          <b>removeAllObjects </b>
          <br>Removes all objects from the receiver, leaving an
            empty array.


        



<section name="removeLastObject">
<label id="method**NSMutableArray**-removeLastObject" />- <code>(void) </code>
          <b>removeLastObject </b>
          <br>Removes the last object in the array. Raises an
            exception if the array is already empty.


        



<section name="removeObject:">
<label id="method**NSMutableArray**-removeObject:" />- <code>(void) </code>
          <b>removeObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Removes all occurrances of <i>anObject</i>
            (found by anObjects
            <ref id="method**NSMutableArray**-isEqual:">
              -isEqual:
            </ref>
            method) from the receiver.


        



<section name="removeObject:inRange:">
<label id="method**NSMutableArray**-removeObject:inRange:" />- <code>(void) </code>
          <b>removeObject: </b>
          <code>(id) </code><i>anObject </i>
          <b>inRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Removes all occurrances of <i>anObject</i>
            (found by the
            <ref id="method**NSMutableArray**-isEqual:">
              -isEqual:
            </ref>
            method of <i>anObject</i>) <i>aRange</i> in
            the receiver.


        



<section name="removeObjectAtIndex:">
<label id="method**NSMutableArray**-removeObjectAtIndex:" />- <code>(void) </code>
          <b>removeObjectAtIndex: </b>
          <code>(unsigned) </code><i>index </i>
          <br>Removes an object from the receiver at the
            specified location. 
<br>
 The size of the array
            decreases by one. 
<br>
 Raises an exception if
            given an array <i>index</i> which is too large.
            
<br>


        



<section name="removeObjectIdenticalTo:">
<label id="method**NSMutableArray**-removeObjectIdenticalTo:" />- <code>(void) </code>
          <b>removeObjectIdenticalTo: </b>
          <code>(id) </code><i>anObject </i>
          <br>Removes all occurrances of <i>anObject</i>
            (found by pointer equality) from the receiver.


        



<section name="removeObjectIdenticalTo:inRange:">
<label id="method**NSMutableArray**-removeObjectIdenticalTo:inRange:" />- <code>(void) </code>
          <b>removeObjectIdenticalTo: </b>
          <code>(id) </code><i>anObject </i>
          <b>inRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Removes all occurrances of <i>anObject</i>
            (found by pointer equality) from <i>aRange</i>
            in the receiver.


        



<section name="removeObjectsFromIndices:numIndices:">
<label id="method**NSMutableArray**-removeObjectsFromIndices:numIndices:" />- <code>(void) </code>
          <b>removeObjectsFromIndices: </b>
          <code>(unsigned*) </code><i>indices </i>
          <b>numIndices: </b>
          <code>(unsigned) </code><i>count </i>
          <br>Supplied with a C array of <i>indices</i>
            containing <i>count</i> values, this method
            removes all corresponding objects from the
            receiver. The objects are removed in such a way
            that the removal is <em>safe</em> irrespective of the
            order in which they are specified in the
            <i>indices</i> array.


        



<section name="removeObjectsInArray:">
<label id="method**NSMutableArray**-removeObjectsInArray:" />- <code>(void) </code>
          <b>removeObjectsInArray: </b>
          <code>(NSArray*) </code><i>otherArray </i>
          <br>Removes from the receiver, all the objects present
            in <i>otherArray</i>, as determined by using the
            <ref id="method**NSMutableArray**-isEqual:">
              -isEqual:
            </ref>
            method.


        



<section name="removeObjectsInRange:">
<label id="method**NSMutableArray**-removeObjectsInRange:" />- <code>(void) </code>
          <b>removeObjectsInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <br>Removes all the objects in <i>aRange</i> from
            the receiver.


        



<section name="replaceObjectAtIndex:withObject:">
<label id="method**NSMutableArray**-replaceObjectAtIndex:withObject:" />- <code>(void) </code>
          <b>replaceObjectAtIndex: </b>
          <code>(unsigned) </code><i>index </i>
          <b>withObject: </b>
          <code>(id) </code><i>anObject </i>
          <br>Places an object into the receiver at the specified
            location. 
<br>
 Raises an exception if given an
            array <i>index</i> which is too large. 
<br>
 The
            object is retained by the array.


        



<section name="replaceObjectsInRange:withObjectsFromArray:">
<label id="method**NSMutableArray**-replaceObjectsInRange:withObjectsFromArray:" />- <code>(void) </code>
          <b>replaceObjectsInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>withObjectsFromArray: </b>
          <code>(NSArray*) </code><i>anArray </i>
          <br>Replaces objects in the receiver with those from
            <i>anArray</i>. 
<br>
 Raises an exception if
            given a range extending beyond the array. 
<br>


        



<section name="replaceObjectsInRange:withObjectsFromArray:range:">
<label id="method**NSMutableArray**-replaceObjectsInRange:withObjectsFromArray:range:" />- <code>(void) </code>
          <b>replaceObjectsInRange: </b>
          <code>(NSRange) </code><i>aRange </i>
          <b>withObjectsFromArray: </b>
          <code>(NSArray*) </code><i>anArray </i>
          <b>range: </b>
          <code>(NSRange) </code><i>anotherRange </i>
          <br>Replaces objects in the receiver with some of
            those from <i>anArray</i>. 
<br>
 Raises an
            exception if given a range extending beyond the
            array. 
<br>


        



<section name="setArray:">
<label id="method**NSMutableArray**-setArray:" />- <code>(void) </code>
          <b>setArray: </b>
          <code>(NSArray*) </code><i>otherArray </i>
          <br>Sets the contents of the receiver to be identical to
            the contents of othrArray.


        



<section name="sortUsingFunction:context:">
<label id="method**NSMutableArray**-sortUsingFunction:context:" />- <code>(void) </code>
          <b>sortUsingFunction: </b>
          <code>(int(*)(id,id,void*)) </code><i>compare </i>
          <b>context: </b>
          <code>(void*) </code><i>context </i>
          <br>Sorts the array according to the supplied
            <i>compare</i> function with the
            <i>context</i> information.


        



<section name="sortUsingSelector:">
<label id="method**NSMutableArray**-sortUsingSelector:" />- <code>(void) </code>
          <b>sortUsingSelector: </b>
          <code>(SEL) </code><i>comparator </i>
          <br>Sorts the array according to the supplied
            <i>comparator</i>.


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSLongLongNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSLongLongNumber">NSLongLongNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSMutableString">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableString">NSMutableString</ref>: <ref id="NSString">NSString</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSString.h
</section>

<section name="Description">
<br>This is the mutable form of the NSString class.


</section>

<section name="Methods">


<section name="string">
<label id="method**NSMutableString**+string" />+ <code>(id) </code>
          <b>string </b>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithCString:">
<label id="method**NSMutableString**+stringWithCString:" />+ <code>(id) </code>
          <b>stringWithCString: </b>
          <code>(const char*) </code><i>byteString </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithCString:length:">
<label id="method**NSMutableString**+stringWithCString:length:" />+ <code>(id) </code>
          <b>stringWithCString: </b>
          <code>(const char*) </code><i>byteString </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithCapacity:">
<label id="method**NSMutableString**+stringWithCapacity:" />+ <code>(NSMutableString*) </code>
          <b>stringWithCapacity: </b>
          <code>(unsigned int) </code><i>capacity </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithCharacters:length:">
<label id="method**NSMutableString**+stringWithCharacters:length:" />+ <code>(id) </code>
          <b>stringWithCharacters: </b>
          <code>(const unichar*) </code><i>characters </i>
          <b>length: </b>
          <code>(unsigned int) </code><i>length </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithContentsOfFile:">
<label id="method**NSMutableString**+stringWithContentsOfFile:" />+ <code>(id) </code>
          <b>stringWithContentsOfFile: </b>
          <code>(NSString*) </code><i>path </i>
          <br><em>Description forthcoming.</em>


        



<section name="stringWithFormat:">
<label id="method**NSMutableString**+stringWithFormat:" />+ <code>(id) </code>
          <b>stringWithFormat: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="appendFormat:">
<label id="method**NSMutableString**-appendFormat:" />- <code>(void) </code>
          <b>appendFormat: </b>
          <code>(NSString*) </code><i>format </i>
          
          <br><em>Description forthcoming.</em>


        



<section name="appendString:">
<label id="method**NSMutableString**-appendString:" />- <code>(void) </code>
          <b>appendString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="deleteCharactersInRange:">
<label id="method**NSMutableString**-deleteCharactersInRange:" />- <code>(void) </code>
          <b>deleteCharactersInRange: </b>
          <code>(NSRange) </code><i>range </i>
          <br><em>Description forthcoming.</em>


        



<section name="initWithCapacity:">
<label id="method**NSMutableString**-initWithCapacity:" />- <code>(id) </code>
          <b>initWithCapacity: </b>
          <code>(unsigned int) </code><i>capacity </i>
          <br><em>Description forthcoming.</em>


        



<section name="insertString:atIndex:">
<label id="method**NSMutableString**-insertString:atIndex:" />- <code>(void) </code>
          <b>insertString: </b>
          <code>(NSString*) </code><i>aString </i>
          <b>atIndex: </b>
          <code>(unsigned int) </code><i>loc </i>
          <br><em>Description forthcoming.</em>


        



<section name="replaceCharactersInRange:withString:">
<label id="method**NSMutableString**-replaceCharactersInRange:withString:" />- <code>(void) </code>
          <b>replaceCharactersInRange: </b>
          <code>(NSRange) </code><i>range </i>
          <b>withString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        



<section name="replaceOccurrencesOfString:withString:options:range:">
<label id="method**NSMutableString**-replaceOccurrencesOfString:withString:options:range:" />- <code>(unsigned int) </code>
          <b>replaceOccurrencesOfString: </b>
          <code>(NSString*) </code><i>replace </i>
          <b>withString: </b>
          <code>(NSString*) </code><i>by </i>
          <b>options: </b>
          <code>(unsigned int) </code><i>opts </i>
          <b>range: </b>
          <code>(NSRange) </code><i>searchRange </i>
          <br>Replaces all occurrences of the <i>replace</i>
            string with the <i>by</i> string, for those
            cases where the entire <i>replace</i> string lies
            within the specified <i>searchRange</i> value.
            
<br>
 The value of <i>opts</i> determines the
            direction of the search is and whether only
            leading/trailing occurrances (anchored
            search) of <i>replace</i> are substituted.
            
<br>
 Raises NSInvalidArgumentException if either
            string argument is <code>nil</code>. 
<br>
 Raises
            NSRangeException if part of
            <i>searchRange</i> is beyond the end of the
            receiver.


        



<section name="setString:">
<label id="method**NSMutableString**-setString:" />- <code>(void) </code>
          <b>setString: </b>
          <code>(NSString*) </code><i>aString </i>
          <br><em>Description forthcoming.</em>


        


        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="GSHTMLParser">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSHTMLParser">GSHTMLParser</ref>: <ref id="GSXMLParser">GSXMLParser</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="NSClassDescription">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSClassDescription">NSClassDescription</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSClassDescription.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="classDescriptionForClass:">
<label id="method**NSClassDescription**+classDescriptionForClass:" />+ <code>(NSClassDescription*) </code>
          <b>classDescriptionForClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Returns the class descriptuion for
            <i>aClass</i>. If there is no such description
            available, sends an
            NSClassDescriptionNeededForClassNotification
            (with <i>aClass</i> as its object) so that
            objects providing class descriptions can register
            one, and tries again to find one. 
<br>
 Returns
            <code>nil</code> if there is no description found.
            
<br>
 Handles locking to ensure thread safety and
            ensures that the returned object will not be
            destroyed by other threads.


        



<section name="invalidateClassDescriptionCache">
<label id="method**NSClassDescription**+invalidateClassDescriptionCache" />+ <code>(void) </code>
          <b>invalidateClassDescriptionCache </b>
          <br>Invalidates the cache of class descriptions so
            the new descriptions will be fetched as required and
            begin to refil the cache. You need this only if you
            suspect that a class description should have
            changed.


        



<section name="registerClassDescription:forClass:">
<label id="method**NSClassDescription**+registerClassDescription:forClass:" />+ <code>(void) </code>
          <b>registerClassDescription: </b>
          <code>(NSClassDescription*) </code><i>aDescription </i>
          <b>forClass: </b>
          <code>(Class) </code><i>aClass </i>
          <br>Registers <i>aDescription</i> for
            <i>aClass</i>... placing it in the cache and
            replacing any previous version.


        



<section name="attributeKeys">
<label id="method**NSClassDescription**-attributeKeys" />- <code>(NSArray*) </code>
          <b>attributeKeys </b>
          <br>Returns the attribute keys - default implementation
            returns <code>nil</code>.


        



<section name="inverseForRelationshipKey:">
<label id="method**NSClassDescription**-inverseForRelationshipKey:" />- <code>(NSString*) </code>
          <b>inverseForRelationshipKey: </b>
          <code>(NSString*) </code><i>aKey </i>
          <br>Returns the inverse relationship keys - default
            implementation returns <code>nil</code>.


        



<section name="toManyRelationshipKeys">
<label id="method**NSClassDescription**-toManyRelationshipKeys" />- <code>(NSArray*) </code>
          <b>toManyRelationshipKeys </b>
          <br>Returns the to many relationship keys - default
            implementation returns <code>nil</code>.


        



<section name="toOneRelationshipKeys">
<label id="method**NSClassDescription**-toOneRelationshipKeys" />- <code>(NSArray*) </code>
          <b>toOneRelationshipKeys </b>
          <br>Returns the to one relationship keys - default
            implementation returns <code>nil</code>.


        


        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSMutableDictionary">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSMutableDictionary">NSMutableDictionary</ref>: <ref id="NSDictionary">NSDictionary</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSDictionary.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">


<section name="dictionaryWithCapacity:">
<label id="method**NSMutableDictionary**+dictionaryWithCapacity:" />+ <code>(id) </code>
          <b>dictionaryWithCapacity: </b>
          <code>(unsigned) </code><i>numItems </i>
          <br><em>Description forthcoming.</em>


        



<section name="addEntriesFromDictionary:">
<label id="method**NSMutableDictionary**-addEntriesFromDictionary:" />- <code>(void) </code>
          <b>addEntriesFromDictionary: </b>
          <code>(NSDictionary*) </code><i>otherDictionary </i>
          <br>Merges information from <i>otherDictionary</i>
            into the receiver. If a key exists in both
            dictionaries, the value from
            <i>otherDictionary</i> replaces that which was
            originally in the reciever.


        



<section name="initWithCapacity:">
<label id="method**NSMutableDictionary**-initWithCapacity:" />- <code>(id) </code>
          <b>initWithCapacity: </b>
          <code>(unsigned) </code><i>numItems </i>
          <br><em>Description forthcoming.</em>


        



<section name="removeAllObjects">
<label id="method**NSMutableDictionary**-removeAllObjects" />- <code>(void) </code>
          <b>removeAllObjects </b>
          <br><em>Description forthcoming.</em>


        



<section name="removeObjectForKey:">
<label id="method**NSMutableDictionary**-removeObjectForKey:" />- <code>(void) </code>
          <b>removeObjectForKey: </b>
          <code>(id) </code><i>aKey </i>
          <br><em>Description forthcoming.</em>


        



<section name="removeObjectsForKeys:">
<label id="method**NSMutableDictionary**-removeObjectsForKeys:" />- <code>(void) </code>
          <b>removeObjectsForKeys: </b>
          <code>(NSArray*) </code><i>keyArray </i>
          <br><em>Description forthcoming.</em>


        



<section name="setDictionary:">
<label id="method**NSMutableDictionary**-setDictionary:" />- <code>(void) </code>
          <b>setDictionary: </b>
          <code>(NSDictionary*) </code><i>otherDictionary </i>
          <br><em>Description forthcoming.</em>


        



<section name="setObject:forKey:">
<label id="method**NSMutableDictionary**-setObject:forKey:" />- <code>(void) </code>
          <b>setObject: </b>
          <code>(id) </code><i>anObject </i>
          <b>forKey: </b>
          <code>(id) </code><i>aKey </i>
          <br><em>Description forthcoming.</em>


        



<section name="takeStoredValue:forKey:">
<label id="method**NSMutableDictionary**-takeStoredValue:forKey:" />- <code>(void) </code>
          <b>takeStoredValue: </b>
          <code>(id) </code><i>value </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>key </i>
          <br>Default implementation for this class is equivalent
            to the
            <ref id="method**NSMutableDictionary**-setObject:forKey:">
              -setObject:forKey:
            </ref>
            method unless <i>value</i> is <code>nil</code>,
            in which case it is equivalent to
            <ref id="method**NSMutableDictionary**-removeObjectForKey:">
              -removeObjectForKey:
            </ref>


        



<section name="takeValue:forKey:">
<label id="method**NSMutableDictionary**-takeValue:forKey:" />- <code>(void) </code>
          <b>takeValue: </b>
          <code>(id) </code><i>value </i>
          <b>forKey: </b>
          <code>(NSString*) </code><i>key </i>
          <br>Default implementation for this class is equivalent
            to the
            <ref id="method**NSMutableDictionary**-setObject:forKey:">
              -setObject:forKey:
            </ref>
            method unless <i>value</i> is <code>nil</code>,
            in which case it is equivalent to
            <ref id="method**NSMutableDictionary**-removeObjectForKey:">
              -removeObjectForKey:
            </ref>


        


        
        
        
        
        
        
        
        
        
        
        
        
      
</section>


</chapter>


<chapter name="NSLongNumber">


<section name="Overview">
<b>Inherits From:  </b><ref id="NSLongNumber">NSLongNumber</ref>: <ref id="NSNumber">NSNumber</ref>: <ref id="NSValue">NSValue</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>NSConcreteNumber.h
</section>

<section name="Description">
<br><em>Description forthcoming.</em>


</section>

<section name="Methods">

        
        
      
</section>


</chapter>


<chapter name="GSXPathBoolean">


<section name="Overview">
<b>Inherits From:  </b><ref id="GSXPathBoolean">GSXPathBoolean</ref>: <ref id="GSXPathObject">GSXPathObject</ref>: <ref id="NSObject">NSObject</ref><br><b>Declared in: </b>GSXML.h
</section>

<section name="Description">
<br>For XPath queries returning true/false.


</section>

<section name="Methods">


<section name="booleanValue">
<label id="method**GSXPathBoolean**-booleanValue" />- <code>(BOOL) </code>
          <b>booleanValue </b>
          <br><em>Description forthcoming.</em>


        


        
        
        
      
</section>


</chapter></document>
